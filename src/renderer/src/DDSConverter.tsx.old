/**
 * DDS Converter UI Component
 * Full-featured texture conversion interface with batch processing
 */

import React, { useState, useEffect } from 'react';
import { 
  Image, FileImage, Layers, Zap, Download, Upload, 
  Settings, CheckCircle, XCircle, AlertCircle, 
  FolderOpen, RefreshCw, TrendingDown, Clock
} from 'lucide-react';

// Types
type TextureFormat = 'DDS_DXT1' | 'DDS_DXT3' | 'DDS_DXT5' | 'DDS_BC7' | 'DDS_UNCOMPRESSED' | 'PNG' | 'TGA' | 'BMP' | 'JPG';
type TextureType = 'diffuse' | 'normal' | 'specular' | 'emissive' | 'roughness' | 'metallic';
type ConversionMode = 'single' | 'batch';

interface ConversionFile {
  id: string;
  path: string;
  name: string;
  size: number;
  format?: TextureFormat;
  status: 'pending' | 'converting' | 'success' | 'error';
  result?: any;
  error?: string;
}

interface ConversionSettings {
  format: TextureFormat;
  textureType: TextureType;
  generateMipmaps: boolean;
  mipmapLevels?: number;
  quality: 'fast' | 'normal' | 'high' | 'ultra';
  flipY: boolean;
}

export const DDSConverter: React.FC = () => {
  const [mode, setMode] = useState<ConversionMode>('single');
  const [files, setFiles] = useState<ConversionFile[]>([]);
  const [settings, setSettings] = useState<ConversionSettings>({
    format: 'DDS_DXT1',
    textureType: 'diffuse',
    generateMipmaps: true,
    quality: 'high',
    flipY: false
  });
  const [isConverting, setIsConverting] = useState(false);
  const [presets, setPresets] = useState<any>(null);
  const [batchResults, setBatchResults] = useState<any>(null);

  // Load presets on mount
  useEffect(() => {
    loadPresets();
  }, []);

  const loadPresets = async () => {
    try {
      const result = await (window.electron.api as any).ddsGetAllPresets();
      if (result.success) {
        setPresets(result.presets);
      }
    } catch (error) {
      console.error('Failed to load presets:', error);
    }
  };

  const handlePickFiles = async () => {
    try {
      const result = await (window.electron.api as any).ddsPickFiles();
      if (result.success && result.paths) {
        const newFiles: ConversionFile[] = result.paths.map((path: string) => ({
          id: Math.random().toString(36).substr(2, 9),
          path,
          name: path.split(/[\\/]/).pop() || 'Unknown',
          size: 0,
          status: 'pending' as const
        }));
        
        setFiles(mode === 'single' ? [newFiles[0]] : newFiles);
        
        // Detect formats
        for (const file of newFiles) {
          detectFileFormat(file.path, file.id);
        }
      }
    } catch (error) {
      console.error('File picker error:', error);
      alert('Failed to open file picker');
    }
  };

  const detectFileFormat = async (filePath: string, fileId: string) => {
    try {
      const result = await (window.electron.api as any).ddsDetectFormat(filePath);
      if (result.success) {
        setFiles(prev => prev.map(f => 
          f.id === fileId ? { ...f, format: result.format } : f
        ));
      }
    } catch (error) {
      console.error('Format detection error:', error);
    }
  };

  const handleApplyPreset = async (type: TextureType) => {
    try {
      const result = await (window.electron.api as any).ddsGetPreset(type);
      if (result.success && result.preset) {
        setSettings({
          format: result.preset.format,
          textureType: type,
          generateMipmaps: result.preset.generateMipmaps,
          quality: result.preset.quality,
          flipY: result.preset.flipY
        });
      }
    } catch (error) {
      console.error('Preset application error:', error);
    }
  };

  const handleConvert = async () => {
    if (files.length === 0) {
      alert('Please select files to convert');
      return;
    }

    setIsConverting(true);
    setBatchResults(null);

    if (mode === 'single') {
      // Single file conversion
      const file = files[0];
      try {
        setFiles(prev => prev.map(f => 
          f.id === file.id ? { ...f, status: 'converting' } : f
        ));

        const input = {
          sourcePath: file.path,
          format: settings.format,
          textureType: settings.textureType,
          generateMipmaps: settings.generateMipmaps,
          mipmapLevels: settings.mipmapLevels,
          quality: settings.quality,
          flipY: settings.flipY
        };

        const result = await (window.electron.api as any).ddsConvert(input);
        
        setFiles(prev => prev.map(f => 
          f.id === file.id ? { 
            ...f, 
            status: result.success ? 'success' : 'error',
            result,
            error: result.error
          } : f
        ));
      } catch (error: any) {
        setFiles(prev => prev.map(f => 
          f.id === file.id ? { 
            ...f, 
            status: 'error',
            error: error.message || 'Conversion failed'
          } : f
        ));
      }
    } else {
      // Batch conversion
      try {
        const inputs = files.map(file => ({
          sourcePath: file.path,
          format: settings.format,
          textureType: settings.textureType,
          generateMipmaps: settings.generateMipmaps,
          mipmapLevels: settings.mipmapLevels,
          quality: settings.quality,
          flipY: settings.flipY
        }));

        const result = await (window.electron.api as any).ddsConvertBatch(inputs);
        
        setBatchResults(result);
        
        // Update individual file statuses
        setFiles(prev => prev.map((file, index) => ({
          ...file,
          status: result.results[index]?.success ? 'success' : 'error',
          result: result.results[index],
          error: result.results[index]?.error
        })));
      } catch (error: any) {
        alert('Batch conversion failed: ' + error.message);
      }
    }

    setIsConverting(false);
  };

  const handleRemoveFile = (fileId: string) => {
    setFiles(prev => prev.filter(f => f.id !== fileId));
  };

  const handleClear = () => {
    setFiles([]);
    setBatchResults(null);
  };

  const formatBytes = (bytes: number) => {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return (bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
  };

  const getFormatBadgeColor = (format: TextureFormat) => {
    const colors: Record<TextureFormat, string> = {
      DDS_DXT1: 'bg-blue-100 text-blue-800 border-blue-300',
      DDS_DXT3: 'bg-purple-100 text-purple-800 border-purple-300',
      DDS_DXT5: 'bg-green-100 text-green-800 border-green-300',
      DDS_BC7: 'bg-orange-100 text-orange-800 border-orange-300',
      DDS_UNCOMPRESSED: 'bg-gray-100 text-gray-800 border-gray-300',
      PNG: 'bg-cyan-100 text-cyan-800 border-cyan-300',
      TGA: 'bg-yellow-100 text-yellow-800 border-yellow-300',
      BMP: 'bg-red-100 text-red-800 border-red-300',
      JPG: 'bg-pink-100 text-pink-800 border-pink-300'
    };
    return colors[format] || 'bg-gray-100 text-gray-800 border-gray-300';
  };

  const renderModeSelector = () => (
    <div className="flex gap-2 mb-6">
      <button
        className={`flex-1 px-4 py-3 rounded-lg font-semibold transition-colors flex items-center justify-center gap-2 ${
          mode === 'single'
            ? 'bg-cyan-600 text-white'
            : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
        }`}
        onClick={() => setMode('single')}
      >
        <FileImage className="w-5 h-5" />
        Single File
      </button>
      <button
        className={`flex-1 px-4 py-3 rounded-lg font-semibold transition-colors flex items-center justify-center gap-2 ${
          mode === 'batch'
            ? 'bg-cyan-600 text-white'
            : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
        }`}
        onClick={() => setMode('batch')}
      >
        <Layers className="w-5 h-5" />
        Batch Processing
      </button>
    </div>
  );

  const renderPresets = () => (
    <div className="bg-gray-800/50 rounded-lg p-6 border border-gray-700 mb-6">
      <h3 className="text-lg font-semibold text-white mb-4 flex items-center gap-2">
        <Zap className="w-5 h-5 text-yellow-400" />
        Quick Presets
      </h3>
      <div className="grid grid-cols-3 gap-3">
        {Object.entries(presets || {}).map(([type, preset]: [string, any]) => (
          <button
            key={type}
            onClick={() => handleApplyPreset(type as TextureType)}
            className="bg-gray-900/50 hover:bg-gray-900 rounded-lg p-4 text-left transition-colors border border-gray-700 hover:border-cyan-500"
          >
            <div className="font-semibold text-white capitalize mb-1">{type}</div>
            <div className="text-xs text-gray-400 mb-2">{preset.format}</div>
            <div className="text-xs text-gray-500">{preset.description}</div>
          </button>
        ))}
      </div>
    </div>
  );

  const renderSettings = () => (
    <div className="bg-gray-800/50 rounded-lg p-6 border border-gray-700 mb-6">
      <h3 className="text-lg font-semibold text-white mb-4 flex items-center gap-2">
        <Settings className="w-5 h-5 text-cyan-400" />
        Conversion Settings
      </h3>
      
      <div className="grid grid-cols-2 gap-4">
        {/* Format Selection */}
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">Target Format</label>
          <select
            value={settings.format}
            onChange={(e) => setSettings({ ...settings, format: e.target.value as TextureFormat })}
            className="w-full px-3 py-2 bg-gray-900 border border-gray-700 rounded text-white"
          >
            <option value="DDS_DXT1">DXT1 (BC1) - 4:1 compression</option>
            <option value="DDS_DXT3">DXT3 (BC2) - Explicit alpha</option>
            <option value="DDS_DXT5">DXT5 (BC3) - Interpolated alpha</option>
            <option value="DDS_BC7">BC7 - High quality</option>
            <option value="DDS_UNCOMPRESSED">Uncompressed RGBA</option>
          </select>
        </div>

        {/* Quality */}
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">Compression Quality</label>
          <select
            value={settings.quality}
            onChange={(e) => setSettings({ ...settings, quality: e.target.value as any })}
            className="w-full px-3 py-2 bg-gray-900 border border-gray-700 rounded text-white"
          >
            <option value="fast">Fast (lower quality)</option>
            <option value="normal">Normal</option>
            <option value="high">High</option>
            <option value="ultra">Ultra (best quality)</option>
          </select>
        </div>

        {/* Texture Type */}
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">Texture Type</label>
          <select
            value={settings.textureType}
            onChange={(e) => setSettings({ ...settings, textureType: e.target.value as TextureType })}
            className="w-full px-3 py-2 bg-gray-900 border border-gray-700 rounded text-white"
          >
            <option value="diffuse">Diffuse / Color</option>
            <option value="normal">Normal Map</option>
            <option value="specular">Specular</option>
            <option value="emissive">Emissive / Glow</option>
            <option value="roughness">Roughness (PBR)</option>
            <option value="metallic">Metallic (PBR)</option>
          </select>
        </div>

        {/* Mipmap Levels */}
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">Mipmap Levels</label>
          <input
            type="number"
            min="0"
            max="16"
            value={settings.mipmapLevels || 0}
            onChange={(e) => setSettings({ ...settings, mipmapLevels: parseInt(e.target.value) || undefined })}
            placeholder="Auto (0)"
            className="w-full px-3 py-2 bg-gray-900 border border-gray-700 rounded text-white"
          />
        </div>
      </div>

      <div className="flex gap-4 mt-4">
        <label className="flex items-center gap-2 text-white cursor-pointer">
          <input
            type="checkbox"
            checked={settings.generateMipmaps}
            onChange={(e) => setSettings({ ...settings, generateMipmaps: e.target.checked })}
            className="w-4 h-4"
          />
          Generate Mipmaps
        </label>
        <label className="flex items-center gap-2 text-white cursor-pointer">
          <input
            type="checkbox"
            checked={settings.flipY}
            onChange={(e) => setSettings({ ...settings, flipY: e.target.checked })}
            className="w-4 h-4"
          />
          Flip Vertically (Normal Maps)
        </label>
      </div>
    </div>
  );

  const renderFileList = () => (
    <div className="bg-gray-800/50 rounded-lg p-6 border border-gray-700 mb-6">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-semibold text-white flex items-center gap-2">
          <FolderOpen className="w-5 h-5 text-cyan-400" />
          Files ({files.length})
        </h3>
        <div className="flex gap-2">
          <button
            onClick={handlePickFiles}
            className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded transition-colors flex items-center gap-2"
          >
            <Upload className="w-4 h-4" />
            {mode === 'single' ? 'Select File' : 'Add Files'}
          </button>
          {files.length > 0 && (
            <button
              onClick={handleClear}
              className="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded transition-colors"
            >
              Clear All
            </button>
          )}
        </div>
      </div>

      {files.length === 0 ? (
        <div className="text-center py-12 text-gray-400">
          <Image className="w-16 h-16 mx-auto mb-4 opacity-50" />
          <p>No files selected</p>
          <p className="text-sm mt-2">Click "Select File" to choose textures to convert</p>
        </div>
      ) : (
        <div className="space-y-2">
          {files.map((file) => (
            <div
              key={file.id}
              className="bg-gray-900/50 rounded-lg p-4 border border-gray-700 flex items-center gap-4"
            >
              {/* Status Icon */}
              <div>
                {file.status === 'pending' && <Clock className="w-6 h-6 text-gray-400" />}
                {file.status === 'converting' && <RefreshCw className="w-6 h-6 text-cyan-400 animate-spin" />}
                {file.status === 'success' && <CheckCircle className="w-6 h-6 text-green-400" />}
                {file.status === 'error' && <XCircle className="w-6 h-6 text-red-400" />}
              </div>

              {/* File Info */}
              <div className="flex-1">
                <div className="font-semibold text-white">{file.name}</div>
                <div className="text-sm text-gray-400 flex items-center gap-3 mt-1">
                  {file.format && (
                    <span className={`text-xs px-2 py-0.5 rounded border ${getFormatBadgeColor(file.format)}`}>
                      {file.format}
                    </span>
                  )}
                  {file.result && (
                    <>
                      <span>{file.result.width}x{file.result.height}</span>
                      <span>{formatBytes(file.result.originalSize)} â†’ {formatBytes(file.result.convertedSize)}</span>
                      <span className="text-green-400">{file.result.compressionRatio.toFixed(2)}:1</span>
                      <span>{file.result.mipmapCount} mipmaps</span>
                      <span>{file.result.processingTime}ms</span>
                    </>
                  )}
                  {file.error && <span className="text-red-400">{file.error}</span>}
                </div>
              </div>

              {/* Remove Button */}
              {file.status === 'pending' && (
                <button
                  onClick={() => handleRemoveFile(file.id)}
                  className="text-gray-400 hover:text-red-400 transition-colors"
                >
                  <XCircle className="w-5 h-5" />
                </button>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );

  const renderBatchResults = () => {
    if (!batchResults) return null;

    return (
      <div className="bg-gray-800/50 rounded-lg p-6 border border-gray-700 mb-6">
        <h3 className="text-lg font-semibold text-white mb-4 flex items-center gap-2">
          <TrendingDown className="w-5 h-5 text-green-400" />
          Batch Results
        </h3>
        <div className="grid grid-cols-4 gap-4">
          <div className="bg-gray-900/50 rounded p-4">
            <div className="text-sm text-gray-400 mb-1">Total Files</div>
            <div className="text-2xl font-bold text-white">{batchResults.totalFiles}</div>
          </div>
          <div className="bg-gray-900/50 rounded p-4">
            <div className="text-sm text-gray-400 mb-1">Success</div>
            <div className="text-2xl font-bold text-green-400">{batchResults.successCount}</div>
          </div>
          <div className="bg-gray-900/50 rounded p-4">
            <div className="text-sm text-gray-400 mb-1">Failed</div>
            <div className="text-2xl font-bold text-red-400">{batchResults.failureCount}</div>
          </div>
          <div className="bg-gray-900/50 rounded p-4">
            <div className="text-sm text-gray-400 mb-1">Compression</div>
            <div className="text-2xl font-bold text-cyan-400">{batchResults.totalCompressionRatio.toFixed(2)}:1</div>
          </div>
        </div>
        <div className="mt-4 text-sm text-gray-400">
          <div>Original Size: {formatBytes(batchResults.totalOriginalSize)}</div>
          <div>Converted Size: {formatBytes(batchResults.totalConvertedSize)}</div>
          <div>Processing Time: {(batchResults.totalProcessingTime / 1000).toFixed(2)}s</div>
        </div>
      </div>
    );
  };

  const renderConvertButton = () => (
    <div className="flex justify-center">
      <button
        onClick={handleConvert}
        disabled={files.length === 0 || isConverting}
        className="px-8 py-4 bg-gradient-to-r from-cyan-600 to-blue-600 hover:from-cyan-700 hover:to-blue-700 disabled:from-gray-600 disabled:to-gray-700 disabled:cursor-not-allowed text-white rounded-lg font-bold text-lg transition-colors flex items-center gap-3 shadow-lg"
      >
        {isConverting ? (
          <>
            <RefreshCw className="w-6 h-6 animate-spin" />
            Converting...
          </>
        ) : (
          <>
            <Download className="w-6 h-6" />
            Convert {mode === 'batch' && files.length > 0 && `${files.length} Files`}
          </>
        )}
      </button>
    </div>
  );

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 p-6">
      <div className="max-w-7xl mx-auto">
        {/* Header */}
        <div className="mb-8">
          <h1 className="text-3xl font-bold text-white mb-2 flex items-center gap-3">
            <Image className="w-8 h-8 text-cyan-400" />
            DDS Texture Converter
          </h1>
          <p className="text-gray-400">
            Convert textures to DDS with compression, mipmap generation, and batch processing
          </p>
        </div>

        {/* Mode Selector */}
        {renderModeSelector()}

        {/* Presets */}
        {presets && renderPresets()}

        {/* Settings */}
        {renderSettings()}

        {/* File List */}
        {renderFileList()}

        {/* Batch Results */}
        {renderBatchResults()}

        {/* Convert Button */}
        {renderConvertButton()}
      </div>
    </div>
  );
};
