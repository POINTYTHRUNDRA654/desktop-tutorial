/**
 * Shared TypeScript types for the Desktop AI Assistant
 * Used across main, renderer, and preload processes
 */

/**
 * Project management types for multi-project support
 */
export interface ModProject {
  id: string;
  name: string;
  description?: string;
  path: string; // Root directory of the project
  game: 'fallout4' | 'skyrim' | 'skyrimse' | 'fallout76' | 'other';
  createdAt: number;
  updatedAt: number;
  settings: ProjectSettings;
  collaborators?: Collaborator[];
  versionControl?: VersionControlConfig;
  metadata: {
    modFiles: string[];
    lastBackup?: number;
    size: number; // in bytes
    tags: string[];
  };
}

export interface ProjectSettings {
  // Tool paths specific to this project
  xeditPath?: string;
  nifSkopePath?: string;
  creationKitPath?: string;
  blenderPath?: string;

  // Game-specific settings
  gamePath?: string;
  dataPath?: string;

  // Build/output settings
  outputPath?: string;
  archivePath?: string;

  // Workflow preferences
  preferredTools: string[];
  autoBackup: boolean;
  backupInterval: number; // minutes
}

/**
 * Collaboration types
 */
export interface Collaborator {
  id: string;
  name: string;
  email?: string;
  role: 'owner' | 'editor' | 'viewer';
  avatar?: string;
  lastActive: number;
  permissions: {
    canEdit: boolean;
    canDelete: boolean;
    canInvite: boolean;
    canManageSettings: boolean;
  };
}

export interface VersionControlConfig {
  type: 'git' | 'svn' | 'none';
  repository?: string;
  branch: string;
  remote?: string;
  autoCommit: boolean;
  commitMessageTemplate: string;
  ignorePatterns: string[];
}

export interface CollaborationSession {
  id: string;
  projectId: string;
  participants: Collaborator[];
  activeFiles: string[];
  lastActivity: number;
  status: 'active' | 'idle' | 'ended';
}

/**
 * Roadmap System: Dynamic progress checklists for modding goals
 */
export interface RoadmapStep {
  id: string;
  title: string;
  description: string;
  status: 'not-started' | 'in-progress' | 'completed' | 'blocked';
  tool?: 'blender' | 'ck' | 'xedit' | 'nifskope' | 'image-suite' | 'scribe';
  order: number;
  completionCriteria?: string;
  resources?: { title: string; url: string }[];
}

export interface Roadmap {
  id: string;
  projectId: string; // Roadmap is bound to a project
  title: string;
  goal: string;
  icon?: string;
  steps: RoadmapStep[];
  currentStepId?: string;
  isCustom: boolean; // True if generated by AI for a specific prompt
  createdAt: number;
  updatedAt: number;
}

/**
 * Project Wizard: Guided flows for common modding tasks (Phase 3)
 */
export interface WizardStep {
  id: string;
  title: string;
  description: string;
  status: 'not-started' | 'in-progress' | 'completed';
  type: 'script' | 'blender' | 'audit' | 'setup';
  data?: any; // Stores progress or configuration for this step (e.g., source file path)
}

export interface ProjectWizardState {
  id: string;
  projectId: string;
  name: string;
  steps: WizardStep[];
  currentStepIndex: number;
  lastUpdated: number;
}

/**
 * Analytics types
 */
export interface AnalyticsEvent {
  id: string;
  timestamp: number;
  event: string;
  category: 'usage' | 'performance' | 'error' | 'feature';
  properties: Record<string, any>;
  userId?: string; // Anonymous ID
  sessionId: string;
  version: string;
  platform: string;
}

export interface AnalyticsConfig {
  enabled: boolean;
  anonymousId: string;
  userId?: string;
  consentedAt?: number;
  dataRetentionDays: number;
  categories: {
    usage: boolean;
    performance: boolean;
    errors: boolean;
    features: boolean;
  };
  destinations: {
    local: boolean; // Store locally for debugging
    remote: boolean; // Send to analytics service
  };
}

export interface UsageMetrics {
  sessionStart: number;
  sessionDuration: number;
  featuresUsed: string[];
  toolsLaunched: string[];
  filesProcessed: number;
  errorsEncountered: number;
  performanceMetrics: {
    avgResponseTime: number;
    memoryUsage: number;
    cpuUsage: number;
  };
}

/**
 * Message in the chat history
 */
export interface Message {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: number;
}

/**
 * Application settings stored persistently
 */
export interface Settings {
    // Secure API keys for backend TTS/STT (main process only)
    openaiApiKey?: string;
    groqApiKey?: string;
    elevenLabsApiKey?: string;
  // Backend configuration
  backendBaseUrl?: string;
  backendTokenConfigured?: boolean;
  // LLM Configuration
  llmApiEndpoint: string;
  llmApiKey?: string;
  llmModel: string;

  // Local AI (optional)
  localAiPreferredProvider?: 'auto' | 'cosmos' | 'ollama' | 'openai_compat' | 'off';
  ollamaBaseUrl?: string;
  ollamaModel?: string;
  openaiCompatBaseUrl?: string;
  openaiCompatModel?: string;
  cosmosBaseUrl?: string;
  cosmosModel?: string;
  
  // Audio Settings
  ttsEnabled: boolean;
  ttsVoice: string;
  ttsRate: number;
  ttsPitch: number;
  sttEnabled: boolean;
  sttLanguage: string;

  // UI Settings
  theme: 'light' | 'dark' | 'system';
  /** UI language (BCP-47 tag like 'en', 'en-US', 'es', or 'auto' to follow OS). */
  uiLanguage?: string;
  alwaysOnTop: boolean;
  startMinimized: boolean;
  
  // Behavior
  autoStart: boolean;
  globalHotkey?: string;

  // External Modding Tools
  xeditPath?: string;
  nifSkopePath?: string;
  xeditScriptsDirOverride?: string;
  fomodCreatorPath?: string;
  creationKitPath?: string;
  blenderPath?: string;
  lootPath?: string;
  vortexPath?: string;
  mo2Path?: string;
  
  // Game Paths
  fallout4Path?: string;

  // Creation Kit / Papyrus
  papyrusCompilerPath?: string;
  papyrusFlagsPath?: string;
  papyrusImportPaths?: string; // semicolon-separated
  papyrusSourcePath?: string; // where .psc live (e.g. Data\\Scripts\\Source\\User)
  papyrusOutputPath?: string; // where .pex output goes (e.g. Data\\Scripts)
  papyrusTemplateLibrary?: PapyrusTemplate[];

  // Script libraries (The Scribe)
  xeditScriptLibrary?: ScriptTemplate[];
  blenderScriptLibrary?: ScriptTemplate[];
  scriptBundles?: ScriptBundle[];
  wryeBashPath?: string;
  bodySlidePath?: string;
  outfitStudioPath?: string;
  baePath?: string;
  gimpPath?: string;
  archive2Path?: string;
  pjmScriptPath?: string;
  f4sePath?: string;
  upscaylPath?: string;
  photopeaPath?: string;
  shaderMapPath?: string;
  nvidiaTextureToolsPath?: string;
  autodeskFbxPath?: string;
  photoDemonPath?: string;
  unWrap3Path?: string;
  nifUtilsSuitePath?: string;
  nvidiaOmniversePath?: string;
  spin3dPath?: string;
  nvidiaCanvasPath?: string;

  // Community Sharing
  communityRepo?: string; // GitHub repo in the form "owner/repo"
  communityContributorName?: string;
  communityContributorLink?: string;

  // Load Order Lab (experimental)
  loadOrderLabXeditPresetId?: string;
  loadOrderLabXeditArgsTemplate?: string;
  loadOrderLabXeditArgsEnabled?: boolean;
  loadOrderLabPreparedScriptPath?: string;

  // Workflow Runner
  workflowRunnerWorkflows?: WorkflowRunnerWorkflow[];
  workflowRunnerRunHistory?: WorkflowRunnerRun[];

  // Privacy & Security Settings
  privacySettings: {
    // Data Collection & Sharing
    allowAnalytics: boolean;
    allowCrashReporting: boolean;
    allowUsageMetrics: boolean;
    shareModProjectData: boolean;
    shareScriptPatterns: boolean;
    shareMeshOptimizations: boolean;
    contributeToKnowledgeBase: boolean;

    // Data Retention
    keepLocalOnly: boolean;
    autoDeleteOldData: boolean;
    dataRetentionDays: number;

    // Permissions
    allowFileSystemAccess: boolean;
    allowNetworkAccess: boolean;
    allowExternalTools: boolean;
    allowClipboardAccess: boolean;

    // Security
    requirePasswordForSettings: boolean;
    encryptLocalData: boolean;
    autoLockAfterInactivity: boolean;
    inactivityTimeoutMinutes: number;
  };

  // Security Settings
  securitySettings: {
    // API Key Management
    apiKeyRotationEnabled: boolean;
    apiKeyRotationDays: number;
    requireApiKeyConfirmation: boolean;

    // Encryption
    encryptionEnabled: boolean;
    encryptionAlgorithm: 'aes-256-gcm' | 'chacha20-poly1305';

    // Access Control
    allowedDomains: string[];
    blockedDomains: string[];
    requireHttps: boolean;
  };

  // Multi-Project Support
  currentProjectId?: string;
  projects: ModProject[];

  // Project Wizard (Phase 3)
  wizardStates: ProjectWizardState[];

  // Collaboration Features
  collaborationEnabled: boolean;
  collaborationSessions: CollaborationSession[];

  // Advanced Analytics
  analytics: AnalyticsConfig;
}

/**
 * Installed program information
 */
export interface InstalledProgram {
  name: string;
  displayName: string;
  path: string;
  icon?: string;
  version?: string;
  publisher?: string;
}

/**
 * System information for AI/modding capabilities
 */
export interface SystemInfo {
  cpu: string;
  ram: string;
  gpu: string[];
  os: string;
  aiCapabilities: string[];
  pythonVersions: string[];
  nodeVersion: string | null;
}

export type WorkflowRunnerStepType = 'runTool' | 'openProgram' | 'openExternal' | 'revealInFolder';

export interface WorkflowRunnerStep {
  id: string;
  type: WorkflowRunnerStepType;
  label: string;
  cmd?: string;
  args?: string;
  cwd?: string;
  target?: string;
}

export interface WorkflowRunnerWorkflow {
  id: string;
  name: string;
  description?: string;
  steps: WorkflowRunnerStep[];
  createdAt: string;
  updatedAt: string;
}

export interface WorkflowRunnerRun {
  id: string;
  workflowId: string;
  workflowName: string;
  startedAt: string;
  endedAt: string;
  success: boolean;
  logs: Array<{ at: string; level: 'info' | 'warn' | 'error'; message: string }>;
}

export interface PapyrusTemplate {
  id: string;
  title: string;
  description?: string;
  author?: string;
  scriptName: string;
  extendsType: string;
  templateKind?: string;
  body: string;
  createdAt: string;
  updatedAt: string;
}

export interface ScriptTemplate {
  id: string;
  title: string;
  description?: string;
  author?: string;
  scriptType: 'xedit' | 'blender';
  body: string;
  createdAt: string;
  updatedAt: string;
}

export interface ScriptBundle {
  id: string;
  title: string;
  description?: string;
  author?: string;
  templates: ScriptTemplate[];
  createdAt: string;
  updatedAt: string;
}

/**
 * Default settings
 */
export const DEFAULT_SETTINGS: Settings = {
  llmApiEndpoint: 'https://api.openai.com/v1/chat/completions',
  llmModel: 'gpt-3.5-turbo',
  localAiPreferredProvider: 'auto',
  ollamaBaseUrl: 'http://127.0.0.1:11434',
  ollamaModel: 'llama3',
  openaiCompatBaseUrl: 'http://127.0.0.1:1234/v1',
  openaiCompatModel: '',
  cosmosBaseUrl: '',
  cosmosModel: '',
  ttsEnabled: true,
  ttsVoice: 'default',
  ttsRate: 1.0,
  ttsPitch: 1.0,
  sttEnabled: true,
  sttLanguage: 'en-US',
  theme: 'system',
  uiLanguage: 'auto',
  alwaysOnTop: false,
  startMinimized: false,
  autoStart: false,
  // Tool paths empty by default; user configures in settings
  xeditPath: '',
    xeditScriptsDirOverride: '',
  nifSkopePath: '',
  fomodCreatorPath: '',
  creationKitPath: '',
  blenderPath: '',
  lootPath: '',
  vortexPath: '',
  mo2Path: '',
  fallout4Path: '',
  wryeBashPath: '',
  bodySlidePath: '',
  outfitStudioPath: '',
  baePath: '',
  gimpPath: '',
  archive2Path: '',
  pjmScriptPath: '',
  f4sePath: '',
  upscaylPath: '',
  photopeaPath: '',
  shaderMapPath: '',
  nvidiaTextureToolsPath: '',
  autodeskFbxPath: '',
  photoDemonPath: '',
  unWrap3Path: '',
  nifUtilsSuitePath: '',
  nvidiaOmniversePath: '',
  spin3dPath: '',
  nvidiaCanvasPath: '',

  // Papyrus
  papyrusCompilerPath: '',
  papyrusFlagsPath: '',
  papyrusImportPaths: '',
  papyrusSourcePath: '',
  papyrusOutputPath: '',
  papyrusTemplateLibrary: [],

  // Script libraries (The Scribe)
  xeditScriptLibrary: [],
  blenderScriptLibrary: [],
  scriptBundles: [],

  // Community Sharing
  communityRepo: '',
  communityContributorName: '',
  communityContributorLink: '',

  // Load Order Lab (experimental)
  loadOrderLabXeditPresetId: 'fo4edit-script-quoted',
  loadOrderLabXeditArgsTemplate: '',
  loadOrderLabXeditArgsEnabled: false,
  loadOrderLabPreparedScriptPath: '',

  // Workflow Runner
  workflowRunnerWorkflows: [],
  workflowRunnerRunHistory: [],

  // Privacy & Security Settings
  privacySettings: {
    // Data Collection & Sharing
    allowAnalytics: false,
    allowCrashReporting: false,
    allowUsageMetrics: false,
    shareModProjectData: false,
    shareScriptPatterns: false,
    shareMeshOptimizations: false,
    contributeToKnowledgeBase: false,

    // Data Retention
    keepLocalOnly: true,
    autoDeleteOldData: false,
    dataRetentionDays: 365,

    // Permissions
    allowFileSystemAccess: true,
    allowNetworkAccess: true,
    allowExternalTools: true,
    allowClipboardAccess: true,

    // Security
    requirePasswordForSettings: false,
    encryptLocalData: true,
    autoLockAfterInactivity: false,
    inactivityTimeoutMinutes: 30,
  },

  // Security Settings
  securitySettings: {
    // API Key Management
    apiKeyRotationEnabled: false,
    apiKeyRotationDays: 90,
    requireApiKeyConfirmation: true,

    // Encryption
    encryptionEnabled: true,
    encryptionAlgorithm: 'aes-256-gcm',

    // Access Control
    allowedDomains: [],
    blockedDomains: [],
    requireHttps: true,
  },

  // Multi-Project Support
  currentProjectId: undefined,
  projects: [],

  // Project Wizard (Phase 3)
  wizardStates: [],

  // Collaboration Features
  collaborationEnabled: false,
  collaborationSessions: [],

  // Advanced Analytics
  analytics: {
    enabled: false,
    anonymousId: '',
    dataRetentionDays: 90,
    categories: {
      usage: false,
      performance: false,
      errors: false,
      features: false,
    },
    destinations: {
      local: true,
      remote: false,
    },
  },
};

/**
 * IPC Channel names for main <-> renderer communication
 */
export const IPC_CHANNELS = {
  // Messages
  SEND_MESSAGE: 'send-message',
  ON_MESSAGE: 'on-message',

  // Settings
  GET_SETTINGS: 'get-settings',
  SET_SETTINGS: 'set-settings',
  SETTINGS_UPDATED: 'settings-updated',

  // Audio
  TTS_SPEAK: 'tts-speak',
  STT_START: 'stt-start',
  STT_STOP: 'stt-stop',
  STT_RESULT: 'stt-result',

  // Window
  MINIMIZE_WINDOW: 'minimize-window',
  CLOSE_WINDOW: 'close-window',

  // Workshop
  WORKSHOP_READ_DDS_PREVIEW: 'workshop-read-dds-preview',
  WORKSHOP_READ_NIF_INFO: 'workshop-read-nif-info',
  WORKSHOP_PARSE_SCRIPT_DEPS: 'workshop-parse-script-deps',

  // Image Suite
  IMAGE_GET_INFO: 'image-get-info',
  IMAGE_GENERATE_NORMAL_MAP: 'image-generate-normal-map',
  IMAGE_GENERATE_ROUGHNESS_MAP: 'image-generate-roughness-map',
  IMAGE_GENERATE_HEIGHT_MAP: 'image-generate-height-map',
  IMAGE_GENERATE_METALLIC_MAP: 'image-generate-metallic-map',
  IMAGE_GENERATE_AO_MAP: 'image-generate-ao-map',
  IMAGE_CONVERT_FORMAT: 'image-convert-format',

  // FOMOD Assembler
  FOMOD_SCAN_MOD_FOLDER: 'fomod-scan-mod-folder',
  FOMOD_ANALYZE_STRUCTURE: 'fomod-analyze-structure',
  FOMOD_VALIDATE_XML: 'fomod-validate-xml',
  FOMOD_EXPORT_PACKAGE: 'fomod-export-package',

  // Save/Load
  SAVE_FILE: 'save-file',
  PICK_JSON_FILE: 'pick-json-file',
  PICK_DIRECTORY: 'pick-directory',

  // Local ML
  ML_INDEX_BUILD: 'ml-index-build',
  ML_INDEX_STATUS: 'ml-index-status',
  ML_INDEX_QUERY: 'ml-index-query',
  ML_CAPS_STATUS: 'ml-caps-status',
  ML_LLM_STATUS: 'ml-llm-status',
  ML_LLM_GENERATE: 'ml-llm-generate',

  // Load Order Lab
  LOAD_ORDER_PICK_MO2_PROFILE_DIR: 'load-order-pick-mo2-profile-dir',
  LOAD_ORDER_PICK_LOOT_REPORT_FILE: 'load-order-pick-loot-report-file',
  LOAD_ORDER_WRITE_USERDATA_FILE: 'load-order-write-userdata-file',
  LOAD_ORDER_LAUNCH_XEDIT: 'load-order-launch-xedit',

  // Secrets
  SECRET_STATUS: 'secret-status',

  // STT/Transcription
  TRANSCRIBE_AUDIO: 'transcribe-audio',

  // Duplicate Finder
  DEDUPE_PICK_FOLDERS: 'dedupe-pick-folders',
  DEDUPE_SCAN: 'dedupe-scan',
  DEDUPE_CANCEL: 'dedupe-cancel',
  DEDUPE_PROGRESS: 'dedupe-progress',
  DEDUPE_TRASH: 'dedupe-trash',

  // Multi-Project Support
  PROJECT_CREATE: 'project-create',
  PROJECT_UPDATE: 'project-update',
  PROJECT_DELETE: 'project-delete',
  PROJECT_SWITCH: 'project-switch',
  PROJECT_LIST: 'project-list',
  PROJECT_GET_CURRENT: 'project-get-current',

  // Roadmap System
  ROADMAP_GET_ALL: 'roadmap-get-all',
  ROADMAP_GET_ACTIVE: 'roadmap-get-active',
  ROADMAP_CREATE: 'roadmap-create',
  ROADMAP_UPDATE_STEP: 'roadmap-update-step',
  ROADMAP_DELETE: 'roadmap-delete',
  ROADMAP_GENERATE_AI: 'roadmap-generate-ai',

  // Project Wizard (Phase 3)
  WIZARD_GET_STATE: 'wizard-get-state',
  WIZARD_UPDATE_STEP: 'wizard-update-step',
  WIZARD_SUBMIT_ACTION: 'wizard-submit-action',

  // Proactive Observer (Neural Link+)
  OBSERVER_NOTIFY: 'observer-notify', // Sent from Main to Renderer
  OBSERVER_SET_ACTIVE_FOLDER: 'observer-set-active-folder',

  // Collaboration Features
  COLLABORATION_JOIN_SESSION: 'collaboration-join-session',
  COLLABORATION_LEAVE_SESSION: 'collaboration-leave-session',
  COLLABORATION_SYNC_FILE: 'collaboration-sync-file',
  COLLABORATION_UPDATE_PARTICIPANTS: 'collaboration-update-participants',
  COLLABORATION_GIT_INIT: 'collaboration-git-init',
  COLLABORATION_GIT_COMMIT: 'collaboration-git-commit',
  COLLABORATION_GIT_PUSH: 'collaboration-git-push',
  COLLABORATION_GIT_PULL: 'collaboration-git-pull',

  // Advanced Analytics
  ANALYTICS_TRACK_EVENT: 'analytics-track-event',
  ANALYTICS_GET_METRICS: 'analytics-get-metrics',
  ANALYTICS_EXPORT_DATA: 'analytics-export-data',
  ANALYTICS_UPDATE_CONFIG: 'analytics-update-config',

  // Scribe Advanced (Phase 4)
  SCRIBE_INSTALL_SCRIPT: 'scribe-install-script',
} as const;

/**
 * Mining Infrastructure Types
 */

// ESP/ESM File Structures
export interface ESPRecord {
  type: string; // Record type (e.g., 'TES4', 'WEAP', 'ARMO')
  formId: number;
  editorId?: string;
  flags: number;
  fields: ESPField[];
  subrecords?: ESPRecord[];
  // Extended properties for analysis
  name?: string;
  references?: number[]; // FormIDs this record references
  dependencies?: number[]; // FormIDs this record depends on
  cellId?: number; // For CELL records
  isAddition?: boolean; // For cell modifications
  isDeletion?: boolean; // For cell modifications
  baseObject?: string; // Object type being modified
  position?: { x: number; y: number; z: number }; // For placed objects
  deletionReason?: string; // Why object was deleted
}

export interface ESPField {
  type: string; // Field type (e.g., 'EDID', 'FULL', 'DATA')
  data: Buffer;
  size: number;
}

export interface ESPFile {
  fileName: string; // The name of the ESP file
  header: ESPRecord;
  records: ESPRecord[];
  masters: string[]; // Master files this plugin depends on
  formIdMap: Map<number, ESPRecord>; // Quick lookup by FormID
}

export interface DDSFile {
  fileName: string;
  path: string;
  format: string;
  resolution: { width: number; height: number };
  mipmaps: number;
  size: number;
  compression: string;
  metadata: {
    lastModified: number;
    hash?: string;
  };
}

export interface NIFFile {
  fileName: string;
  path: string;
  version: string;
  vertexCount: number;
  triangleCount: number;
  materialCount: number;
  texturePaths: string[];
  boundingBox: {
    min: [number, number, number];
    max: [number, number, number];
  };
  size: number;
  metadata: {
    lastModified: number;
    hash?: string;
  };
}

export interface INIFile {
  fileName: string;
  path: string;
  sections: Map<string, Map<string, string>>;
  comments: Map<string, string[]>;
  size: number;
  metadata: {
    lastModified: number;
    hash?: string;
  };
}

// Asset Correlation Types
export interface AssetReference {
  type: 'nif' | 'dds' | 'hkx' | 'seq' | 'wav' | 'fuz';
  path: string;
  formId?: number;
  recordType?: string;
}

export interface AssetCorrelation {
  primaryAsset: AssetReference;
  relatedAssets: AssetReference[];
  dependencies: string[]; // File paths this asset depends on
  dependents: string[]; // Files that depend on this asset
  metadata: {
    size: number;
    lastModified: number;
    hash?: string;
  };
}

// Mod Dependency Graph
export interface ModNode {
  name: string;
  filename: string;
  masters: string[]; // Required master files
  optionalMasters: string[]; // Optional master files
  providedRecords: Map<string, number[]>; // Record types and FormIDs provided
  requiredRecords: Map<string, number[]>; // Record types and FormIDs required
  conflicts: ModConflict[];
  loadOrder: number;
  enabled: boolean;
}

export interface ModConflict {
  type: 'override' | 'conflict' | 'compatibility';
  conflictingMod: string;
  recordType: string;
  formIds: number[];
  severity: 'minor' | 'major' | 'critical';
}

export interface ModDependencyGraph {
  nodes: Map<string, ModNode>;
  edges: ModDependencyEdge[];
  cycles: string[][]; // Detected circular dependencies
  loadOrder: string[]; // Optimal load order
}

export interface ModDependencyEdge {
  from: string; // Mod name
  to: string; // Required mod name
  type: 'master' | 'optional' | 'compatibility';
  weight: number; // Strength of dependency
}

// Performance Metrics
export interface PerformanceMetric {
  modCombination: string[]; // List of mod names
  fps: number;
  memoryUsage: number; // MB
  loadTime: number; // seconds
  stabilityScore: number; // 0-100
  conflictCount: number;
  timestamp: number;
  hardwareProfile: HardwareProfile;
}



export interface PerformanceReport {
  baselineMetrics: PerformanceMetric;
  modImpact: Map<string, PerformanceImpact>;
  recommendations: PerformanceRecommendation[];
  compatibilityMatrix: Map<string, Map<string, number>>; // Mod pairs and compatibility score
}

export interface PerformanceImpact {
  fpsDelta: number;
  memoryDelta: number;
  loadTimeDelta: number;
  stabilityDelta: number;
}

export interface PerformanceRecommendation {
  type: 'disable' | 'reorder' | 'patch' | 'alternative';
  targetMods: string[];
  description: string;
  expectedImprovement: PerformanceImpact;
  confidence: number; // 0-100
}

// Pattern Recognition Engine Types
export interface PatternRecognitionResult {
  patterns: DetectedPattern[];
  anomalies: Anomaly[];
  recommendations: PatternRecommendation[];
  confidence: number;
}

export interface DetectedPattern {
  id: string;
  type: 'conflict' | 'performance' | 'compatibility' | 'resource' | 'script';
  description: string;
  affectedMods: string[];
  severity: 'low' | 'medium' | 'high' | 'critical';
  frequency: number; // How often this pattern occurs
  examples: PatternExample[];
}

export interface PatternExample {
  modCombination: string[];
  outcome: 'success' | 'failure' | 'warning';
  metrics?: PerformanceMetric;
  description: string;
}

export interface Anomaly {
  id: string;
  type: 'performance' | 'memory' | 'compatibility' | 'resource';
  description: string;
  affectedMods: string[];
  deviation: number; // Standard deviations from normal
  severity: 'low' | 'medium' | 'high' | 'critical';
}

export interface PatternRecommendation {
  type: 'avoid' | 'prefer' | 'patch' | 'alternative';
  targetPattern: string;
  description: string;
  confidence: number;
  alternatives?: string[];
}

// Performance Bottleneck Mining Types

export interface PerformanceBottleneck {
  modName: string;
  bottleneckType: 'cpu' | 'gpu' | 'memory' | 'io' | 'script';
  impact: number; // FPS impact
  confidence: number;
  evidence: BottleneckEvidence[];
  mitigationStrategies: string[];
}

export interface BottleneckEvidence {
  metric: string;
  value: number;
  threshold: number;
  description: string;
}

export interface OptimizationOpportunity {
  type: 'texture' | 'mesh' | 'script' | 'config' | 'load_order';
  description: string;
  potentialGain: number; // FPS gain
  difficulty: 'easy' | 'medium' | 'hard';
  affectedMods: string[];
}

// Memory Usage Analysis Types
export interface MemoryAnalysis {
  vramUsage: VRAMUsage;
  systemRamUsage: RAMUsage;
  memoryPatterns: MemoryPattern[];
  recommendations: MemoryRecommendation[];
  leakDetection: MemoryLeak[];
}

export interface VRAMUsage {
  total: number; // MB
  byMod: Map<string, number>;
  byAssetType: Map<string, number>; // textures, meshes, etc.
  peakUsage: number;
  averageUsage: number;
  trends: MemoryTrend[];
}

export interface RAMUsage {
  total: number; // MB
  byMod: Map<string, number>;
  byComponent: Map<string, number>; // scripts, assets, etc.
  peakUsage: number;
  averageUsage: number;
  trends: MemoryTrend[];
}

export interface MemoryTrend {
  timestamp: number;
  usage: number;
  context: string; // load order, specific mod, etc.
}

export interface MemoryPattern {
  type: 'allocation' | 'deallocation' | 'leak' | 'fragmentation';
  description: string;
  frequency: number;
  impact: number;
  affectedMods: string[];
}

export interface MemoryRecommendation {
  type: 'reduce' | 'optimize' | 'reorder' | 'patch';
  description: string;
  potentialSavings: number; // MB
  affectedMods: string[];
}

export interface MemoryLeak {
  modName: string;
  leakType: 'script' | 'asset' | 'resource';
  estimatedSize: number; // MB
  evidence: string[];
  confidence: number;
}

// Compatibility Matrix Mining Types
export interface CompatibilityMatrix {
  matrix: Map<string, Map<string, CompatibilityScore>>;
  clusters: CompatibilityCluster[];
  rules: CompatibilityRule[];
  lastUpdated: number;
  dataPoints: number;
}

export interface CompatibilityScore {
  score: number; // -1 (incompatible) to 1 (perfect)
  confidence: number;
  evidence: CompatibilityEvidence[];
  testedVersions: string[];
  lastTested: number;
}

export interface CompatibilityEvidence {
  type: 'user_report' | 'automated_test' | 'pattern_analysis' | 'historical';
  source: string;
  description: string;
  weight: number;
}

export interface CompatibilityCluster {
  id: string;
  mods: string[];
  compatibility: number; // Average compatibility within cluster
  description: string;
  recommended: boolean;
}

export interface CompatibilityRule {
  id: string;
  condition: string; // Logical condition for compatibility
  action: 'allow' | 'warn' | 'block';
  description: string;
  confidence: number;
  examples: string[];
}

// Cross-Reference Intelligence Types
export interface FormIDRelationshipMap {
  formId: string;
  references: FormIDReference[];
  conflicts: FormIDConflict[];
  dependencies: FormIDDependency[];
  modOwnership: string;
  recordType: string;
}

export interface FormIDReference {
  sourceFormId: string;
  targetFormId: string;
  referenceType: 'parent' | 'child' | 'sibling' | 'override' | 'merge';
  modName: string;
  confidence: number;
}

export interface FormIDConflict {
  conflictingMods: string[];
  conflictType: 'override' | 'duplicate' | 'missing_reference';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  resolution?: string;
}

export interface FormIDDependency {
  dependentFormId: string;
  dependencyFormId: string;
  dependencyType: 'required' | 'optional' | 'conditional';
  modName: string;
}

export interface CellModification {
  modName: string;
  timestamp: number;
  additions: CellAddition[];
  removals: CellRemoval[];
}

export interface CellAddition {
  objectType: string;
  formId: string;
  position: { x: number; y: number; z: number };
}

export interface CellRemoval {
  objectType: string;
  formId: string;
  reason: string;
}

export interface CellWorldspaceAnalysis {
  cellId: string;
  worldspaceId: string;
  mods: CellModInteraction[];
  modifications: CellModification[];
  conflicts: CellConflict[];
  optimizationOpportunities: CellOptimization[];
  performanceImpact: CellPerformanceImpact;
}

export interface CellModInteraction {
  modName: string;
  changes: CellChange[];
  additions: CellAddition[];
  removals: CellRemoval[];
  timestamp: number;
}

export interface CellChange {
  changeType: 'navmesh' | 'lighting' | 'placement' | 'landscape' | 'water';
  description: string;
  impact: 'low' | 'medium' | 'high';
}

export interface CellAddition {
  objectType: string;
  formId: string;
  position: { x: number; y: number; z: number };
  modName: string;
}

export interface CellRemoval {
  objectType: string;
  formId: string;
  reason: string;
  modName: string;
}

export interface CellConflict {
  conflictType: 'placement' | 'removal' | 'modification';
  severity: 'low' | 'medium' | 'high';
  mods: string[];
  description: string;
  cellId: string;
  position?: { x: number; y: number; z: number };
  objects?: Array<{ formId: string; objectType: string }>;
  affectedObjects?: string[];
  resolution?: string;
}

export interface CellOptimization {
  optimizationType: 'performance' | 'layout' | 'lod' | 'occlusion' | 'batching' | 'streaming';
  description: string;
  cellId?: string;
  suggestedActions?: string[];
  expectedImprovement?: {
    fps: number;
    memory: number;
    loadTime: number;
  };
  potentialGain?: number;
  difficulty?: 'easy' | 'medium' | 'hard';
}

export interface CellPerformanceImpact {
  fpsImpact: number;
  memoryImpact: number;
  loadTimeImpact: number;
  streamingImpact: number;
}

export interface QuestObjectiveAnalysis {
  questId: string;
  questName: string;
  objectives: QuestObjective[];
  dependencies: QuestDependency[];
  conflicts: QuestConflict[];
  modInteractions: QuestModInteraction[];
}

export interface QuestObjective {
  objectiveId: string;
  description: string;
  completionCriteria: string[];
  rewards: QuestReward[];
  dependencies: string[];
}

export interface QuestReward {
  type: 'item' | 'perk' | 'experience' | 'faction' | 'misc';
  formId?: string;
  amount?: number;
  description: string;
}

export interface QuestDependency {
  dependentQuest: string;
  dependencyQuest: string;
  dependencyType: 'required' | 'optional' | 'exclusive';
  modName: string;
}

export interface QuestConflict {
  conflictingQuests: string[];
  conflictType: 'objective' | 'reward' | 'timing' | 'completion';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  resolution?: string;
}

export interface QuestModInteraction {
  modName: string;
  changes: QuestChange[];
  additions: QuestAddition[];
  compatibility: 'compatible' | 'conflicts' | 'requires_patch';
  notes?: string;
}

export interface QuestChange {
  changeType: 'objective' | 'reward' | 'dialogue' | 'script';
  description: string;
  impact: 'low' | 'medium' | 'high';
}

export interface QuestAddition {
  additionType: 'quest' | 'objective' | 'dialogue' | 'item';
  formId: string;
  description: string;
}

export interface PerkPowerAnalysis {
  perkId: string;
  perkName: string;
  effects: PerkEffect[];
  interactions: PerkInteraction[];
  balanceIssues: BalanceIssue[];
  modModifications: PerkModification[];
}

export interface PerkEffect {
  effectType: 'stat' | 'ability' | 'resistance' | 'skill' | 'misc';
  target: string;
  magnitude: number;
  conditions?: string[];
  description: string;
}

export interface PerkInteraction {
  interactingPerk: string;
  interactionType: 'synergy' | 'conflict' | 'stacking' | 'override';
  description: string;
  impact: 'positive' | 'negative' | 'neutral';
  magnitude: number;
}

export interface BalanceIssue {
  issueType: 'overpowered' | 'underpowered' | 'imbalanced' | 'exploitable';
  description: string;
  severity: 'low' | 'medium' | 'high';
  affectedBuilds: string[];
  suggestedFix?: string;
}

export interface PerkModification {
  modName: string;
  changes: PerkChange[];
  additions: PerkAddition[];
  timestamp: number;
}

export interface PerkChange {
  changeType: 'effect' | 'requirement' | 'description' | 'icon';
  oldValue: any;
  newValue: any;
  reason: string;
}

export interface PerkAddition {
  additionType: 'perk' | 'rank' | 'effect';
  formId: string;
  description: string;
}

// Cross-Reference Mining Engines
export interface FormIDRelationshipMiningEngine {
  analyze: (espFiles: ESPFile[]) => Promise<FormIDRelationshipMap[]>;
  findConflicts: (formIdMaps: FormIDRelationshipMap[]) => Promise<FormIDConflict[]>;
  buildDependencyGraph: (formIdMaps: FormIDRelationshipMap[]) => Promise<FormIDDependencyGraph>;
}

export interface CellWorldspaceMiningEngine {
  analyze: (espFiles: ESPFile[], worldspaceData: any[]) => Promise<CellWorldspaceAnalysis[]>;
  detectConflicts: (cellAnalyses: CellWorldspaceAnalysis[]) => Promise<CellConflict[]>;
  optimizeLayout: (cellAnalyses: CellWorldspaceAnalysis[]) => Promise<CellOptimization[]>;
}

export interface QuestObjectiveMiningEngine {
  analyze: (espFiles: ESPFile[]) => Promise<QuestObjectiveAnalysis[]>;
  detectConflicts: (questAnalyses: QuestObjectiveAnalysis[]) => Promise<QuestConflict[]>;
  buildDependencyGraph: (questAnalyses: QuestObjectiveAnalysis[]) => Promise<QuestDependencyGraph>;
}

export interface PerkPowerMiningEngine {
  analyze: (espFiles: ESPFile[]) => Promise<PerkPowerAnalysis[]>;
  detectInteractions: (perkAnalyses: PerkPowerAnalysis[]) => Promise<PerkInteraction[]>;
  balanceAnalysis: (perkAnalyses: PerkPowerAnalysis[]) => Promise<BalanceIssue[]>;
}

// Additional supporting types
export interface FormIDDependencyGraph {
  nodes: FormIDNode[];
  edges: FormIDEdge[];
  cycles: FormIDCycle[];
  isolatedNodes: string[];
}

export interface FormIDNode {
  formId: string;
  modName: string;
  recordType: string;
  referenceCount: number;
}

export interface FormIDEdge {
  source: string;
  target: string;
  edgeType: 'references' | 'depends_on' | 'conflicts_with';
  weight: number;
}

export interface FormIDCycle {
  nodes: string[];
  description: string;
  severity: 'low' | 'medium' | 'high';
}

export interface QuestDependencyGraph {
  nodes: QuestNode[];
  edges: QuestEdge[];
  cycles: QuestCycle[];
  completionPaths: QuestPath[];
}

export interface QuestNode {
  questId: string;
  questName: string;
  modName: string;
  objectiveCount: number;
}

export interface QuestEdge {
  source: string;
  target: string;
  edgeType: 'requires' | 'blocks' | 'enables' | 'conflicts';
  weight: number;
}

export interface QuestCycle {
  nodes: string[];
  description: string;
  breakable: boolean;
}

export interface QuestPath {
  quests: string[];
  totalObjectives: number;
  estimatedTime: number;
  difficulty: 'easy' | 'medium' | 'hard';
}

// Advanced Analysis Engine
export interface AdvancedAnalysisEngine {
  patternRecognition: PatternRecognitionEngine;
  conflictPrediction: ConflictPredictionEngine;
  bottleneckMining: BottleneckMiningEngine;
  memoryAnalysis: MemoryAnalysisEngine;
  compatibilityMining: CompatibilityMiningEngine;
  formIdRelationshipMining: FormIDRelationshipMiningEngine;
  cellWorldspaceMining: CellWorldspaceMiningEngine;
  questObjectiveMining: QuestObjectiveMiningEngine;
  perkPowerMining: PerkPowerMiningEngine;
  runComprehensiveAnalysis(data: AnalysisData): Promise<{
    patterns: PatternRecognitionResult;
    bottlenecks: BottleneckAnalysis;
    memory: MemoryAnalysis;
    compatibilityMatrix: CompatibilityMatrix;
  }>;
}

export interface PatternRecognitionEngine {
  analyze: (data: AnalysisData) => Promise<PatternRecognitionResult>;
  train: (historicalData: HistoricalData[]) => Promise<void>;
  getPatterns: () => Promise<DetectedPattern[]>;
}

export interface ConflictPredictionEngine {
  predict: (modA: string, modB: string) => Promise<ConflictPrediction>;
  train: (conflictData: ConflictTrainingData[]) => Promise<void>;
  getModelStatus: () => Promise<ConflictPredictionModel>;
}

export interface ConflictPredictionModel {
  trained: boolean;
  lastTrained: number;
  accuracy: number;
  featureCount: number;
  trainingDataSize: number;
}

export interface BottleneckMiningEngine {
  analyze: (performanceData: PerformanceData) => Promise<BottleneckAnalysis>;
  identify: (metrics: PerformanceMetric[]) => Promise<PerformanceBottleneck[]>;
}

export interface MemoryAnalysisEngine {
  analyze: (memoryData: MemoryData) => Promise<MemoryAnalysis>;
  track: (sessionData: SessionData) => Promise<MemoryTrend[]>;
}

export interface CompatibilityMiningEngine {
  build: (compatibilityData: CompatibilityData[]) => Promise<CompatibilityMatrix>;
  query: (modA: string, modB: string) => Promise<CompatibilityScore>;
  update: (newData: CompatibilityData) => Promise<void>;
}

// Data structures for analysis
export interface AnalysisData {
  mods: string[];
  performanceMetrics: PerformanceMetric[];
  conflicts: ModConflict[];
  loadOrder: string[];
  systemInfo: HardwareProfile;
}

export interface HistoricalData {
  timestamp: number;
  mods: string[];
  outcome: 'success' | 'failure' | 'warning';
  fps?: number;
  memoryUsage?: number;
  loadTime?: number;
  metrics?: PerformanceMetric;
  conflicts?: ModConflict[];
}

export interface PerformanceData {
  metrics: PerformanceMetric[];
  systemInfo: HardwareProfile;
  loadOrder: string[];
  sessionDuration: number;
}

export interface MemoryData {
  vramSnapshots: MemorySnapshot[];
  ramSnapshots: MemorySnapshot[];
  modLoadOrder: string[];
  sessionInfo: SessionData;
}

export interface MemorySnapshot {
  timestamp: number;
  usage: number;
  byComponent: Map<string, number>;
}

export interface SessionData {
  startTime: number;
  endTime: number;
  mods: string[];
  peakVRAM: number;
  peakRAM: number;
  averageFPS: number;
}

export interface CompatibilityData {
  modA: string;
  modB: string;
  compatible: boolean;
  issues?: string[];
  testedBy: string;
  timestamp: number;
  versions: { modA: string; modB: string };
}

// Data Pipeline Types
export interface DataSource {
  type: 'esp' | 'nif' | 'dds' | 'hkx' | 'log' | 'config' | 'benchmark' | 'bsa';
  path: string;
  priority: number;
  lastProcessed?: number;
  checksum?: string;
}

export interface MiningPipeline {
  sources: DataSource[];
  processors: DataProcessor[];
  correlators: AssetCorrelator[];
  analyzers: PerformanceAnalyzer[];
  output: MiningResult;
}

export interface DataProcessor {
  name: string;
  process: (data: any) => Promise<any>;
  supportedTypes: string[];
}

export interface AssetCorrelator {
  correlate: (assets: AssetReference[]) => Promise<AssetCorrelation[]>;
  supportedTypes: string[];
}

export interface PerformanceAnalyzer {
  analyze: (metrics: PerformanceMetric[]) => Promise<PerformanceReport>;
  supportedMetrics: string[];
}

export interface MiningResult {
  espData: Map<string, ESPFile>;
  correlations: AssetCorrelation[];
  dependencyGraph: ModDependencyGraph;
  performanceReport: PerformanceReport;
  processedAt: number;
  errors: string[];
  engine?: string; // Engine that produced this result
  timestamp?: Date; // When the result was generated
}

export interface MiningEngine {
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<MiningResult>;
}

export interface Phase1MiningEngine {
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<Phase1MiningResult>;
}

export interface Phase1MiningResult {
  engine: string;
  timestamp: Date;
  data: any;
  metadata: any;
}

export interface Phase1AssetCorrelation {
  assetId: string;
  correlatedAssets: string[];
  correlationStrength: number;
  correlationType: string;
  metadata?: any;
}

// Phase 2: Advanced ML-based Mining Engines

export interface Phase2MiningEngine {
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<Phase2MiningResult>;
}

export interface Phase2MiningResult {
  engine: string;
  timestampNum: number;
  predictions: any[];
  insights: any[];
  recommendations: any[];
  resultMetadata: Record<string, any>;
}

// ML-based Conflict Prediction Engine
export interface MLConflictPredictionEngine extends Phase2MiningEngine {
  predictConflicts(modCombination: string[]): Promise<ConflictPrediction[]>;
  trainModel(trainingData: ConflictTrainingData[]): Promise<void>;
  getModelAccuracy(): Promise<ModelMetrics>;
  updateWithFeedback(feedback: ConflictFeedback[]): Promise<void>;
}

export interface ConflictPrediction {
  modA: string;
  modB: string;
  probability: number; // 0-1
  conflictTypes: string[];
  severity: 'low' | 'medium' | 'high' | 'critical';
  evidence: ConflictEvidence[];
  mitigationStrategies: string[];
  confidence: number;
}

export interface ConflictEvidence {
  type: 'historical' | 'pattern' | 'similarity' | 'rule_based' | 'ml_prediction';
  description: string;
  weight: number;
  source?: string;
}

export interface ConflictTrainingData {
  modA: string;
  modB: string;
  actualConflict: boolean;
  conflictType?: string;
  severity?: number;
  context: {
    gameVersion: string;
    modVersions: { [modName: string]: string };
    hardwareProfile: HardwareProfile;
    loadOrder: string[];
  };
}

export interface ConflictFeedback {
  predictionId: string;
  actualOutcome: boolean;
  userRating: number; // 1-5, how accurate was the prediction
  comments?: string;
}

export interface ModelMetrics {
  accuracy: number;
  precision: number;
  recall: number;
  f1Score: number;
  trainingDataSize: number;
  lastTrained: number;
  featureImportance: { [feature: string]: number };
}

// Performance Bottleneck Detection Engine
export interface PerformanceBottleneckEngine extends Phase2MiningEngine {
  analyzeBottlenecks(performanceData: PerformanceData): Promise<BottleneckAnalysis>;
  predictPerformanceImpact(modChanges: ModChange[]): Promise<PerformancePrediction[]>;
  identifyOptimizationOpportunities(systemProfile: HardwareProfile): Promise<OptimizationRecommendation[]>;
  monitorRealTimePerformance(): Promise<RealtimeMetrics>;
}

export interface BottleneckAnalysis {
  primaryBottlenecks: Phase2PerformanceBottleneck[];
  secondaryBottlenecks: Phase2PerformanceBottleneck[];
  criticalPath: string[]; // Mods causing the most performance impact
  systemLimitations: Phase2SystemLimitation[];
  optimizationOpportunities: OptimizationRecommendation[];
  confidence: number;
}

export interface Phase2PerformanceBottleneck {
  type: 'cpu' | 'gpu' | 'memory' | 'io' | 'script' | 'asset_loading';
  severity: 'low' | 'medium' | 'high' | 'critical';
  impact: {
    fps: number;
    memory: number;
    loadTime: number;
  };
  affectedMods: string[];
  rootCause: string;
  mitigationStrategies: MitigationStrategy[];
  evidence: Phase2BottleneckEvidence[];
}

export interface Phase2BottleneckEvidence {
  metric: string;
  observedValue: number;
  expectedValue: number;
  deviation: number;
  confidence: number;
}

export interface MitigationStrategy {
  type: 'disable' | 'reorder' | 'patch' | 'optimize' | 'alternative';
  description: string;
  difficulty: 'easy' | 'medium' | 'hard';
  expectedImprovement: {
    fps: number;
    memory: number;
    loadTime: number;
  };
  affectedMods: string[];
}

export interface PerformancePrediction {
  modChange: ModChange;
  predictedImpact: {
    fps: number;
    memory: number;
    loadTime: number;
  };
  confidence: number;
  riskLevel: 'low' | 'medium' | 'high';
  recommendations: string[];
}

export interface ModChange {
  type: 'add' | 'remove' | 'update' | 'reorder';
  modName: string;
  fromVersion?: string;
  toVersion?: string;
  newPosition?: number;
}

export interface OptimizationRecommendation {
  type: 'texture' | 'mesh' | 'script' | 'config' | 'load_order' | 'hardware';
  description: string;
  potentialGain: {
    fps: number;
    memory: number;
    loadTime: number;
  };
  difficulty: 'easy' | 'medium' | 'hard';
  prerequisites: string[];
  affectedMods: string[];
}

export interface RealtimeMetrics {
  currentFPS: number;
  memoryUsage: number;
  cpuUsage: number;
  gpuUsage: number;
  activeMods: string[];
  bottleneckIndicators: BottleneckIndicator[];
  timestamp: number;
}

export interface BottleneckIndicator {
  component: 'cpu' | 'gpu' | 'memory' | 'disk';
  utilization: number;
  threshold: number;
  isBottleneck: boolean;
}

export interface Phase2SystemLimitation {
  component: any;
  currentCapacity: number;
  recommendedMinimum: number;
  isLimiting: boolean;
  upgradeSuggestions: string[];
}

// Hardware-Aware Mining Engine
export interface HardwareAwareMiningEngine extends Phase2MiningEngine {
  analyzeHardwareCompatibility(mods: string[]): Promise<HardwareCompatibility[]>;
  generateHardwareSpecificRecommendations(profile: HardwareProfile): Promise<HardwareRecommendation[]>;
  predictPerformanceForHardware(mods: string[], targetHardware: HardwareProfile): Promise<HardwarePerformancePrediction>;
  optimizeForHardware(mods: string[], hardwareProfile: HardwareProfile): Promise<HardwareOptimization[]>;
}

export interface HardwareCompatibility {
  modName: string;
  compatibility: {
    cpu: number; // 0-1 compatibility score
    gpu: number;
    ram: number;
    storage: number;
  };
  requirements: HardwareRequirements;
  recommendations: string[];
  warnings: string[];
}

export interface HardwareRequirements {
  minimum: HardwareProfile;
  recommended: HardwareProfile;
  estimatedPerformance: {
    minSpecFPS: number;
    recSpecFPS: number;
  };
}

export interface HardwareRecommendation {
  type: 'upgrade' | 'downgrade' | 'alternative' | 'optimization';
  component: 'cpu' | 'gpu' | 'ram' | 'storage';
  description: string;
  priority: 'low' | 'medium' | 'high';
  costEstimate?: number;
  performanceGain: number;
  affectedMods: string[];
}

export interface HardwarePerformancePrediction {
  baselinePerformance: PerformanceMetric;
  predictedPerformance: PerformanceMetric;
  confidence: number;
  limitingFactors: string[];
  optimizationSuggestions: HardwareOptimization[];
}

export interface HardwareOptimization {
  type: 'texture_resolution' | 'mesh_lod' | 'shadow_quality' | 'draw_distance' | 'anti_aliasing';
  description: string;
  currentSetting: any;
  recommendedSetting: any;
  performanceImpact: {
    fps: number;
    quality: number;
  };
  compatibility: string[]; // Affected mods
}

// Longitudinal Mining Engine
export interface LongitudinalMiningEngine extends Phase2MiningEngine {
  trackPerformanceOverTime(sessionData: SessionData[]): Promise<PerformanceTrend[]>;
  detectPerformanceDegradation(trends: PerformanceTrend[]): Promise<DegradationAlert[]>;
  predictFuturePerformance(currentMods: string[], futureChanges: ModChange[]): Promise<FuturePerformancePrediction>;
  analyzeModUpdateImpact(updates: ModUpdate[]): Promise<UpdateImpactAnalysis[]>;
}

export interface PerformanceTrend {
  modCombination: string[];
  timeRange: {
    start: number;
    end: number;
  };
  metrics: {
    fps: TrendData;
    memory: TrendData;
    loadTime: TrendData;
    stability: TrendData;
  };
  significantChanges: PerformanceChange[];
  overallTrend: 'improving' | 'stable' | 'degrading';
}

export interface TrendData {
  values: number[];
  timestamps: number[];
  average: number;
  min: number;
  max: number;
  standardDeviation: number;
  trend: 'increasing' | 'decreasing' | 'stable';
  slope: number; // Rate of change
}

export interface PerformanceChange {
  timestamp: number;
  changeType: 'improvement' | 'degradation' | 'fluctuation';
  magnitude: number;
  cause: string;
  confidence: number;
}

export interface DegradationAlert {
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  affectedMods: string[];
  rootCause: string;
  mitigationSteps: string[];
  predictedImpact: {
    fps: number;
    memory: number;
    stability: number;
  };
  timeframe: string; // When the degradation was detected
}

export interface FuturePerformancePrediction {
  timeHorizon: number; // Days into the future
  predictedMetrics: PerformanceMetric;
  confidence: number;
  riskFactors: string[];
  recommendedActions: string[];
}

export interface ModUpdate {
  modName: string;
  fromVersion: string;
  toVersion: string;
  updateType: 'patch' | 'major' | 'minor';
  changelog?: string;
  timestamp: number;
}

export interface UpdateImpactAnalysis {
  modName: string;
  update: ModUpdate;
  performanceImpact: {
    fps: number;
    memory: number;
    loadTime: number;
  };
  compatibilityChanges: string[];
  riskLevel: 'low' | 'medium' | 'high';
  recommendations: string[];
  rollbackAdvice?: string;
}

export interface SessionData {
  sessionId: string;
  startTime: number;
  endTime: number;
  mods: string[];
  initialLoadOrder: string[];
  finalLoadOrder: string[];
  performanceSnapshots: PerformanceSnapshot[];
  events: SessionEvent[];
  userActions: UserAction[];
}

export interface PerformanceSnapshot {
  timestamp: number;
  fps: number;
  memoryUsage: number;
  cpuUsage: number;
  gpuUsage: number;
  activeMods: number;
}

export interface SessionEvent {
  timestamp: number;
  type: 'mod_loaded' | 'mod_unloaded' | 'crash' | 'save' | 'load' | 'setting_changed';
  details: any;
}

export interface UserAction {
  timestamp: number;
  action: 'enable_mod' | 'disable_mod' | 'reorder_mods' | 'change_setting' | 'install_mod' | 'uninstall_mod';
  details: any;
}

// Contextual Mining Engine
export interface ContextualMiningEngine extends Phase2MiningEngine {
  analyzeUserPreferences(userProfile?: UserProfile): Promise<any>;
  understandModdingGoals(mods?: string[], userHistory?: UserHistory): Promise<ModdingGoal[]>;
  generatePersonalizedRecommendations(userContext?: any): Promise<any[]>;
  adaptToUserBehavior(behaviorPatterns?: BehaviorPattern[]): Promise<AdaptationStrategy[]>;
}

export interface UserProfile {
  userId: string;
  preferences: {
    performancePriority: any; // 0-10, how much they care about FPS
    visualQualityPriority: any; // 0-10, how much they care about graphics
    stabilityPriority: any; // 0-10, how much they care about crashes
    moddingExperience?: any;
    playstyle?: any;
    hardwareBudget?: any;
    visualQuality?: any;
    modCategories?: any;
    complexityTolerance?: any;
    automationPreference?: any;
    learningStyle?: any;
    moddingStyle?: any;
    contentPreferences?: any;
    technicalProficiency?: any;
  };
  behaviorPatterns?: BehaviorPattern[];
  modPreferences?: any;
  settingPreferences?: any;
  contextualPatterns?: any;
  performanceTolerance?: {
    minFPS: number;
    maxMemoryUsage: number;
    acceptableLoadTime: number;
  };
  lastUpdated: number;
  learningProgress: {
    interactionsProcessed: number;
    feedbackIncorporated: number;
    patternsLearned: number;
    adaptationCycles: number;
  };
  hardwareProfile?: HardwareProfile;
  modLibrary?: string[];
  favoriteMods?: string[];
  avoidedMods?: string[];
  commonIssues?: string[];
  created?: number;
  userGoals?: any[];
}

export interface UserInsights {
  performanceTolerance: {
    minAcceptableFPS: number;
    maxAcceptableLoadTime: number;
    memoryLimit: number;
  };
  qualityPreferences: {
    textureResolution: 'low' | 'medium' | 'high' | 'ultra';
    meshQuality: 'low' | 'medium' | 'high' | 'ultra';
    shadowQuality: 'off' | 'low' | 'medium' | 'high' | 'ultra';
    effectQuality: 'low' | 'medium' | 'high';
  };
  riskTolerance: 'conservative' | 'moderate' | 'aggressive';
  learningStyle: 'cautious' | 'experimental' | 'methodical';
}

export interface ModdingGoal {
  goalType: 'performance' | 'visual' | 'content' | 'compatibility' | 'stability';
  priority: number; // 0-10
  description: string;
  targetMods: string[];
  constraints: string[];
  successCriteria: string[];
  estimatedDifficulty: 'easy' | 'medium' | 'hard';
}

export interface UserContext {
  currentMods: string[];
  recentChanges: ModChange[];
  performanceHistory: PerformanceTrend[];
  reportedIssues: string[];
  userGoals: ModdingGoal[];
  timeConstraints: {
    availableTime: number; // Hours per week for modding
    patienceLevel: 'low' | 'medium' | 'high';
  };
  technicalComfort: 'beginner' | 'intermediate' | 'advanced';
  action?: any;
  details?: any;
}

export interface PersonalizedRecommendation {
  type: any;
  priority?: any;
  description?: string;
  rationale?: any;
  relevance: number;
  confidence: number;
  action?: string;
  id?: string;
  expectedBenefit?: any;
  implementationDifficulty?: any;
  prerequisites?: string[];
  item?: string;
  reasoning?: string[];
  contextRelevance?: number;
  expectedImpact?: any;
}

export interface UserInteraction {
  type: any;
  modName?: string;
  context: any;
  outcome: {
    success?: boolean;
    error?: string;
    performance?: number;
    satisfaction?: number;
    issues?: string[];
  };
  timestamp: number;
  settingName?: string;
  value?: any;
  rating?: number;
}

export interface UserFeedback {
  id?: string;
  rating: number;
  comments?: string;
  recommendationId?: string;
  timestamp: number;
  accepted?: boolean;
  context?: any;
  outcome?: {
    performance?: number;
    satisfaction?: number;
    issues?: string[];
  };
}

export interface SessionContext {
  gameMode?: string;
  systemResourceState?: string;
  activeMods?: string[];
  difficulty?: string;
  hardwareProfile?: any;
  performanceMetrics?: any;
  userPreferences?: any;
}

export interface ContextTransition {
  from: any;
  to: any;
  timestamp: number;
  reason?: string;
  impact?: any;
}

export interface TransitionAnalysis {
  frequency?: number;
  commonPaths?: string[][];
  averageDuration?: number;
  commonTransitions?: ContextTransition[];
  transitionPatterns?: Record<string, number>;
  adaptationStrategies?: any[];
  effectiveness?: number;
}

export interface UserHistory {
  sessions: SessionData[];
  interactions?: UserInteraction[];
  lastActive: number;
}

export interface ModdingGoal {
  title: string;
  target: string;
  requirements: string[];
  currentProgress: number;
}

export interface AdaptationStrategy {
  id: string;
  name?: string;
  strategyType?: any;
  type?: any;
  description: string;
  action?: string;
  trigger?: string;
  isApplied?: boolean;
  appliedAt?: number;
  isActive?: boolean;
  adjustmentFactor: number;
  effectiveness: number;
  conditions?: any;
  actions?: string[];
  implementation?: string[];
  lastUsed?: number;
  successRate?: number;
  expectedImprovement?: number;
  userAcceptance?: number;
  triggerCondition?: any;
  lastAdapted?: number;
}

export type AdaptiveStrategy = AdaptationStrategy;

export interface UserInsights {
  primaryGoal: string;
  preferences: Record<string, any>;
  commonProblems: string[];
  suggestedPath: string;
}

export interface BehaviorPattern {
  id?: string;
  type?: string;
  patternType?: any;
  pattern: string;
  frequency: number;
  successRate: number;
  preferredApproaches?: string[];
  avoidedApproaches?: string[];
  learningProgression?: string[];
  lastObserved: number;
  contexts: any[];
  confidence: number;
  insights?: any[];
}

export interface UserHistory {
  sessions: SessionData[];
  interactions?: UserInteraction[];
  modInstallations?: ModInstallation[];
  issueReports?: IssueReport[];
  settingChanges?: SettingChange[];
  performanceMeasurements?: PerformanceMeasurement[];
  lastActive: number;
}

export interface ModInstallation {
  modName: string;
  version: string;
  timestamp: number;
  source: string;
  reason: string;
  outcome: 'success' | 'failure' | 'partial';
}

export interface IssueReport {
  timestamp: number;
  issueType: 'crash' | 'performance' | 'compatibility' | 'visual' | 'other';
  description: string;
  affectedMods: string[];
  resolution?: string;
  userRating?: number;
}

export interface SettingChange {
  timestamp: number;
  setting: string;
  oldValue: any;
  newValue: any;
  reason: string;
  outcome: 'positive' | 'negative' | 'neutral';
}

export interface PerformanceMeasurement {
  timestamp: number;
  mods: string[];
  metrics: PerformanceMetric;
  context: string;
  userSatisfaction: number; // 1-10
}

export interface MiningStatus {
  active: boolean;
  progress: number;
  currentTask?: string;
  engineType: string;
  engine?: string; // Engine identifier
  startTime?: number;
  lastUpdate?: number;
}

// Intelligent Asset Discovery Types

// BSA Archive Structures
export interface BSAFileEntry {
  filename: string;
  size: number;
  offset: number;
  compressed: boolean;
}

export interface BSADirectory {
  name: string;
  files: BSAFileEntry[];
}

export interface BSAArchive {
  path: string;
  version: number;
  directories: BSADirectory[];
  totalFiles: number;
  totalSizeCompressed: number;
  totalSizeUncompressed: number;
}

// Unused Asset Detection
export interface UnusedAsset {
  path: string;
  type: 'texture' | 'model' | 'animation' | 'sound' | 'other';
  size: number;
  archive?: string; // BSA archive containing this asset
  reason: 'orphaned' | 'duplicate' | 'low_usage';
  potentialSavings: number; // Bytes that could be saved by removal
}

export interface UnusedAssetReport {
  totalAssets: number;
  unusedAssets: UnusedAsset[];
  potentialSpaceSavings: number;
  recommendations: string[];
}

// LOD Optimization Mining
export interface LODMeshInfo {
  path: string;
  lodLevel: number; // 0 = highest detail, higher numbers = lower detail
  triangleCount: number;
  vertexCount: number;
  texturePath?: string;
  distanceThreshold: number;
}

export interface LODOptimization {
  meshPath: string;
  currentLODs: LODMeshInfo[];
  recommendedLODs: LODMeshInfo[];
  issues: string[];
  suggestions: string[];
  potentialSavings: {
    triangles: number;
    vertices: number;
    textureMemory: number;
  };
}

export interface LODReport {
  totalMeshes: number;
  optimizedMeshes: LODOptimization[];
  recommendations: string[];
}

// Texture Resolution Mining
export interface TextureInfo {
  path: string;
  width: number;
  height: number;
  format: string;
  mipmaps: number;
  size: number;
  usage: 'diffuse' | 'normal' | 'specular' | 'other';
  distanceUsage: 'close' | 'medium' | 'far' | 'background';
}

export interface TextureUpscaleOpportunity {
  texture: TextureInfo;
  recommendedResolution: { width: number; height: number };
  qualityImprovement: number; // 0-100
  performanceImpact: number; // Additional VRAM usage in MB
  priority: 'high' | 'medium' | 'low';
  reason: string;
}

export interface TextureResolutionReport {
  totalTextures: number;
  lowResTextures: TextureUpscaleOpportunity[];
  recommendations: string[];
  potentialQualityImprovement: number;
}

// Animation Frame Mining
export interface AnimationKeyframe {
  time: number;
  position?: { x: number; y: number; z: number };
  rotation?: { x: number; y: number; z: number; w: number };
  scale?: { x: number; y: number; z: number };
}

export interface AnimationInfo {
  path: string;
  duration: number;
  frameRate: number;
  keyframeCount: number;
  boneCount: number;
  keyframes: AnimationKeyframe[];
  compressionRatio: number; // Current compression level
}

export interface AnimationOptimization {
  animation: AnimationInfo;
  recommendedFrameRate: number;
  recommendedKeyframeReduction: number;
  potentialSavings: {
    fileSize: number;
    memory: number;
    cpu: number; // Estimated CPU cycles saved
  };
  qualityImpact: number; // 0-100, higher = better quality preserved
  suggestions: string[];
}

export interface AnimationReport {
  totalAnimations: number;
  optimizableAnimations: AnimationOptimization[];
  recommendations: string[];
  potentialSavings: {
    totalFileSize: number;
    totalMemory: number;
    totalCPU: number;
  };
}

// Asset Discovery Analyzers
export interface UnusedAssetDetector {
  scan: (bsaArchives: BSAArchive[], espFiles: ESPFile[]) => Promise<UnusedAssetReport>;
  supportedTypes: string[];
}

export interface LODOptimizer {
  analyze: (lodMeshes: LODMeshInfo[]) => Promise<LODOptimization[]>;
  supportedTypes: string[];
}

export interface TextureResolutionAnalyzer {
  analyze: (textures: TextureInfo[]) => Promise<TextureResolutionReport>;
  supportedTypes: string[];
}

export interface AnimationFrameAnalyzer {
  analyze: (animations: AnimationInfo[]) => Promise<AnimationReport>;
  supportedTypes: string[];
}

// Extended Mining Result
export interface ExtendedMiningResult extends MiningResult {
  assetDiscovery: {
    unusedAssets: UnusedAssetReport;
    lodOptimizations: LODReport;
    textureResolutions: TextureResolutionReport;
    animationOptimizations: AnimationReport;
  };
}

/**
 * API for the preload script (exposed to renderer via contextBridge)
 */
export interface ElectronAPI {
    // Generic IPC
    invoke: (channel: string, ...args: any[]) => Promise<any>;
    send: (channel: string, ...args: any[]) => void;
    on: (channel: string, callback: (...args: any[]) => void) => (() => void);
    
    // Directory Picker
    pickDirectory: (options?: any) => Promise<string | null>;

    // Real-time STT partial transcript
    onSttPartial?: (callback: (partial: string) => void) => void;

    // Real-time mic level
    onMicLevel?: (callback: (level: number) => void) => void;
  // Messaging
  sendMessage: (message: string | VoiceChatPayload) => Promise<void>;
  onMessage: (callback: (message: Message) => void) => (() => void);
  
  // Settings
  getSettings: () => Promise<Settings>;
  setSettings: (settings: Partial<Settings>) => Promise<void>;
  onSettingsUpdated: (callback: (settings: Settings) => void) => void;

  // Desktop Bridge
  checkBlenderAddon?: () => Promise<{ connected: boolean; error?: string }>;
  sendBlenderCommand?: (command: string, args?: any) => Promise<any>;
  
  // Audio
  ttsSpeak: (text: string) => Promise<void>;
  sttStart: () => Promise<void>;
  sttStop: () => Promise<void>;
  startListening: () => Promise<void>;
  stopListening: () => Promise<void>;
  onSttResult: (callback: (text: string) => void) => (() => void);
  onTtsSpeak: (callback: (text: string | null) => void) => (() => void);
  transcribeAudio: (arrayBuffer: ArrayBuffer, mimeType?: string) => Promise<{ success: boolean; text?: string; error?: string }>;
  // PDF parsing
  parsePDF: (arrayBuffer: ArrayBuffer) => Promise<{ success: boolean; text?: string; error?: string }>;
  // PSD parsing
  parsePSD: (arrayBuffer: ArrayBuffer) => Promise<{ success: boolean; text?: string; metadata?: any; error?: string }>;
  // ABR parsing (Adobe Brush)
  parseABR: (arrayBuffer: ArrayBuffer) => Promise<{ success: boolean; text?: string; metadata?: any; error?: string }>;
  // Video transcription
  transcribeVideo: (arrayBuffer: ArrayBuffer, filename: string, projectId?: string, organizationId?: string) => Promise<{ success: boolean; text?: string; error?: string }>;
  getSystemInfo: () => Promise<SystemInfo>;
  getPerformance: () => Promise<{
    cpuUsage: number;
    memoryUsage: number;
    gpuUsage?: number;
    gpuMemory?: number;
  }>;
  detectPrograms: () => Promise<InstalledProgram[]>;
  getRunningProcesses: () => Promise<any[]>;
  openExternal: (url: string) => Promise<void>;
  openProgram: (path: string) => Promise<{ success: boolean; error?: string; method?: string }>;
  readFile: (filePath: string) => Promise<string>;
  saveFile: (content: string, filename: string) => Promise<string>;
  // Developer tools
  openDevTools: () => Promise<void>;

  // Advanced analysis (optional)
  getAdvancedAnalysisEngine?: () => Promise<AdvancedAnalysisEngine>;
  
  // Image Suite
  generateNormalMap: (imageBase64: string) => Promise<string>;
  generateRoughnessMap: (imageBase64: string) => Promise<string>;
  generateHeightMap: (imageBase64: string) => Promise<string>;
  generateMetallicMap: (imageBase64: string) => Promise<string>;
  generateAOMap: (imageBase64: string) => Promise<string>;
  convertImageFormat: (sourceBase64: string, targetFormat: string, options: any) => Promise<string>;
  getImageInfo: (filePath: string) => Promise<{ width: number; height: number; format: string; colorSpace: string } | null>;
  
  // Voice setup wizard handlers
  checkOllamaStatus: () => Promise<{ installed: boolean; version?: string; error?: string }>;
  listOllamaModels: () => Promise<string[]>;
  pullOllamaModel: (modelName: string) => Promise<{ success: boolean; message?: string; error?: string }>;
  
  // Scribe Advanced
  installScript: (type: 'papyrus' | 'xedit', name: string, code: string, targetPath?: string) => Promise<{ success: boolean; path?: string; error?: string }>;

  // Window
  minimizeWindow: () => void;
  closeWindow: () => void;

  // Project Management
  listProjects: () => Promise<ModProject[]>;
  createProject: (project: Omit<ModProject, 'id' | 'createdAt' | 'updatedAt'>) => Promise<ModProject>;
  updateProject: (id: string, updates: Partial<ModProject>) => Promise<ModProject>;
  deleteProject: (id: string) => Promise<boolean>;
  switchProject: (id: string) => Promise<void>;
  getCurrentProject: () => Promise<ModProject | null>;

  // Wizard Support
  wizardGetState: (wizardId: string) => Promise<any>;
  wizardUpdateStep: (wizardId: string, stepId: string, status: any, data?: any) => Promise<any>;
  wizardSubmitAction: (wizardId: string, actionType: string, payload: any) => Promise<any>;

  // Roadmap System
  roadmapGetAll: () => Promise<Roadmap[]>;
  roadmapGetActive: () => Promise<Roadmap | null>;
  roadmapCreate: (roadmap: Omit<Roadmap, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Roadmap>;
  roadmapUpdateStep: (roadmapId: string, stepId: string, status: string) => Promise<{ ok: boolean }>;
  roadmapDelete: (id: string) => Promise<void>;
  roadmapGenerateAI: (prompt: string, projectId: string) => Promise<{ ok: boolean; roadmap: Roadmap }>;

  // Mining Infrastructure
  startMiningPipeline?: (sources: DataSource[]) => Promise<MiningResult>;
  parseESPFile?: (filePath: string) => Promise<ESPFile>;
  correlateAssets?: (assets: AssetReference[]) => Promise<AssetCorrelation[]>;
  buildDependencyGraph?: (modFiles: string[]) => Promise<ModDependencyGraph>;
  analyzePerformance?: (metrics: PerformanceMetric[]) => Promise<PerformanceReport>;
  getMiningStatus?: () => Promise<{ active: boolean; progress: number; currentTask?: string }>;
  miningStart?: () => Promise<void>;
  miningStop?: () => Promise<void>;
  miningGetStatus?: () => Promise<any>;
  miningGetResults?: () => Promise<any>;
  miningDeepAnalysis?: (options: any) => Promise<any>;
  miningBatchJob?: (job: any) => Promise<any>;
  miningResolveConflicts: (modDirectory: string) => Promise<any>;
  miningWorkflowRecommendations: (options: any) => Promise<any>;
  miningUpdateConfig: (config: any) => Promise<any>;

  // Phase 1: Asset Correlation Engine
  miningAssetCorrelationStart: (config?: any) => Promise<any>;
  miningAssetCorrelationStop: () => Promise<any>;
  miningAssetCorrelationStatus: () => Promise<any>;
  miningAssetCorrelationResults: () => Promise<any>;

  // Phase 1: Pattern Recognition Engine
  miningPatternRecognitionStart: (config?: any) => Promise<any>;
  miningPatternRecognitionStop: () => Promise<any>;
  miningPatternRecognitionStatus: () => Promise<any>;
  miningPatternRecognitionResults: () => Promise<any>;

  // BA2 Archive Management
  mergeBA2: (inputArchives: string[], outputArchive: string, archiveType: 'general' | 'texture') => Promise<any>;

  // Collaboration Features
  initGitRepository: (projectId: string, config: any) => Promise<any>;
  gitCommit: (projectId: string, message: string, files?: string[]) => Promise<any>;
  gitPush: (projectId: string) => Promise<any>;
  gitPull: (projectId: string) => Promise<any>;
  joinCollaborationSession?: (sessionId: string) => Promise<CollaborationSession>;
  leaveCollaborationSession?: (sessionId: string) => Promise<void>;

  // Advanced Analytics
  trackAnalyticsEvent: (event: any) => Promise<any>;
  getAnalyticsMetrics: () => Promise<any>;
  exportAnalyticsData: () => Promise<any>;
  updateAnalyticsConfig: (config: any) => Promise<any>;

  // Advanced Analysis Capabilities
  analyzePatterns: (data: any) => Promise<any>;
  predictConflicts: (modA: string, modB: string) => Promise<any>;
  analyzeBottlenecks: (performanceData: any) => Promise<any>;
  analyzeMemory: (memoryData: any) => Promise<any>;
  buildCompatibilityMatrix: (compatibilityData: any[]) => Promise<any>;
  queryCompatibility: (modA: string, modB: string) => Promise<any>;
  trainConflictModel: (trainingData: any[]) => Promise<any>;
  getAnalysisStatus: () => Promise<any>;

  // Enhanced LLM Service
  llmGenerateWithExplainability: (messages: any[], config: any, includeExplainability: boolean) => Promise<any>;
  llmSaveModelVersion: (version: any) => Promise<any>;
  llmGetModelVersions: () => Promise<any>;
  llmCreateABTest: (test: any) => Promise<any>;
  llmGetPerformanceMetrics: (timeRange?: number) => Promise<any>;

  // Monitoring Service
  monitoringStart: () => Promise<any>;
  monitoringStop: () => Promise<any>;
  monitoringCreateAlertRule: (rule: any) => Promise<any>;
  monitoringGetAlertRules: () => Promise<any>;
  monitoringGetHealth: () => Promise<any>;
  monitoringGetMetrics: (name?: string, timeRange?: number) => Promise<any>;
  monitoringGetNotifications: (limit?: number) => Promise<any>;

  // Data Management Service
  dataCreateUserProfile: (userData: any) => Promise<any>;
  dataGetUserProfile: (userId: string) => Promise<any>;
  dataUpdateUserProfile: (userId: string, updates: any) => Promise<any>;
  dataSubmitGDPRRequest: (request: any) => Promise<any>;
  dataGetGDPRRequest: (requestId: string) => Promise<any>;
  dataRequestExport: (userId: string, options?: any) => Promise<any>;
  dataGetExport: (exportId: string) => Promise<any>;
  dataGetPrivacySettings: () => Promise<any>;
  dataUpdatePrivacySettings: (settings: any) => Promise<any>;

  // Scalability Service
  scalabilityGetCache: (key: string) => Promise<any>;
  scalabilitySetCache: (key: string, value: any, ttl?: number) => Promise<any>;
  scalabilitySubmitTask: (task: any) => Promise<any>;
  scalabilityGetTaskStatus: (taskId: string) => Promise<any>;
  scalabilityRegisterWorker: (workerId: string, capabilities: string[], type?: string) => Promise<any>;
  scalabilityGetAvailableWorkers: () => Promise<any>;

  // Notification listener for monitoring service
  onNotification: (callback: (notification: any) => void) => (() => void);
}

export interface VoiceChatPayload {
  text: string;
  history?: Array<{ role: 'user' | 'assistant'; content: string }>;
  workingMemory?: string;
  projectData?: Record<string, any> | null;
}

/**
 * Predictive Optimization Mining Engines
 */

// Load Order Optimization
export interface LoadOrderOptimizationMiningEngine {
  analyze: (performanceData: PerformanceData[]) => Promise<LoadOrderOptimization[]>;
  optimize: (currentOrder: string[], performanceData: PerformanceData[]) => Promise<OptimizedLoadOrder>;
  predictImpact: (proposedOrder: string[], performanceData: PerformanceData[]) => Promise<LoadOrderImpact>;
}

export interface LoadOrderOptimization {
  currentOrder: string[];
  suggestedOrder: string[];
  performanceImprovement: number;
  stabilityScore: number;
  conflictReduction: number;
  reasoning: string[];
}

export interface OptimizedLoadOrder {
  order: string[];
  expectedPerformanceGain: number;
  stabilityRating: number;
  conflictScore: number;
  implementationSteps: string[];
}

export interface LoadOrderConstraints {
  mustLoadBefore: Array<[string, string]>; // [modA, modB] - modA must load before modB
  mustLoadAfter: Array<[string, string]>;  // [modA, modB] - modA must load after modB
  incompatiblePairs: Array<[string, string]>; // mods that cannot be loaded together
  performancePriority: 'stability' | 'performance' | 'compatibility';
}

export interface SimpleHardwarePerformancePrediction {
  fpsImprovement: number;
  memoryUsageChange: number;
  loadTimeChange: number;
  stabilityScore: number;
  confidence: number;
}

// Texture Optimization
export interface TextureOptimizationMiningEngine {
  analyze: (ddsFiles: DDSFile[], hardwareProfile: HardwareProfile) => Promise<TextureOptimization[]>;
  recommendCompression: (texture: DDSFile) => Promise<CompressionRecommendation>;
  batchOptimize: (textures: DDSFile[]) => Promise<BatchOptimizationResult>;
}

export interface TextureOptimization {
  texturePath: string;
  currentFormat: string;
  recommendedFormat: string;
  compressionRatio: number;
  qualityImpact: number;
  performanceGain: number;
  memorySavings: number;
}

export interface CompressionRecommendation {
  originalFormat: string;
  recommendedFormat: 'DXT1' | 'DXT3' | 'DXT5' | 'BC7' | 'BC6H' | 'RGBA8';
  compressionSettings: {
    quality: number;
    mips: boolean;
    alpha: boolean;
  };
  expectedSavings: number;
  qualityLoss: number;
}

export interface BatchOptimizationResult {
  totalTextures: number;
  optimizedTextures: number;
  totalMemorySavings: number;
  averageQualityLoss: number;
  processingTime: number;
  recommendations: TextureOptimization[];
}

// Mesh Optimization
export interface MeshOptimizationMiningEngine {
  analyze: (nifFiles: NIFFile[], lodSettings: LODSettings) => Promise<MeshOptimization[]>;
  suggestLOD: (mesh: NIFFile, lodSettings: LODSettings) => Promise<LODSuggestion>;
  optimizeBatch: (meshes: NIFFile[], lodSettings: LODSettings) => Promise<BatchMeshOptimization>;
}

export interface MeshOptimization {
  meshPath: string;
  currentTriangles: number;
  recommendedTriangles: number;
  lodSuggestions: LODSuggestion[];
  performanceImpact: number;
  visualQualityLoss: number;
}

export interface LODSuggestion {
  distance: number;
  triangleReduction: number;
  quality: 'high' | 'medium' | 'low';
  performanceGain: number;
}

export interface LODSettings {
  maxDistance: number;
  qualityLevels: number;
  triangleBudget: number;
  performanceTarget: 'high' | 'medium' | 'low';
}

export interface BatchMeshOptimization {
  totalMeshes: number;
  optimizedMeshes: number;
  totalTriangleReduction: number;
  averagePerformanceGain: number;
  lodConfigurations: LODSuggestion[];
}

// INI Parameter Mining
export interface IniParameterMiningEngine {
  analyze: (iniFiles: INIFile[], hardwareProfile: HardwareProfile) => Promise<IniOptimization[]>;
  recommendSettings: (iniFile: INIFile, hardwareProfile: HardwareProfile) => Promise<INISettingsRecommendation>;
  validateConfiguration: (iniSettings: Record<string, any>, hardwareProfile: HardwareProfile) => Promise<ConfigurationValidation>;
}

export interface IniOptimization {
  iniPath: string;
  section: string;
  key: string;
  currentValue: string;
  recommendedValue: string;
  performanceImpact: number;
  stabilityImpact: number;
  reasoning: string;
}

export interface INISettingsRecommendation {
  settings: IniOptimization[];
  profile: string;
  expectedPerformanceGain: number;
  stabilityRating: number;
  compatibilityScore: number;
  warnings: string[];
}

export interface ConfigurationValidation {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  performanceScore: number;
  stabilityScore: number;
}

/**
 * Knowledge Graph Construction Mining Engines
 */

// Modding Knowledge Mining
export interface ModdingKnowledgeMiningEngine {
  mineFromSources: (sources: KnowledgeSource[]) => Promise<KnowledgeGraph>;
  extractInsights: (rawData: RawKnowledgeData[]) => Promise<ModdingInsight[]>;
  buildKnowledgeGraph: (insights: ModdingInsight[]) => Promise<KnowledgeGraph>;
}

export interface KnowledgeSource {
  id: string;
  type: 'forum' | 'wiki' | 'discord' | 'tutorial' | 'documentation';
  url: string;
  title: string;
  lastUpdated: number;
  credibility: number;
  content?: string;
  timestamp?: number;
}

export interface RawKnowledgeData {
  source: KnowledgeSource;
  topic: string;
  content: string;
  sentiment: number;
  relevance: number;
}

export interface ModdingInsight {
  id: string;
  type: 'solution' | 'warning' | 'optimization' | 'compatibility' | 'tutorial';
  title: string;
  description: string;
  confidence: number;
  sources: KnowledgeSource[];
  relatedMods?: string[];
  tags?: string[];
  timestamp?: number;
}

export interface KnowledgeGraph {
  nodes: KnowledgeNode[];
  edges: KnowledgeEdge[];
  insights: ModdingInsight[];
  lastUpdated: number;
}

export interface KnowledgeNode {
  id: string;
  type: 'concept' | 'problem' | 'solution' | 'tutorial' | 'tool' | 'technique';
  label: string;
  content: string;
  source: string;
  confidence: number;
  tags: string[];
  metadata: Record<string, any>;
}

export interface KnowledgeEdge {
  id: string;
  source: string;
  target: string;
  type: 'requires' | 'solves' | 'related' | 'prerequisite' | 'improves' | 'conflicts';
  weight: number;
  evidence: string[];
  metadata?: Record<string, any>;
}

// Patch Compatibility Mining
export interface PatchCompatibilityMiningEngine {
  analyzePatchCombinations: (patches: PatchData[]) => Promise<PatchCompatibilityGraph>;
  findCompatibleSets: (targetMods: string[]) => Promise<CompatiblePatchSet[]>;
  validatePatchSet: (patchSet: PatchData[]) => Promise<PatchValidation>;
}

export interface PatchData {
  id: string;
  name: string;
  targetMods: string[];
  changes: PatchChange[];
  compatibility: PatchCompatibility[];
  version: string;
  author: string;
}

export interface PatchChange {
  type: 'esp' | 'ini' | 'texture' | 'mesh' | 'script';
  target: string;
  modification: string;
  impact: number;
}

export interface PatchCompatibility {
  withPatch: string;
  compatibility: 'compatible' | 'incompatible' | 'requires_patch' | 'conflicts';
  reason: string;
  severity: 'low' | 'medium' | 'high';
  score?: number;
}

export interface PatchCompatibilityGraph {
  patches: PatchData[];
  compatibilityMatrix: Record<string, Record<string, PatchCompatibility>>;
  recommendedSets: CompatiblePatchSet[];
}

export interface CompatiblePatchSet {
  patches: string[];
  targetMods: string[];
  compatibilityScore: number;
  performanceImpact: number;
  stabilityRating: number;
  description: string;
}

export interface PatchValidation {
  isValid: boolean;
  conflicts: PatchConflict[];
  warnings: string[];
  performanceScore: number;
  compatibilityRating: number;
}

export interface PatchConflict {
  patchA: string;
  patchB: string;
  conflictType: string;
  severity: 'low' | 'medium' | 'high';
  resolution: string;
}

// Version Compatibility Mining
export interface VersionCompatibilityMiningEngine {
  trackCompatibility: (modVersions: ModVersionData[]) => Promise<VersionCompatibilityGraph>;
  predictCompatibility: (modA: string, versionA: string, modB: string, versionB: string) => Promise<CompatibilityPrediction>;
  findCompatibleVersions: (modList: string[]) => Promise<CompatibleVersionSet[]>;
}

export interface ModVersionData {
  modName: string;
  version: string;
  gameVersion: string;
  dependencies: VersionDependency[];
  incompatibilities: VersionIncompatibility[];
  reportedIssues: VersionIssue[];
  testResults: VersionTestResult[];
}

export interface VersionDependency {
  modName: string;
  versionRange: string;
  type: 'required' | 'optional' | 'recommended';
}

export interface VersionIncompatibility {
  modName: string;
  versionRange: string;
  reason: string;
  severity: 'low' | 'medium' | 'high';
}

export interface VersionIssue {
  issueType: 'crash' | 'bug' | 'performance' | 'compatibility';
  description: string;
  frequency: number;
  severity: 'low' | 'medium' | 'high';
  reportedBy: string[];
}

export interface VersionTestResult {
  tester: string;
  gameVersion: string;
  result: 'success' | 'partial' | 'failure';
  notes: string;
  timestamp: number;
}

export interface VersionCompatibilityGraph {
  mods: Record<string, ModVersionData[]>;
  compatibilityMatrix: Record<string, Record<string, CompatibilityPrediction>>;
  recommendedVersions: CompatibleVersionSet[];
}

export interface CompatibilityPrediction {
  compatibility: 'compatible' | 'incompatible' | 'unknown' | 'risky';
  confidence: number;
  issues: VersionIssue[];
  recommendations: string[];
}

export interface CompatibleVersionSet {
  mods: Record<string, string>; // modName -> version
  compatibilityScore: number;
  stabilityRating: number;
  performanceScore: number;
  knownIssues: VersionIssue[];
}

// Hardware-Specific Mining
export interface HardwareSpecificMiningEngine {
  analyzeHardwareProfile: (hardware: HardwareProfile) => Promise<HardwareOptimization[]>;
  recommendSettings: (hardware: HardwareProfile, modList: string[]) => Promise<HardwareRecommendation>;
  predictPerformance: (hardware: HardwareProfile, loadOrder: string[]) => Promise<HardwarePerformancePrediction>;
}

export interface HardwareProfile {
  cpu: CPUInfo;
  gpu: GPUInfo;
  ram: RAMInfo;
  storage: StorageInfo;
  os: OSInfo;
}

export interface CPUInfo {
  model: string;
  cores: number;
  threads: number;
  baseClock: number;
  boostClock: number;
  cache: number;
}

export interface GPUInfo {
  model: string;
  vram: number;
  driverVersion: string;
  dxVersion: string;
  rayTracing: boolean;
}

export interface RAMInfo {
  total: number;
  speed: number;
  type: string;
  channels: number;
}

export interface StorageInfo {
  type: 'HDD' | 'SSD' | 'NVMe';
  readSpeed: number;
  writeSpeed: number;
  totalSpace: number;
  availableSpace: number;
}

export interface OSInfo {
  name: string;
  version: string;
  architecture: 'x64' | 'x86' | 'arm64';
}



export interface HardwareRecommendation {
  iniSettings: Record<string, any>;
  loadOrderAdjustments: string[];
  textureSettings: TextureOptimization[];
  meshSettings: MeshOptimization[];
  expectedPerformance: HardwarePerformancePrediction;
}

export interface DetailedHardwarePerformancePrediction {
  averageFps: number;
  minimumFps: number;
  memoryUsage: number;
  loadTime: number;
  stabilityScore: number;
  bottlenecks: string[];
}

// Predictive Optimization Mining Engines
export interface LoadOrderOptimizationMiningEngine {
  analyze: (performanceData: PerformanceData[]) => Promise<LoadOrderOptimization[]>;
  optimize: (currentOrder: string[], performanceData: PerformanceData[]) => Promise<OptimizedLoadOrder>;
  predictImpact: (proposedOrder: string[], performanceData: PerformanceData[]) => Promise<LoadOrderImpact>;
}

export interface TextureOptimizationMiningEngine {
  analyze: (ddsFiles: DDSFile[], hardwareProfile: HardwareProfile) => Promise<TextureOptimization[]>;
  recommendCompression: (texture: DDSFile) => Promise<CompressionRecommendation>;
  batchOptimize: (textures: DDSFile[]) => Promise<BatchOptimizationResult>;
}

export interface MeshOptimizationMiningEngine {
  analyze: (nifFiles: NIFFile[], lodSettings: LODSettings) => Promise<MeshOptimization[]>;
  suggestLOD: (mesh: NIFFile, lodSettings: LODSettings) => Promise<LODSuggestion>;
  optimizeBatch: (meshes: NIFFile[], lodSettings: LODSettings) => Promise<BatchMeshOptimization>;
}

export interface IniParameterMiningEngine {
  analyze: (iniFiles: INIFile[], hardwareProfile: HardwareProfile) => Promise<IniOptimization[]>;
  recommendSettings: (iniFile: INIFile, hardwareProfile: HardwareProfile) => Promise<INISettingsRecommendation>;
  validateConfiguration: (iniSettings: Record<string, any>, hardwareProfile: HardwareProfile) => Promise<ConfigurationValidation>;
}

// Knowledge Graph Construction Mining Engines
export interface ModdingKnowledgeMiningEngine {
  mineFromSources: (sources: KnowledgeSource[]) => Promise<KnowledgeGraph>;
  extractInsights: (rawData: RawKnowledgeData[]) => Promise<ModdingInsight[]>;
  buildKnowledgeGraph: (insights: ModdingInsight[]) => Promise<KnowledgeGraph>;
}

// Additional supporting types for Predictive Optimization
export interface LoadOrderOptimization {
  currentOrder: string[];
  optimizedOrder: string[];
  performanceGain: number;
  stabilityImprovement: number;
  conflictReduction: number;
  reasoning: string[];
}

export interface OptimizedLoadOrder {
  order: string[];
  expectedPerformance: HardwarePerformancePrediction;
  conflictScore: number;
  stabilityRating: number;
}

export interface LoadOrderImpact {
  fpsImpact: number;
  memoryImpact: number;
  loadTimeImpact: number;
  stabilityImpact: number;
}

export interface TextureOptimization {
  texturePath: string;
  currentFormat: string;
  recommendedFormat: string;
  expectedSavings: number;
  performanceGain: number;
  compatibilityNotes: string[];
}

export interface CompressionRecommendation {
  texturePath: string;
  suggestedFormat: string;
  suggestedResolution: { width: number; height: number };
  performanceGain: number;
  fileSizeReduction: number;
  qualityImpact: number;
  compatibility: string[];
}

export interface BatchOptimizationResult {
  optimizations: TextureOptimization[];
  totalSavings: number;
  averagePerformanceGain: number;
  incompatibleTextures: string[];
}

export interface LODSettings {
  baseDistance: number;
  lod1Distance: number;
  lod2Distance: number;
  quality: 'low' | 'medium' | 'high';
  generateFromHighPoly: boolean;
}

export interface MeshOptimization {
  meshPath: string;
  currentVertexCount: number;
  optimizedVertexCount: number;
  lodLevels: number;
  expectedPerformanceGain: number;
  qualityLoss: number;
  recommendations: string[];
}

export interface LODSuggestion {
  meshPath: string;
  lodLevels: LODLevel[];
  totalReduction: number;
  performanceImpact: number;
  generationMethod: string;
}

export interface LODLevel {
  level: number;
  distance: number;
  vertexCount: number;
  triangleCount: number;
  quality: number;
}

export interface BatchMeshOptimization {
  optimizations: MeshOptimization[];
  totalVertexReduction: number;
  averagePerformanceGain: number;
  lodGenerationStats: LODGenerationStats;
}

export interface LODGenerationStats {
  totalMeshes: number;
  successfulGenerations: number;
  failedGenerations: number;
  averageLODsPerMesh: number;
}

export interface IniOptimization {
  iniPath: string;
  section: string;
  key: string;
  currentValue: string;
  recommendedValue: string;
  performanceImpact: number;
  stabilityImpact: number;
  reasoning: string;
}

export interface INISettingsRecommendation {
  settings: IniOptimization[];
  profile: string;
  expectedPerformanceGain: number;
  compatibilityWarnings: string[];
}

export interface ConfigurationValidation {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  performanceScore: number;
  recommendations: string[];
}

// Additional supporting types for Knowledge Graph Construction
export interface KnowledgeSource {
  id: string;
  type: 'forum' | 'wiki' | 'discord' | 'tutorial' | 'documentation';
  url: string;
  title: string;
  lastUpdated: number;
  credibility: number;
  tags: string[];
}

export interface KnowledgeGraph {
  nodes: KnowledgeNode[];
  edges: KnowledgeEdge[];
  metadata: {
    totalNodes: number;
    totalEdges: number;
    sourcesProcessed: number;
    lastUpdated: string;
    confidence: number;
  };
}

export interface KnowledgeNode {
  id: string;
  type: 'concept' | 'problem' | 'solution' | 'tutorial' | 'tool' | 'technique';
  label: string;
  content: string;
  source: string;
  confidence: number;
  tags: string[];
  metadata: Record<string, any>;
}

export interface KnowledgeEdge {
  id: string;
  source: string;
  target: string;
  type: 'requires' | 'solves' | 'related' | 'prerequisite' | 'improves' | 'conflicts';
  weight: number;
  evidence: string[];
  metadata?: Record<string, any>;
}

export interface RawKnowledgeData {
  source: KnowledgeSource;
  content: string;
  extractedAt: number;
  processingMetadata: Record<string, any>;
}

export interface ModdingInsight {
  id: string;
  type: 'solution' | 'warning' | 'optimization' | 'compatibility' | 'tutorial';
  title: string;
  description: string;
  confidence: number;
  sources: KnowledgeSource[];
  relatedNodes: string[];
  actionableSteps: string[];
  metadata: Record<string, any>;
}

// Update AdvancedAnalysisEngine interface
export interface AdvancedAnalysisEngine {
  patternRecognition: PatternRecognitionEngine;
  conflictPrediction: ConflictPredictionEngine;
  bottleneckMining: BottleneckMiningEngine;
  memoryAnalysis: MemoryAnalysisEngine;
  compatibilityMining: CompatibilityMiningEngine;
  formIdRelationshipMining: FormIDRelationshipMiningEngine;
  cellWorldspaceMining: CellWorldspaceMiningEngine;
  questObjectiveMining: QuestObjectiveMiningEngine;
  perkPowerMining: PerkPowerMiningEngine;
  loadOrderOptimization: LoadOrderOptimizationMiningEngine;
  textureOptimization: TextureOptimizationMiningEngine;
  meshOptimization: MeshOptimizationMiningEngine;
  iniParameterMining: IniParameterMiningEngine;
  moddingKnowledgeMining: ModdingKnowledgeMiningEngine;
  patchCompatibilityMining: PatchCompatibilityMiningEngine;
  versionCompatibilityMining: VersionCompatibilityMiningEngine;
  hardwareSpecificMining: HardwareSpecificMiningEngine;
  runComprehensiveAnalysis(data: AnalysisData): Promise<{
    patterns: PatternRecognitionResult;
    bottlenecks: BottleneckAnalysis;
    memory: MemoryAnalysis;
    compatibilityMatrix: CompatibilityMatrix;
  }>;
}

/**
 * Phase 2 Mining Engines - Advanced AI-driven analysis
 */

// Contextual Mining Engine Types
// (UserInteraction was moved above and merged)

export interface MiningUserProfile {
  preferences: {
    visualQuality: number;
    performancePriority: number;
    modCategories: Record<string, number>;
    complexityTolerance: number;
    automationPreference: number;
    learningStyle: 'visual' | 'textual' | 'interactive';
  };
  behaviorPatterns: MiningBehaviorPattern[];
  performanceTolerance: {
    minFPS: number;
    maxMemoryUsage: number;
    acceptableLoadTime: number;
  };
  modPreferences: Record<string, number>;
  settingPreferences: Record<string, any>;
  contextualPatterns: ContextualPattern[];
  learningProgress: {
    interactionsProcessed: number;
    feedbackIncorporated: number;
    patternsLearned: number;
    adaptationCycles: number;
  };
  lastUpdated: number;
}

export interface MiningBehaviorPattern {
  pattern: string;
  frequency: number;
  contexts: string[];
  successRate: number;
  lastObserved: number;
  confidence: number;
}

export interface ContextualPattern {
  context: string;
  preferences: Record<string, any>;
  frequency: number;
  effectiveness: number;
}

export interface PreferenceAnalysis {
  visualQuality?: number;
  performancePriority?: number;
  modCategories?: Record<string, number>;
  complexityTolerance?: number;
  automationPreference?: number;
  learningStyle?: string;
  confidence: number;
  preferences?: any;
  trends?: any;
  lastAnalyzed?: number;
  dataPoints?: number;
}

export interface ContextualRecommendation {
  type: any;
  item?: string;
  confidence: number;
  relevance: number; // Added
  reasoning?: string[];
  contextRelevance?: number;
  expectedImpact?: {
    performance: number;
    stability: number;
    compatibility: number;
  };
  id?: string;
  title?: string;
  description?: string;
  expectedOutcome?: string;
  actionRequired?: string;
  personalizationScore?: number;
  category?: string;
  userPreferenceAlignment?: number;
  prerequisites?: string[];
  alternatives?: string[];
}

// (UserFeedback was moved above and merged)

// (SessionContext was moved above and merged)

// (ContextTransition was moved above and merged)

export interface ContextHistory {
  sessionId: string;
  context: SessionContext;
  timestamp: number;
  duration?: number;
  transitions: ContextTransition[];
}

// (TransitionAnalysis was moved above and merged)

// (AdaptiveStrategy was moved above and merged)

export interface ContextualInsight {
  id: string;
  type: string;
  title: string;
  description: string;
  confidence: number;
  impact?: string;
  actionable?: boolean;
  category?: string;
  context?: Record<string, any>;
  recommendations?: any[];
  timestamp?: number;
}

// Contextual Mining Engine Interface
export interface AdvancedContextualMiningEngine {
  // Core lifecycle methods
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<any>;

  // User profiling methods
  recordUserInteraction(interaction: UserInteraction): Promise<void>;
  buildUserProfile(): Promise<UserProfile>;
  analyzeUserPreferences(): Promise<PreferenceAnalysis>;

  // Contextual analysis methods
  updateUserContext(context: UserContext): Promise<void>;
  generateContextualRecommendations(context: Record<string, any>): Promise<ContextualRecommendation[]>;

  // Adaptive learning methods
  incorporateUserFeedback(feedback: UserFeedback): Promise<void>;
  analyzeBehaviorPatterns(): Promise<{
    modCategoryPreferences: Record<string, number>;
    contextualBehaviors: Record<string, any>;
    successPatterns: Record<string, number>;
    riskTolerance: number;
  }>;

  // Personalization methods
  generatePersonalizedRecommendations(): Promise<ContextualRecommendation[]>;

  // Context awareness methods
  updateSessionContext(context: SessionContext): Promise<void>;
  getContextHistory(): Promise<ContextHistory[]>;
  recordContextTransition(transition: ContextTransition): Promise<void>;
  analyzeContextTransitions(): Promise<TransitionAnalysis>;
}

// Longitudinal Mining Engine Types
export interface LongitudinalHistoricalData {
  sessionId: string;
  timestamp: number;
  mods: string[];
  fps: number;
  memoryUsage: number;
  loadTime: number;
  performanceMetrics: PerformanceMetric;
  context: Record<string, any>;
}

export interface AdvancedPerformanceTrend {
  period: string;
  direction: 'improving' | 'degrading' | 'stable';
  magnitude: number;
  confidence: number;
  factors: string[];
  recommendations: string[];
}

export interface AdvancedTrendData {
  timestamp: number;
  value: number;
  context: Record<string, any>;
}

export interface AdvancedPerformanceChange {
  timestamp: number;
  type: 'improvement' | 'degradation';
  magnitude: number;
  causes: string[];
  confidence: number;
}

export interface AdvancedDegradationAlert {
  id: string;
  timestamp: number;
  severity: 'low' | 'medium' | 'high' | 'critical';
  type: 'performance' | 'stability' | 'compatibility';
  description: string;
  affectedMods: string[];
  recommendedActions: string[];
  confidence: number;
  context: Record<string, any>;
}

export interface AdvancedFuturePerformancePrediction {
  timestamp: number;
  predictionHorizon: number; // days
  predictedFPS: number;
  predictedMemoryUsage: number;
  confidence: number;
  riskFactors: string[];
  recommendations: string[];
  context: Record<string, any>;
}

export interface AdvancedSessionData {
  sessionId: string;
  startTime: number;
  endTime: number;
  mods: string[];
  peakVRAM: number;
  peakRAM: number;
  averageFPS: number;
  performanceMetrics?: PerformanceMetric;
  context?: Record<string, any>;
}

export interface AdvancedLongitudinalModChange {
  modName: string;
  type: 'added' | 'removed' | 'updated';
  version?: string;
  timestamp: number;
  impact: Record<string, any>;
}

export interface AdvancedUpdateImpactAnalysis {
  modName: string;
  currentVersion: string;
  newVersion: string;
  impact: {
    performance: number;
    compatibility: number;
    stability: number;
  };
  riskLevel: 'low' | 'medium' | 'high';
  recommendations: string[];
  confidence: number;
  context: Record<string, any>;
}

// Longitudinal Mining Engine Interface
export interface AdvancedLongitudinalMiningEngine {
  // Core lifecycle methods
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<any>;

  // Performance tracking methods
  trackPerformanceOverTime(): Promise<AdvancedPerformanceTrend[]>;
  detectPerformanceDegradation(): Promise<AdvancedDegradationAlert[]>;
  predictFuturePerformance(): Promise<AdvancedFuturePerformancePrediction>;
  analyzeModUpdateImpact(updates: AdvancedLongitudinalModChange[]): Promise<AdvancedUpdateImpactAnalysis[]>;
}

// Hardware-Aware Mining Engine Types
export interface AdvancedHardwareProfile {
  cpu: AdvancedCPUInfo;
  gpu: AdvancedGPUInfo;
  ram: AdvancedRAMInfo;
  storage: AdvancedStorageInfo;
  os: AdvancedOSInfo;
  bottlenecks: string[];
  optimizationScore: number;
}

export interface AdvancedHardwareCompatibility {
  modName: string;
  compatibility: 'excellent' | 'good' | 'fair' | 'poor' | 'incompatible';
  requirements: AdvancedHardwareRequirements;
  recommendations: AdvancedHardwareRecommendation[];
  performanceImpact: Record<string, any>;
}

export interface AdvancedHardwareRecommendation {
  type: 'setting' | 'mod' | 'configuration';
  item: string;
  action: 'enable' | 'disable' | 'adjust' | 'replace';
  value?: any;
  reasoning: string;
  expectedImpact: Record<string, any>;
  priority: 'low' | 'medium' | 'high';
}

export interface AdvancedHardwarePerformancePrediction {
  scenario: string;
  predictedFPS: number;
  predictedMemoryUsage: number;
  bottleneck: string;
  recommendations: AdvancedHardwareRecommendation[];
  confidence: number;
}

export interface AdvancedHardwareOptimization {
  category: 'cpu' | 'gpu' | 'memory' | 'storage' | 'settings';
  optimizations: AdvancedHardwareRecommendation[];
  expectedGain: number;
  riskLevel: 'low' | 'medium' | 'high';
  implementationDifficulty: 'easy' | 'medium' | 'hard';
}

export interface AdvancedHardwareRequirements {
  minCPU?: string;
  minGPU?: string;
  minRAM?: number;
  minStorage?: number;
  recommendedCPU?: string;
  recommendedGPU?: string;
  recommendedRAM?: number;
  recommendedStorage?: number;
}

export interface AdvancedCPUInfo {
  model: string;
  cores: number;
  threads: number;
  frequency: number;
  cache: number;
  architecture: string;
}

export interface AdvancedGPUInfo {
  model: string;
  vram: number;
  driverVersion: string;
  api: 'directx' | 'vulkan' | 'opengl';
  performanceScore: number;
}

export interface AdvancedRAMInfo {
  total: number;
  available: number;
  speed: number;
  type: string;
}

export interface AdvancedStorageInfo {
  type: 'hdd' | 'ssd' | 'nvme';
  total: number;
  available: number;
  readSpeed: number;
  writeSpeed: number;
}

export interface AdvancedOSInfo {
  name: string;
  version: string;
  architecture: string;
  pageFileSize?: number;
}

// Hardware-Aware Mining Engine Interface
export interface AdvancedHardwareAwareMiningEngine {
  // Core lifecycle methods
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<AdvancedPhase2MiningResult>;

  // Hardware analysis methods
  analyzeHardwareProfile(): Promise<AdvancedHardwareProfile>;
  checkModCompatibility(modName: string, requirements: AdvancedHardwareRequirements): Promise<AdvancedHardwareCompatibility>;
  generateHardwareRecommendations(profile: AdvancedHardwareProfile): Promise<AdvancedHardwareRecommendation[]>;
  predictPerformanceImpact(changes: AdvancedHardwareRecommendation[]): Promise<AdvancedHardwarePerformancePrediction>;
  optimizeForHardware(profile: AdvancedHardwareProfile): Promise<AdvancedHardwareOptimization[]>;
}

// ML Conflict Prediction Engine Types
export interface ConflictPattern {
  id: string;
  type: 'load_order' | 'compatibility' | 'resource' | 'script';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  affectedMods: string[];
  confidence: number;
  evidence: string[];
  solutions: ConflictSolution[];
}

export interface ConflictSolution {
  type: 'reorder' | 'disable' | 'replace' | 'patch';
  description: string;
  affectedMods: string[];
  expectedOutcome: Record<string, any>;
  riskLevel: 'low' | 'medium' | 'high';
  implementationSteps: string[];
}

export interface AdvancedConflictPrediction {
  modCombination: string[];
  predictedConflicts: ConflictPattern[];
  overallRisk: 'low' | 'medium' | 'high' | 'critical';
  confidence: number;
  conflictSolutions: ConflictSolution[];
  context: Record<string, any>;
}

export interface MLModelMetrics {
  accuracy: number;
  precision: number;
  recall: number;
  f1Score: number;
  trainingDataSize: number;
  lastTrained: number;
  modelVersion: string;
}

export interface TrainingData {
  modCombination: string[];
  conflicts: ConflictPattern[];
  resolution: ConflictSolution;
  outcome: 'success' | 'partial' | 'failure';
  feedback?: string;
}

// ML Conflict Prediction Engine Interface
export interface AdvancedMLConflictPredictionEngine {
  // Core lifecycle methods
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<AdvancedPhase2MiningResult>;

  // ML analysis methods
  predictConflicts(modCombination: string[]): Promise<AdvancedConflictPrediction>;
  analyzeConflictPatterns(): Promise<ConflictPattern[]>;
  generateConflictSolutions(conflicts: ConflictPattern[]): Promise<ConflictSolution[]>;
  trainModel(trainingData: TrainingData[]): Promise<MLModelMetrics>;
  incorporateFeedback(predictionId: string, outcome: 'accepted' | 'rejected', feedback?: string): Promise<void>;
}

// Performance Bottleneck Detection Engine Types
export interface AdvancedBottleneckAnalysis {
  primaryBottleneck: string;
  secondaryBottlenecksList: string[];
  severity: 'low' | 'medium' | 'high' | 'critical';
  impact: {
    fps: number;
    memory: number;
    loadTime: number;
  };
  recommendations: BottleneckSolution[];
  confidence: number;
  context: Record<string, any>;
}

export interface BottleneckSolution {
  type: 'hardware' | 'software' | 'configuration' | 'mod';
  description: string;
  expectedImprovement: Record<string, number>;
  implementationDifficulty: 'easy' | 'medium' | 'hard';
  riskLevel: 'low' | 'medium' | 'high';
  prerequisites: string[];
}

export interface SystemBottleneck {
  component: 'cpu' | 'gpu' | 'memory' | 'storage' | 'network';
  utilization: number;
  threshold: number;
  isBottleneck: boolean;
  recommendations: BottleneckSolution[];
}

export interface PerformanceOptimization {
  category: string;
  optimizations: BottleneckSolution[];
  expectedGain: number;
  implementationOrder: string[];
  dependencies: string[];
}

// Performance Bottleneck Detection Engine Interface
export interface AdvancedPerformanceBottleneckDetectionEngine {
  // Core lifecycle methods
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<AdvancedPhase2MiningResult>;

  // Bottleneck analysis methods
  analyzeBottlenecks(performanceData: PerformanceMetric): Promise<AdvancedBottleneckAnalysis>;
  identifyBottlenecks(systemInfo: any): Promise<SystemBottleneck[]>;
  generateOptimizationStrategies(bottlenecks: SystemBottleneck[]): Promise<PerformanceOptimization[]>;
  predictOptimizationImpact(optimizations: PerformanceOptimization[]): Promise<Record<string, any>>;
}

// Phase 2 Mining Result
export interface AdvancedPhase2MiningResult {
  engine: string;
  timestamp: number;
  insights: any[];
  recommendations: any[];
  predictions: any[];
  metrics: Record<string, any>;
  metadata: Record<string, any>;
}

/**
 * Extend Window interface to include our Electron API
 */
declare global {
  interface Window {
    electronAPI: ElectronAPI;
  }
}

// ===== ADVANCED FEATURES: Enhanced ML, Monitoring, Data Management, Scalability =====

/**
 * Enhanced LLM Service Types
 */
export interface LLMMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

export interface LLMConfig {
  provider: 'groq' | 'openai' | 'ollama';
  model?: string;
  temperature?: number;
  maxTokens?: number;
  version?: string;
}

export interface ModelVersion {
  id: string;
  provider: string;
  model: string;
  version: string;
  createdAt: number;
  performanceMetrics: {
    accuracy: number;
    latency: number;
    cost: number;
    userSatisfaction: number;
  };
  isActive: boolean;
  metadata: Record<string, any>;
}

export interface ABTestVariant {
  id: string;
  name: string;
  config: LLMConfig;
  weight: number;
  metrics: {
    impressions: number;
    conversions: number;
    satisfaction: number;
  };
}

export interface ABTest {
  id: string;
  name: string;
  variants: ABTestVariant[];
  startDate: number;
  endDate?: number;
  status: 'active' | 'completed' | 'paused';
  targetMetric: 'satisfaction' | 'accuracy' | 'latency';
}

export interface ModelExplainabilityResult {
  response: string;
  confidence: number;
  reasoning: string[];
  alternativeResponses: Array<{
    text: string;
    probability: number;
    reasoning: string;
  }>;
  biasAnalysis: {
    detectedBiases: string[];
    mitigationStrategies: string[];
  };
  sources: Array<{
    type: 'training_data' | 'knowledge_base' | 'context';
    relevance: number;
    content: string;
  }>;
}

/**
 * Monitoring Service Types
 */
export interface AlertRule {
  id: string;
  name: string;
  condition: {
    metric: string;
    operator: '>' | '<' | '>=' | '<=' | '==' | '!=';
    threshold: number;
    duration?: number;
  };
  severity: 'low' | 'medium' | 'high' | 'critical';
  enabled: boolean;
  cooldown: number;
  lastTriggered?: number;
  channels: ('notification' | 'websocket' | 'log')[];
}

export interface HealthMetric {
  name: string;
  value: number;
  unit: string;
  timestamp: number;
  status: 'healthy' | 'warning' | 'critical';
  metadata?: Record<string, any>;
}

export interface SystemHealth {
  cpuUsage: number;
  memoryUsage: number;
  diskUsage: number;
  networkActivity: number;
  miningEngineStatus: 'active' | 'idle' | 'error';
  activeConnections: number;
  uptime: number;
  lastUpdate: number;
}

export interface NotificationMessage {
  id: string;
  type: 'alert' | 'info' | 'warning' | 'success';
  title: string;
  message: string;
  timestamp: number;
  data?: any;
  actions?: Array<{
    label: string;
    action: string;
    data?: any;
  }>;
}

/**
 * Data Management Service Types
 */
export interface AccountUserProfile {
  id: string;
  anonymizedId: string;
  preferences: {
    theme: 'light' | 'dark' | 'auto';
    language: string;
    notifications: boolean;
    analytics: boolean;
  };
  usageStats: {
    sessionsCount: number;
    totalTimeSpent: number;
    lastActivity: number;
    favoriteFeatures: string[];
  };
  moddingHistory: {
    projectsCreated: number;
    modsDownloaded: number;
    toolsUsed: string[];
    skillLevel: 'beginner' | 'intermediate' | 'advanced';
  };
  createdAt: number;
  lastUpdated: number;
  consentGiven: boolean;
  dataRetentionPeriod: number;
}

export interface DataExport {
  id: string;
  userId: string;
  requestedAt: number;
  completedAt?: number;
  format: 'json' | 'csv' | 'xml';
  includesPersonalData: boolean;
  includesAnalytics: boolean;
  includesUsageData: boolean;
  downloadUrl?: string;
  expiresAt: number;
}

export interface GDPRRequest {
  id: string;
  userId: string;
  type: 'access' | 'rectification' | 'erasure' | 'portability' | 'restriction' | 'objection';
  status: 'pending' | 'processing' | 'completed' | 'rejected';
  requestedAt: number;
  completedAt?: number;
  reason?: string;
  data?: any;
}

export interface PrivacySettings {
  dataCollectionEnabled: boolean;
  analyticsEnabled: boolean;
  crashReportingEnabled: boolean;
  personalizationEnabled: boolean;
  dataRetentionDays: number;
  anonymizeByDefault: boolean;
  exportDataOnRequest: boolean;
  autoDeleteOldData: boolean;
}

/**
 * Scalability Service Types
 */
export interface CacheEntry {
  key: string;
  value: any;
  expiresAt?: number;
  lastAccessed: number;
  accessCount: number;
  size: number;
}

export interface DistributedTask {
  id: string;
  type: string;
  payload: any;
  priority: 'low' | 'medium' | 'high' | 'critical';
  createdAt: number;
  assignedTo?: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  result?: any;
  error?: string;
  retries: number;
  maxRetries: number;
  timeout: number;
}

export interface WorkerNode {
  id: string;
  type: 'cpu' | 'gpu' | 'io';
  capabilities: string[];
  status: 'idle' | 'busy' | 'offline';
  lastHeartbeat: number;
  tasksProcessed: number;
  performance: {
    avgResponseTime: number;
    successRate: number;
    currentLoad: number;
  };
}
