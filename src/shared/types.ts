/**
 * Shared TypeScript types for the Desktop AI Assistant
 * Used across main, renderer, and preload processes
 */

/**
 * Project management types for multi-project support
 */
export interface ModProject {
  id: string;
  name: string;
  description?: string;
  path: string; // Root directory of the project
  game: 'fallout4' | 'skyrim' | 'skyrimse' | 'fallout76' | 'other';
  createdAt: number;
  updatedAt: number;
  settings: ProjectSettings;
  collaborators?: Collaborator[];
  versionControl?: VersionControlConfig;
  metadata: {
    modFiles: string[];
    lastBackup?: number;
    size: number; // in bytes
    tags: string[];
  };
}

export interface ProjectSettings {
  // Tool paths specific to this project
  xeditPath?: string;
  nifSkopePath?: string;
  creationKitPath?: string;
  blenderPath?: string;

  // Game-specific settings
  gamePath?: string;
  dataPath?: string;

  // Build/output settings
  outputPath?: string;
  archivePath?: string;

  // Workflow preferences
  preferredTools: string[];
  autoBackup: boolean;
  backupInterval: number; // minutes
}

/**
 * Collaboration types
 */
export interface Collaborator {
  id: string;
  name: string;
  email?: string;
  role: 'owner' | 'editor' | 'viewer';
  avatar?: string;
  lastActive: number;
  permissions: {
    canEdit: boolean;
    canDelete: boolean;
    canInvite: boolean;
    canManageSettings: boolean;
  };
}

export interface VersionControlConfig {
  type: 'git' | 'svn' | 'none';
  repository?: string;
  branch: string;
  remote?: string;
  autoCommit: boolean;
  commitMessageTemplate: string;
  ignorePatterns: string[];
}

export interface CollaborationSession {
  id: string;
  projectId: string;
  participants: Collaborator[];
  activeFiles: string[];
  lastActivity: number;
  status: 'active' | 'idle' | 'ended';
}

/**
 * Roadmap System: Dynamic progress checklists for modding goals
 */
export interface RoadmapStep {
  id: string;
  title: string;
  description: string;
  status: 'not-started' | 'in-progress' | 'completed' | 'blocked';
  tool?: 'blender' | 'ck' | 'xedit' | 'nifskope' | 'image-suite' | 'scribe';
  order: number;
  completionCriteria?: string;
  resources?: { title: string; url: string }[];
}

export interface Roadmap {
  id: string;
  projectId: string; // Roadmap is bound to a project
  title: string;
  goal: string;
  icon?: string;
  steps: RoadmapStep[];
  currentStepId?: string;
  isCustom: boolean; // True if generated by AI for a specific prompt
  createdAt: number;
  updatedAt: number;
}

/**
 * Project Wizard: Guided flows for common modding tasks (Phase 3)
 */
export interface WizardStep {
  id: string;
  title: string;
  description: string;
  status: 'not-started' | 'in-progress' | 'completed';
  type: 'script' | 'blender' | 'audit' | 'setup';
  data?: any; // Stores progress or configuration for this step (e.g., source file path)
}

export interface ProjectWizardState {
  id: string;
  projectId: string;
  name: string;
  steps: WizardStep[];
  currentStepIndex: number;
  lastUpdated: number;
}

/**
 * Analytics types
 */
export interface AnalyticsEvent {
  id: string;
  timestamp: number;
  event: string;
  category: 'usage' | 'performance' | 'error' | 'feature';
  properties: Record<string, any>;
  userId?: string; // Anonymous ID
  sessionId: string;
  version: string;
  platform: string;
}

export interface AnalyticsConfig {
  enabled: boolean;
  anonymousId: string;
  userId?: string;
  consentedAt?: number;
  dataRetentionDays: number;
  categories: {
    usage: boolean;
    performance: boolean;
    errors: boolean;
    features: boolean;
  };
  destinations: {
    local: boolean; // Store locally for debugging
    remote: boolean; // Send to analytics service
  };
}

export interface UsageMetrics {
  sessionStart: number;
  sessionDuration: number;
  featuresUsed: string[];
  toolsLaunched: string[];
  filesProcessed: number;
  errorsEncountered: number;
  performanceMetrics: {
    avgResponseTime: number;
    memoryUsage: number;
    cpuUsage: number;
  };
}

/**
 * Message in the chat history
 */
export interface Message {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: number;
}

// --- Security & Malware scanning types ---
export interface ThreatInfo {
  hash: string;
  name: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  category?: string;
  firstSeen?: number;
  lastSeen?: number;
  description?: string;
}

export interface ScanResult {
  filePath: string;
  infected: boolean;
  threats: ThreatInfo[];
  scannedAt: number;
  engineVersion?: string;
  summary?: string;
}

export interface ArchiveScanEntry { filename: string; result: ScanResult }
export interface ArchiveScanResult { archivePath: string; entries: ArchiveScanEntry[]; infectedCount: number; scannedAt: number }
export interface ScriptScanResult { scriptPath: string; suspiciousPatterns: Pattern[]; issues: string[]; score: number; scannedAt: number }

export interface Pattern { id: string; description: string; severity: 'low' | 'medium' | 'high' | 'critical'; match: string }

export interface CodeIssue { line: number; severity: 'info' | 'warning' | 'error'; message: string; ruleId?: string }
export interface CodeAnalysis { issues: CodeIssue[]; complexity: { cyclomatic: number; maintainability: number }; recommendations: string[] }

export interface SandboxResult { exitCode: number; stdout?: string; stderr?: string; timedOut?: boolean; durationMs: number; isolationId?: string }
export interface UpdateResult { success: boolean; updatedAt?: number; version?: string; error?: string }

export interface SandboxConfig { timeoutMs?: number; memoryLimitMb?: number; cpuLimit?: number }

/**
 * Application settings stored persistently
 */
export interface Settings {
    // Secure API keys for backend TTS/STT (main process only)
    openaiApiKey?: string;
    groqApiKey?: string;
    elevenLabsApiKey?: string;
  // Backend configuration
  backendBaseUrl?: string;
  backendTokenConfigured?: boolean;
  // LLM Configuration
  llmApiEndpoint: string;
  llmApiKey?: string;
  llmModel: string;

  // Local AI (optional)
  localAiPreferredProvider?: 'auto' | 'cosmos' | 'ollama' | 'openai_compat' | 'off';
  ollamaBaseUrl?: string;
  ollamaModel?: string;
  openaiCompatBaseUrl?: string;
  openaiCompatModel?: string;
  cosmosBaseUrl?: string;
  cosmosModel?: string;
  
  // Audio Settings
  ttsEnabled: boolean;
  ttsVoice: string;
  ttsRate: number;
  ttsPitch: number;
  sttEnabled: boolean;
  sttLanguage: string;

  // UI Settings
  theme: 'light' | 'dark' | 'system';
  /** UI language (BCP-47 tag like 'en', 'en-US', 'es', or 'auto' to follow OS). */
  uiLanguage?: string;
  alwaysOnTop: boolean;
  startMinimized: boolean;
  
  // Behavior
  autoStart: boolean;
  globalHotkey?: string;

  // External Modding Tools
  xeditPath?: string;
  nifSkopePath?: string;
  xeditScriptsDirOverride?: string;
  fomodCreatorPath?: string;
  creationKitPath?: string;
  blenderPath?: string;
  lootPath?: string;
  vortexPath?: string;
  mo2Path?: string;
  
  // Game Paths
  fallout4Path?: string;

  // Creation Kit / Papyrus
  papyrusCompilerPath?: string;
  papyrusFlagsPath?: string;
  papyrusImportPaths?: string; // semicolon-separated
  papyrusSourcePath?: string; // where .psc live (e.g. Data\\Scripts\\Source\\User)
  papyrusOutputPath?: string; // where .pex output goes (e.g. Data\\Scripts)
  papyrusTemplateLibrary?: PapyrusTemplate[];

  // Script libraries (The Scribe)
  xeditScriptLibrary?: ScriptTemplate[];
  blenderScriptLibrary?: ScriptTemplate[];
  scriptBundles?: ScriptBundle[];
  wryeBashPath?: string;
  bodySlidePath?: string;
  outfitStudioPath?: string;
  baePath?: string;
  gimpPath?: string;
  archive2Path?: string;
  pjmScriptPath?: string;
  f4sePath?: string;
  upscaylPath?: string;
  photopeaPath?: string;
  shaderMapPath?: string;
  nvidiaTextureToolsPath?: string;
  autodeskFbxPath?: string;
  photoDemonPath?: string;
  unWrap3Path?: string;
  nifUtilsSuitePath?: string;
  nvidiaOmniversePath?: string;
  spin3dPath?: string;
  nvidiaCanvasPath?: string;

  // Community Sharing
  communityRepo?: string; // GitHub repo in the form "owner/repo"
  communityContributorName?: string;
  communityContributorLink?: string;

  // Load Order Lab (experimental)
  loadOrderLabXeditPresetId?: string;
  loadOrderLabXeditArgsTemplate?: string;
  loadOrderLabXeditArgsEnabled?: boolean;
  loadOrderLabPreparedScriptPath?: string;

  // Workflow Runner
  workflowRunnerWorkflows?: WorkflowRunnerWorkflow[];
  workflowRunnerRunHistory?: WorkflowRunnerRun[];

  // Privacy & Security Settings
  privacySettings: {
    // Data Collection & Sharing
    allowAnalytics: boolean;
    allowCrashReporting: boolean;
    allowUsageMetrics: boolean;
    shareModProjectData: boolean;
    shareScriptPatterns: boolean;
    shareMeshOptimizations: boolean;
    contributeToKnowledgeBase: boolean;

    // Data Retention
    keepLocalOnly: boolean;
    autoDeleteOldData: boolean;
    dataRetentionDays: number;

    // Permissions
    allowFileSystemAccess: boolean;
    allowNetworkAccess: boolean;
    allowExternalTools: boolean;
    allowClipboardAccess: boolean;

    // Security
    requirePasswordForSettings: boolean;
    encryptLocalData: boolean;
    autoLockAfterInactivity: boolean;
    inactivityTimeoutMinutes: number;
  };

  // Security Settings
  securitySettings: {
    // API Key Management
    apiKeyRotationEnabled: boolean;
    apiKeyRotationDays: number;
    requireApiKeyConfirmation: boolean;

    // Encryption
    encryptionEnabled: boolean;
    encryptionAlgorithm: 'aes-256-gcm' | 'chacha20-poly1305';

    // Access Control
    allowedDomains: string[];
    blockedDomains: string[];
    requireHttps: boolean;
  };

  // Multi-Project Support
  currentProjectId?: string;
  projects: ModProject[];

  // Project Wizard (Phase 3)
  wizardStates: ProjectWizardState[];

  // Collaboration Features
  collaborationEnabled: boolean;
  collaborationSessions: CollaborationSession[];

  // Advanced Analytics
  analytics: AnalyticsConfig;
}

/**
 * Installed program information
 */
export interface InstalledProgram {
  name: string;
  displayName: string;
  path: string;
  icon?: string;
  version?: string;
  publisher?: string;
}

/**
 * System information for AI/modding capabilities
 */
export interface SystemInfo {
  cpu: string;
  ram: string;
  gpu: string[];
  os: string;
  aiCapabilities: string[];
  pythonVersions: string[];
  nodeVersion: string | null;
}

export type WorkflowRunnerStepType = 'runTool' | 'openProgram' | 'openExternal' | 'revealInFolder';

export interface WorkflowRunnerStep {
  id: string;
  type: WorkflowRunnerStepType;
  label: string;
  cmd?: string;
  args?: string;
  cwd?: string;
  target?: string;
}

export interface WorkflowRunnerWorkflow {
  id: string;
  name: string;
  description?: string;
  steps: WorkflowRunnerStep[];
  createdAt: string;
  updatedAt: string;
}

export interface WorkflowRunnerRun {
  id: string;
  workflowId: string;
  workflowName: string;
  startedAt: string;
  endedAt: string;
  success: boolean;
  logs: Array<{ at: string; level: 'info' | 'warn' | 'error'; message: string }>;
}

export interface PapyrusTemplate {
  id: string;
  title: string;
  description?: string;
  author?: string;
  scriptName: string;
  extendsType: string;
  templateKind?: string;
  body: string;
  createdAt: string;
  updatedAt: string;
}

export interface ScriptTemplate {
  id: string;
  title: string;
  description?: string;
  author?: string;
  scriptType: 'xedit' | 'blender';
  body: string;
  createdAt: string;
  updatedAt: string;
}

export interface ScriptBundle {
  id: string;
  title: string;
  description?: string;
  author?: string;
  templates: ScriptTemplate[];
  createdAt: string;
  updatedAt: string;
}

/**
 * Default settings
 */
export const DEFAULT_SETTINGS: Settings = {
  llmApiEndpoint: 'https://api.openai.com/v1/chat/completions',
  llmModel: 'gpt-3.5-turbo',
  localAiPreferredProvider: 'auto',
  ollamaBaseUrl: 'http://127.0.0.1:11434',
  ollamaModel: 'llama3',
  openaiCompatBaseUrl: 'http://127.0.0.1:1234/v1',
  openaiCompatModel: '',
  cosmosBaseUrl: '',
  cosmosModel: '',
  ttsEnabled: true,
  ttsVoice: 'default',
  ttsRate: 1.0,
  ttsPitch: 1.0,
  sttEnabled: true,
  sttLanguage: 'en-US',
  theme: 'system',
  uiLanguage: 'auto',
  alwaysOnTop: false,
  startMinimized: false,
  autoStart: false,
  // Tool paths empty by default; user configures in settings
  xeditPath: '',
    xeditScriptsDirOverride: '',
  nifSkopePath: '',
  fomodCreatorPath: '',
  creationKitPath: '',
  blenderPath: '',
  lootPath: '',
  vortexPath: '',
  mo2Path: '',
  fallout4Path: '',
  wryeBashPath: '',
  bodySlidePath: '',
  outfitStudioPath: '',
  baePath: '',
  gimpPath: '',
  archive2Path: '',
  pjmScriptPath: '',
  f4sePath: '',
  upscaylPath: '',
  photopeaPath: '',
  shaderMapPath: '',
  nvidiaTextureToolsPath: '',
  autodeskFbxPath: '',
  photoDemonPath: '',
  unWrap3Path: '',
  nifUtilsSuitePath: '',
  nvidiaOmniversePath: '',
  spin3dPath: '',
  nvidiaCanvasPath: '',

  // Papyrus
  papyrusCompilerPath: '',
  papyrusFlagsPath: '',
  papyrusImportPaths: '',
  papyrusSourcePath: '',
  papyrusOutputPath: '',
  papyrusTemplateLibrary: [],

  // Script libraries (The Scribe)
  xeditScriptLibrary: [],
  blenderScriptLibrary: [],
  scriptBundles: [],

  // Community Sharing
  communityRepo: '',
  communityContributorName: '',
  communityContributorLink: '',

  // Load Order Lab (experimental)
  loadOrderLabXeditPresetId: 'fo4edit-script-quoted',
  loadOrderLabXeditArgsTemplate: '',
  loadOrderLabXeditArgsEnabled: false,
  loadOrderLabPreparedScriptPath: '',

  // Workflow Runner
  workflowRunnerWorkflows: [],
  workflowRunnerRunHistory: [],

  // Privacy & Security Settings
  privacySettings: {
    // Data Collection & Sharing
    allowAnalytics: false,
    allowCrashReporting: false,
    allowUsageMetrics: false,
    shareModProjectData: false,
    shareScriptPatterns: false,
    shareMeshOptimizations: false,
    contributeToKnowledgeBase: false,

    // Data Retention
    keepLocalOnly: true,
    autoDeleteOldData: false,
    dataRetentionDays: 365,

    // Permissions
    allowFileSystemAccess: true,
    allowNetworkAccess: true,
    allowExternalTools: true,
    allowClipboardAccess: true,

    // Security
    requirePasswordForSettings: false,
    encryptLocalData: true,
    autoLockAfterInactivity: false,
    inactivityTimeoutMinutes: 30,
  },

  // Security Settings
  securitySettings: {
    // API Key Management
    apiKeyRotationEnabled: false,
    apiKeyRotationDays: 90,
    requireApiKeyConfirmation: true,

    // Encryption
    encryptionEnabled: true,
    encryptionAlgorithm: 'aes-256-gcm',

    // Access Control
    allowedDomains: [],
    blockedDomains: [],
    requireHttps: true,
  },

  // Multi-Project Support
  currentProjectId: undefined,
  projects: [],

  // Project Wizard (Phase 3)
  wizardStates: [],

  // Collaboration Features
  collaborationEnabled: false,
  collaborationSessions: [],

  // Advanced Analytics
  analytics: {
    enabled: false,
    anonymousId: '',
    dataRetentionDays: 90,
    categories: {
      usage: false,
      performance: false,
      errors: false,
      features: false,
    },
    destinations: {
      local: true,
      remote: false,
    },
  },
};

/**
 * IPC Channel names for main <-> renderer communication
 */
export const IPC_CHANNELS = {
  // Messages
  SEND_MESSAGE: 'send-message',
  ON_MESSAGE: 'on-message',

  // Settings
  GET_SETTINGS: 'get-settings',
  SET_SETTINGS: 'set-settings',
  SETTINGS_UPDATED: 'settings-updated',

  // Audio
  TTS_SPEAK: 'tts-speak',
  STT_START: 'stt-start',
  STT_STOP: 'stt-stop',
  STT_RESULT: 'stt-result',

  // Window
  MINIMIZE_WINDOW: 'minimize-window',
  CLOSE_WINDOW: 'close-window',

  // Workshop
  WORKSHOP_READ_DDS_PREVIEW: 'workshop-read-dds-preview',
  WORKSHOP_READ_NIF_INFO: 'workshop-read-nif-info',
  WORKSHOP_PARSE_SCRIPT_DEPS: 'workshop-parse-script-deps',

  // Image Suite
  IMAGE_GET_INFO: 'image-get-info',
  IMAGE_GENERATE_NORMAL_MAP: 'image-generate-normal-map',
  IMAGE_GENERATE_ROUGHNESS_MAP: 'image-generate-roughness-map',
  IMAGE_GENERATE_HEIGHT_MAP: 'image-generate-height-map',
  IMAGE_GENERATE_METALLIC_MAP: 'image-generate-metallic-map',
  IMAGE_GENERATE_AO_MAP: 'image-generate-ao-map',
  IMAGE_CONVERT_FORMAT: 'image-convert-format',

  // FOMOD Assembler
  FOMOD_SCAN_MOD_FOLDER: 'fomod-scan-mod-folder',
  FOMOD_ANALYZE_STRUCTURE: 'fomod-analyze-structure',
  FOMOD_VALIDATE_XML: 'fomod-validate-xml',
  FOMOD_EXPORT_PACKAGE: 'fomod-export-package',

  // Save/Load
  SAVE_FILE: 'save-file',
  PICK_JSON_FILE: 'pick-json-file',
  PICK_DIRECTORY: 'pick-directory',

  // Local ML
  ML_INDEX_BUILD: 'ml-index-build',
  ML_INDEX_STATUS: 'ml-index-status',
  ML_INDEX_QUERY: 'ml-index-query',
  ML_CAPS_STATUS: 'ml-caps-status',
  ML_LLM_STATUS: 'ml-llm-status',
  ML_LLM_GENERATE: 'ml-llm-generate',

  // Load Order Lab
  LOAD_ORDER_PICK_MO2_PROFILE_DIR: 'load-order-pick-mo2-profile-dir',
  LOAD_ORDER_PICK_LOOT_REPORT_FILE: 'load-order-pick-loot-report-file',
  LOAD_ORDER_WRITE_USERDATA_FILE: 'load-order-write-userdata-file',
  LOAD_ORDER_LAUNCH_XEDIT: 'load-order-launch-xedit',

  // Secrets
  SECRET_STATUS: 'secret-status',

  // STT/Transcription
  TRANSCRIBE_AUDIO: 'transcribe-audio',

  // Duplicate Finder
  DEDUPE_PICK_FOLDERS: 'dedupe-pick-folders',
  DEDUPE_SCAN: 'dedupe-scan',
  DEDUPE_CANCEL: 'dedupe-cancel',
  DEDUPE_PROGRESS: 'dedupe-progress',
  DEDUPE_TRASH: 'dedupe-trash',

  // Multi-Project Support
  PROJECT_CREATE: 'project-create',
  PROJECT_UPDATE: 'project-update',
  PROJECT_DELETE: 'project-delete',
  PROJECT_SWITCH: 'project-switch',
  PROJECT_LIST: 'project-list',
  PROJECT_GET_CURRENT: 'project-get-current',

  // Roadmap System
  ROADMAP_GET_ALL: 'roadmap-get-all',
  ROADMAP_GET_ACTIVE: 'roadmap-get-active',
  ROADMAP_CREATE: 'roadmap-create',
  ROADMAP_UPDATE_STEP: 'roadmap-update-step',
  ROADMAP_DELETE: 'roadmap-delete',
  ROADMAP_GENERATE_AI: 'roadmap-generate-ai',

  // Project Wizard (Phase 3)
  WIZARD_GET_STATE: 'wizard-get-state',
  WIZARD_UPDATE_STEP: 'wizard-update-step',
  WIZARD_SUBMIT_ACTION: 'wizard-submit-action',

  // Proactive Observer (Neural Link+)
  OBSERVER_NOTIFY: 'observer-notify', // Sent from Main to Renderer
  OBSERVER_SET_ACTIVE_FOLDER: 'observer-set-active-folder',

  // Collaboration Features
  COLLABORATION_JOIN_SESSION: 'collaboration-join-session',
  COLLABORATION_LEAVE_SESSION: 'collaboration-leave-session',
  COLLABORATION_SYNC_FILE: 'collaboration-sync-file',
  COLLABORATION_UPDATE_PARTICIPANTS: 'collaboration-update-participants',
  COLLABORATION_GIT_INIT: 'collaboration-git-init',
  COLLABORATION_GIT_COMMIT: 'collaboration-git-commit',
  COLLABORATION_GIT_PUSH: 'collaboration-git-push',
  COLLABORATION_GIT_PULL: 'collaboration-git-pull',

  // Advanced Analytics
  ANALYTICS_TRACK_EVENT: 'analytics-track-event',
  ANALYTICS_GET_METRICS: 'analytics-get-metrics',
  ANALYTICS_EXPORT_DATA: 'analytics-export-data',
  ANALYTICS_UPDATE_CONFIG: 'analytics-update-config',

  // Scribe Advanced (Phase 4)
  SCRIBE_INSTALL_SCRIPT: 'scribe-install-script',
} as const;

/**
 * Mining Infrastructure Types
 */

// ESP/ESM File Structures
export interface ESPRecord {
  type: string; // Record type (e.g., 'TES4', 'WEAP', 'ARMO')
  formId: number;
  editorId?: string;
  flags: number;
  fields: ESPField[];
  subrecords?: ESPRecord[];
  // Extended properties for analysis
  name?: string;
  references?: number[]; // FormIDs this record references
  dependencies?: number[]; // FormIDs this record depends on
  cellId?: number; // For CELL records
  isAddition?: boolean; // For cell modifications
  isDeletion?: boolean; // For cell modifications
  baseObject?: string; // Object type being modified
  position?: { x: number; y: number; z: number }; // For placed objects
  deletionReason?: string; // Why object was deleted
}

export interface ESPField {
  type: string; // Field type (e.g., 'EDID', 'FULL', 'DATA')
  data: Buffer;
  size: number;
}

export interface ESPFile {
  fileName: string; // The name of the ESP file
  header: ESPRecord;
  records: ESPRecord[];
  masters: string[]; // Master files this plugin depends on
  formIdMap: Map<number, ESPRecord>; // Quick lookup by FormID
}

export interface DDSFile {
  fileName: string;
  path: string;
  format: string;
  resolution: { width: number; height: number };
  mipmaps: number;
  size: number;
  compression: string;
  metadata: {
    lastModified: number;
    hash?: string;
  };
}

export interface NIFFile {
  fileName: string;
  path: string;
  version: string;
  vertexCount: number;
  triangleCount: number;
  materialCount: number;
  texturePaths: string[];
  boundingBox: {
    min: [number, number, number];
    max: [number, number, number];
  };
  size: number;
  metadata: {
    lastModified: number;
    hash?: string;
  };
}

export interface INIFile {
  fileName: string;
  path: string;
  sections: Map<string, Map<string, string>>;
  comments: Map<string, string[]>;
  size: number;
  metadata: {
    lastModified: number;
    hash?: string;
  };
}

// Asset Correlation Types
export interface AssetReference {
  type: 'nif' | 'dds' | 'hkx' | 'seq' | 'wav' | 'fuz';
  path: string;
  formId?: number;
  recordType?: string;
}

export interface AssetCorrelation {
  primaryAsset: AssetReference;
  relatedAssets: AssetReference[];
  dependencies: string[]; // File paths this asset depends on
  dependents: string[]; // Files that depend on this asset
  metadata: {
    size: number;
    lastModified: number;
    hash?: string;
  };
}

// Mod Dependency Graph
export interface ModNode {
  name: string;
  filename: string;
  masters: string[]; // Required master files
  optionalMasters: string[]; // Optional master files
  providedRecords: Map<string, number[]>; // Record types and FormIDs provided
  requiredRecords: Map<string, number[]>; // Record types and FormIDs required
  conflicts: ModConflict[];
  loadOrder: number;
  enabled: boolean;
}

export interface ModConflict {
  type: 'override' | 'conflict' | 'compatibility';
  conflictingMod: string;
  recordType: string;
  formIds: number[];
  severity: 'minor' | 'major' | 'critical';
}

export interface ModDependencyGraph {
  nodes: Map<string, ModNode>;
  edges: ModDependencyEdge[];
  cycles: string[][]; // Detected circular dependencies
  loadOrder: string[]; // Optimal load order
}

export interface ModDependencyEdge {
  from: string; // Mod name
  to: string; // Required mod name
  type: 'master' | 'optional' | 'compatibility';
  weight: number; // Strength of dependency
}

// --- Mod Browser / Workshop types ---
export interface ModListing {
  id: string;
  name: string;
  author: string;
  summary: string;
  category: string;
  version: string;
  downloads: number;
  endorsements: number;
  thumbnailUrl: string;
  uploadedAt: number;
  updatedAt: number;
}

export interface ModFile {
  id: string;
  name: string;
  version: string;
  size: number;
  downloadUrl: string;
  isPrimary: boolean;
}

export interface ModDetails extends ModListing {
  description: string;
  requirements: string[];
  files: ModFile[];
  images: string[];
  videos: string[];
  changelog: string;
  tags: string[];
}

export interface SearchFilters {
  game: 'fallout4' | 'skyrim';
  category?: string;
  tags?: string[];
  sortBy: 'trending' | 'downloads' | 'recent' | 'endorsements';
  nsfw: boolean;
}

export interface Review {
  userId: string;
  username: string;
  rating: number;
  text: string;
  helpful: number;
  timestamp: number;
}

export interface Collection {
  id: string;
  name: string;
  description: string;
  mods: string[];
  author: string;
  downloads: number;
  shareUrl: string;
}

export interface DownloadResult {
  success: boolean;
  filePath: string;
  size: number;
  duration: number;
}

export interface AuthResult { success: boolean; provider?: string; token?: string; expiresAt?: number; error?: string }

// Performance Metrics
export interface PerformanceMetric {
  modCombination: string[]; // List of mod names
  fps: number;
  memoryUsage: number; // MB
  loadTime: number; // seconds
  stabilityScore: number; // 0-100
  conflictCount: number;
  timestamp: number;
  hardwareProfile: HardwareProfile;
}



export interface PerformanceReport {
  baselineMetrics: PerformanceMetric;
  modImpact: Map<string, PerformanceImpact>;
  recommendations: PerformanceRecommendation[];
  compatibilityMatrix: Map<string, Map<string, number>>; // Mod pairs and compatibility score
}

export interface PerformanceImpact {
  fpsDelta: number;
  memoryDelta: number;
  loadTimeDelta: number;
  stabilityDelta: number;
}

export interface PerformanceRecommendation {
  type: 'disable' | 'reorder' | 'patch' | 'alternative';
  targetMods: string[];
  description: string;
  expectedImprovement: PerformanceImpact;
  confidence: number; // 0-100
}

// Pattern Recognition Engine Types
export interface PatternRecognitionResult {
  patterns: DetectedPattern[];
  anomalies: Anomaly[];
  recommendations: PatternRecommendation[];
  confidence: number;
}

export interface DetectedPattern {
  id: string;
  type: 'conflict' | 'performance' | 'compatibility' | 'resource' | 'script';
  description: string;
  affectedMods: string[];
  severity: 'low' | 'medium' | 'high' | 'critical';
  frequency: number; // How often this pattern occurs
  examples: PatternExample[];
}

export interface PatternExample {
  modCombination: string[];
  outcome: 'success' | 'failure' | 'warning';
  metrics?: PerformanceMetric;
  description: string;
}

export interface Anomaly {
  id: string;
  type: 'performance' | 'memory' | 'compatibility' | 'resource';
  description: string;
  affectedMods: string[];
  deviation: number; // Standard deviations from normal
  severity: 'low' | 'medium' | 'high' | 'critical';
}

export interface PatternRecommendation {
  type: 'avoid' | 'prefer' | 'patch' | 'alternative';
  targetPattern: string;
  description: string;
  confidence: number;
  alternatives?: string[];
}

// Performance Bottleneck Mining Types

export interface PerformanceBottleneck {
  modName: string;
  bottleneckType: 'cpu' | 'gpu' | 'memory' | 'io' | 'script';
  impact: number; // FPS impact
  confidence: number;
  evidence: BottleneckEvidence[];
  mitigationStrategies: string[];
}

export interface BottleneckEvidence {
  metric: string;
  value: number;
  threshold: number;
  description: string;
}

export interface OptimizationOpportunity {
  type: 'texture' | 'mesh' | 'script' | 'config' | 'load_order';
  description: string;
  potentialGain: number; // FPS gain
  difficulty: 'easy' | 'medium' | 'hard';
  affectedMods: string[];
}

// Backwards-compatible alias expected across the codebase
export type Optimization = OptimizationOpportunity;

// Memory Usage Analysis Types
export interface MemoryAnalysis {
  vramUsage: VRAMUsage;
  systemRamUsage: RAMUsage;
  memoryPatterns: MemoryPattern[];
  recommendations: MemoryRecommendation[];
  leakDetection: MemoryLeak[];
}

export interface VRAMUsage {
  total: number; // MB
  byMod: Map<string, number>;
  byAssetType: Map<string, number>; // textures, meshes, etc.
  peakUsage: number;
  averageUsage: number;
  trends: MemoryTrend[];
}

export interface RAMUsage {
  total: number; // MB
  byMod: Map<string, number>;
  byComponent: Map<string, number>; // scripts, assets, etc.
  peakUsage: number;
  averageUsage: number;
  trends: MemoryTrend[];
}

export interface MemoryTrend {
  timestamp: number;
  usage: number;
  context: string; // load order, specific mod, etc.
}

export interface MemoryPattern {
  type: 'allocation' | 'deallocation' | 'leak' | 'fragmentation';
  description: string;
  frequency: number;
  impact: number;
  affectedMods: string[];
}

export interface MemoryRecommendation {
  type: 'reduce' | 'optimize' | 'reorder' | 'patch';
  description: string;
  potentialSavings: number; // MB
  affectedMods: string[];
}

export interface MemoryLeak {
  modName: string;
  leakType: 'script' | 'asset' | 'resource';
  estimatedSize: number; // MB
  evidence: string[];
  confidence: number;
}

// Compatibility Matrix Mining Types
export interface CompatibilityMatrix {
  matrix: Map<string, Map<string, CompatibilityScore>>;
  clusters: CompatibilityCluster[];
  rules: CompatibilityRule[];
  lastUpdated: number;
  dataPoints: number;
}

export interface CompatibilityScore {
  score: number; // -1 (incompatible) to 1 (perfect)
  confidence: number;
  evidence: CompatibilityEvidence[];
  testedVersions: string[];
  lastTested: number;
}

export interface CompatibilityEvidence {
  type: 'user_report' | 'automated_test' | 'pattern_analysis' | 'historical';
  source: string;
  description: string;
  weight: number;
}

export interface CompatibilityCluster {
  id: string;
  mods: string[];
  compatibility: number; // Average compatibility within cluster
  description: string;
  recommended: boolean;
}

export interface CompatibilityRule {
  id: string;
  condition: string; // Logical condition for compatibility
  action: 'allow' | 'warn' | 'block';
  description: string;
  confidence: number;
  examples: string[];
}

// Cross-Reference Intelligence Types
export interface FormIDRelationshipMap {
  formId: string;
  references: FormIDReference[];
  conflicts: FormIDConflict[];
  dependencies: FormIDDependency[];
  modOwnership: string;
  recordType: string;
}

export interface FormIDReference {
  sourceFormId: string;
  targetFormId: string;
  referenceType: 'parent' | 'child' | 'sibling' | 'override' | 'merge';
  modName: string;
  confidence: number;
}

export interface FormIDConflict {
  conflictingMods: string[];
  conflictType: 'override' | 'duplicate' | 'missing_reference';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  resolution?: string;
}

export interface FormIDDependency {
  dependentFormId: string;
  dependencyFormId: string;
  dependencyType: 'required' | 'optional' | 'conditional';
  modName: string;
}

export interface CellModification {
  modName: string;
  timestamp: number;
  additions: CellAddition[];
  removals: CellRemoval[];
}

export interface CellAddition {
  objectType: string;
  formId: string;
  position: { x: number; y: number; z: number };
}

export interface CellRemoval {
  objectType: string;
  formId: string;
  reason: string;
}

export interface CellWorldspaceAnalysis {
  cellId: string;
  worldspaceId: string;
  mods: CellModInteraction[];
  modifications: CellModification[];
  conflicts: CellConflict[];
  optimizationOpportunities: CellOptimization[];
  performanceImpact: CellPerformanceImpact;
}

export interface CellModInteraction {
  modName: string;
  changes: CellChange[];
  additions: CellAddition[];
  removals: CellRemoval[];
  timestamp: number;
}

export interface CellChange {
  changeType: 'navmesh' | 'lighting' | 'placement' | 'landscape' | 'water';
  description: string;
  impact: 'low' | 'medium' | 'high';
}

export interface CellAddition {
  objectType: string;
  formId: string;
  position: { x: number; y: number; z: number };
  modName: string;
}

export interface CellRemoval {
  objectType: string;
  formId: string;
  reason: string;
  modName: string;
}

export interface CellConflict {
  conflictType: 'placement' | 'removal' | 'modification';
  severity: 'low' | 'medium' | 'high';
  mods: string[];
  description: string;
  cellId: string;
  position?: { x: number; y: number; z: number };
  objects?: Array<{ formId: string; objectType: string }>;
  affectedObjects?: string[];
  resolution?: string;
}

export interface CellOptimization {
  optimizationType: 'performance' | 'layout' | 'lod' | 'occlusion' | 'batching' | 'streaming';
  description: string;
  cellId?: string;
  suggestedActions?: string[];
  expectedImprovement?: {
    fps: number;
    memory: number;
    loadTime: number;
  };
  potentialGain?: number;
  difficulty?: 'easy' | 'medium' | 'hard';
}

export interface CellPerformanceImpact {
  fpsImpact: number;
  memoryImpact: number;
  loadTimeImpact: number;
  streamingImpact: number;
}

// ---------------------------------------------------------------------------------
// Cell / Worldspace editor runtime types (used by CellEditorEngine)
// ---------------------------------------------------------------------------------

export type CellType = 
  | 'interior'      // Interior cell
  | 'exterior'      // Worldspace exterior
  | 'public'        // Public space (inn, shop)
  | 'private'       // Private home
  | 'dungeon';      // Dungeon/cave

export interface Vector3 { x: number; y: number; z: number; }

export interface ReferenceFlags {
  persistent: boolean;
  disabled: boolean;
  initiallyDisabled: boolean;
  noRespawn: boolean;
  multibound: boolean;
}

export interface Reference {
  id: string;
  baseObject: string; // FormID of STAT/ACTI/NPC/etc
  position: Vector3;
  rotation: Vector3;
  scale: number;
  flags: ReferenceFlags;
  linkedRef?: string;
}

// RGB convenience type used across lighting and color APIs
export interface RGB { r: number; g: number; b: number }

export interface FogSettings {
  nearDistance: number;
  farDistance: number;
  power: number;
  color: RGB;
}

export interface LightingData {
  // Preferred shape (new)
  ambient?: RGB;
  directional?: RGB;
  fog?: FogSettings;
  imagespace?: string;

  // Backwards-compatible / legacy fields (kept optional)
  ambientColor?: { r: number; g: number; b: number };
  exposure?: number;
  timeOfDayLighting?: Record<string, any>;
  usesPrevis?: boolean;
}

export interface Cell {
  id: string;
  editorId: string;
  name: string;
  type: CellType;
  references: Reference[];
  lighting: LightingData;
  navmesh?: Navmesh;
  waterHeight?: number;
  acousticSpace?: string;
}

export interface SaveResult {
  success: boolean;
  warnings?: string[];
  error?: string;
}

export interface Worldspace {
  id: string;
  editorId?: string;
  name: string;
  // grid of cell id => `Cell`
  cells?: Record<string, Cell>;
  bounds?: { min: Vector3; max: Vector3 };
  heightMap?: HeightMap;
  lod?: LODData;
  metadata?: Record<string, any>;
}

export interface HeightMap {
  // New (multires) representation
  resolution?: number;
  heights?: number[][];       // 2D array [row][col]
  textureMap?: number[][];    // texture layer indices per cell

  // Legacy support
  width?: number;
  height?: number;
  data?: number[]; // row-major float heights
}

export interface NavmeshSettings {
  // tile/grid sizing
  cellSize?: number;
  cellHeight?: number;
  // agent configuration
  agentHeight?: number;
  agentRadius?: number;
  agentMaxClimb?: number;
  agentMaxSlope?: number;

  // legacy/compat
  cellId?: string;
  maxSlope?: number;
  stepHeight?: number;
}

// LOD (Level-of-detail) metadata for worldspace/cells
export interface LODData {
  level?: number;
  distance?: number;
  meshPath?: string;
  texturePath?: string;
  reductionFactor?: number;
}

export interface Triangle {
  a: Vector3;
  b: Vector3;
  c: Vector3;
  walkable?: boolean;
}

export interface NavTriangleFlags {
  preferred?: boolean;
  water?: boolean;
  door?: boolean;
  stairs?: boolean;
  jump?: boolean;
}

export interface NavTriangle {
  vertices: [number, number, number]; // indices into `Navmesh.vertices`
  flags: NavTriangleFlags;
  coverValue: number;
}

export interface NavEdge {
  triangle1: number;
  triangle2: number;
  doorReference?: string;
}

export interface CoverTriangle {
  navTriangle: number;
  coverType: 'high' | 'low' | 'left' | 'right';
  direction: Vector3;
}

export interface Navmesh {
  id: string;
  triangles: NavTriangle[];       // indexed triangles (indices into `vertices`)
  vertices: Vector3[];            // shared vertex pool
  edges: NavEdge[];               // connectivity / door links
  coverTriangles: CoverTriangle[];
  bounds?: { min: Vector3; max: Vector3 };
}

export interface LightSource {
  id?: string;
  type: 'point' | 'spot' | 'directional' | 'ambient' | 'hemisphere';
  color: RGB;
  intensity: number;
  // optional spatial properties
  position?: Vector3;
  radius?: number;
  castShadows?: boolean;
  // art/behavior helpers
  flickerEffect?: string;
}

export interface AOData {
  textureBase64?: string;
  samples?: number;
  resolution?: { width: number; height: number };
} 

export interface CollisionData {
  triangles: Triangle[];
  boundingBoxes?: Array<{ min: Vector3; max: Vector3 }>;
}

export interface OcclusionPlane {
  position: Vector3;
  normal: Vector3;
  width: number;
  height: number;
}

export interface OcclusionData {
  // support both legacy plane (normal + d) and new full plane description
  planes: OcclusionPlane[] | Array<{ normal: Vector3; d: number }>;
  generatedAt?: number;
}

export interface CombinedMesh {
  // raw mesh buffers (float32/uint32 arrays flattened)
  vertices?: number[];
  indices?: number[];
  uvs?: number[];
  normals?: number[];

  // metadata / legacy surface
  id?: string;
  vertexCount?: number;
  triangleCount?: number;
  boundingBox?: { min: Vector3; max: Vector3 };
  meshBlobPath?: string;
}

export interface QuestObjectiveAnalysis {
  questId: string;
  questName: string;
  objectives: AnalysisQuestObjective[];
  dependencies: QuestDependency[];
  conflicts: QuestConflict[];
  modInteractions: QuestModInteraction[];
}

export interface AnalysisQuestObjective {
  objectiveId: string;
  description: string;
  completionCriteria: string[];
  rewards: QuestReward[];
  dependencies: string[];
}

export interface QuestReward {
  type: 'item' | 'perk' | 'experience' | 'faction' | 'misc';
  formId?: string;
  amount?: number;
  description: string;
}

export interface QuestDependency {
  dependentQuest: string;
  dependencyQuest: string;
  dependencyType: 'required' | 'optional' | 'exclusive';
  modName: string;
}

export interface QuestConflict {
  conflictingQuests: string[];
  conflictType: 'objective' | 'reward' | 'timing' | 'completion';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  resolution?: string;
}

export interface QuestModInteraction {
  modName: string;
  changes: QuestChange[];
  additions: QuestAddition[];
  compatibility: 'compatible' | 'conflicts' | 'requires_patch';
  notes?: string;
}

export interface QuestChange {
  changeType: 'objective' | 'reward' | 'dialogue' | 'script';
  description: string;
  impact: 'low' | 'medium' | 'high';
}

export interface QuestAddition {
  additionType: 'quest' | 'objective' | 'dialogue' | 'item';
  formId: string;
  description: string;
}

export interface PerkPowerAnalysis {
  perkId: string;
  perkName: string;
  effects: PerkEffect[];
  interactions: PerkInteraction[];
  balanceIssues: BalanceIssue[];
  modModifications: PerkModification[];
}

export interface PerkEffect {
  effectType: 'stat' | 'ability' | 'resistance' | 'skill' | 'misc';
  target: string;
  magnitude: number;
  conditions?: string[];
  description: string;
}

export interface PerkInteraction {
  interactingPerk: string;
  interactionType: 'synergy' | 'conflict' | 'stacking' | 'override';
  description: string;
  impact: 'positive' | 'negative' | 'neutral';
  magnitude: number;
}

export interface BalanceIssue {
  issueType: 'overpowered' | 'underpowered' | 'imbalanced' | 'exploitable';
  description: string;
  severity: 'low' | 'medium' | 'high';
  affectedBuilds: string[];
  suggestedFix?: string;
}

export interface PerkModification {
  modName: string;
  changes: PerkChange[];
  additions: PerkAddition[];
  timestamp: number;
}

export interface PerkChange {
  changeType: 'effect' | 'requirement' | 'description' | 'icon';
  oldValue: any;
  newValue: any;
  reason: string;
}

export interface PerkAddition {
  additionType: 'perk' | 'rank' | 'effect';
  formId: string;
  description: string;
}

// Cross-Reference Mining Engines
export interface FormIDRelationshipMiningEngine {
  analyze: (espFiles: ESPFile[]) => Promise<FormIDRelationshipMap[]>;
  findConflicts: (formIdMaps: FormIDRelationshipMap[]) => Promise<FormIDConflict[]>;
  buildDependencyGraph: (formIdMaps: FormIDRelationshipMap[]) => Promise<FormIDDependencyGraph>;
}

export interface CellWorldspaceMiningEngine {
  analyze: (espFiles: ESPFile[], worldspaceData: any[]) => Promise<CellWorldspaceAnalysis[]>;
  detectConflicts: (cellAnalyses: CellWorldspaceAnalysis[]) => Promise<CellConflict[]>;
  optimizeLayout: (cellAnalyses: CellWorldspaceAnalysis[]) => Promise<CellOptimization[]>;
}

export interface QuestObjectiveMiningEngine {
  analyze: (espFiles: ESPFile[]) => Promise<QuestObjectiveAnalysis[]>;
  detectConflicts: (questAnalyses: QuestObjectiveAnalysis[]) => Promise<QuestConflict[]>;
  buildDependencyGraph: (questAnalyses: QuestObjectiveAnalysis[]) => Promise<QuestDependencyGraph>;
}

export interface PerkPowerMiningEngine {
  analyze: (espFiles: ESPFile[]) => Promise<PerkPowerAnalysis[]>;
  detectInteractions: (perkAnalyses: PerkPowerAnalysis[]) => Promise<PerkInteraction[]>;
  balanceAnalysis: (perkAnalyses: PerkPowerAnalysis[]) => Promise<BalanceIssue[]>;
}

// Additional supporting types
export interface FormIDDependencyGraph {
  nodes: FormIDNode[];
  edges: FormIDEdge[];
  cycles: FormIDCycle[];
  isolatedNodes: string[];
}

export interface FormIDNode {
  formId: string;
  modName: string;
  recordType: string;
  referenceCount: number;
}

export interface FormIDEdge {
  source: string;
  target: string;
  edgeType: 'references' | 'depends_on' | 'conflicts_with';
  weight: number;
}

export interface FormIDCycle {
  nodes: string[];
  description: string;
  severity: 'low' | 'medium' | 'high';
}

export interface QuestDependencyGraph {
  nodes: QuestNode[];
  edges: QuestEdge[];
  cycles: QuestCycle[];
  completionPaths: QuestPath[];
}

export interface QuestNode {
  questId: string;
  questName: string;
  modName: string;
  objectiveCount: number;
}

export interface QuestEdge {
  source: string;
  target: string;
  edgeType: 'requires' | 'blocks' | 'enables' | 'conflicts';
  weight: number;
}

export interface QuestCycle {
  nodes: string[];
  description: string;
  breakable: boolean;
}

export interface QuestPath {
  quests: string[];
  totalObjectives: number;
  estimatedTime: number;
  difficulty: 'easy' | 'medium' | 'hard';
}

// Advanced Analysis Engine
export interface AdvancedAnalysisEngine {
  patternRecognition: PatternRecognitionEngine;
  conflictPrediction: ConflictPredictionEngine;
  bottleneckMining: BottleneckMiningEngine;
  memoryAnalysis: MemoryAnalysisEngine;
  compatibilityMining: CompatibilityMiningEngine;
  formIdRelationshipMining: FormIDRelationshipMiningEngine;
  cellWorldspaceMining: CellWorldspaceMiningEngine;
  questObjectiveMining: QuestObjectiveMiningEngine;
  perkPowerMining: PerkPowerMiningEngine;
  runComprehensiveAnalysis(data: AnalysisData): Promise<{
    patterns: PatternRecognitionResult;
    bottlenecks: BottleneckAnalysis;
    memory: MemoryAnalysis;
    compatibilityMatrix: CompatibilityMatrix;
  }>;
}

export interface PatternRecognitionEngine {
  analyze: (data: AnalysisData) => Promise<PatternRecognitionResult>;
  train: (historicalData: HistoricalData[]) => Promise<void>;
  getPatterns: () => Promise<DetectedPattern[]>;
}

export interface ConflictPredictionEngine {
  predict: (modA: string, modB: string) => Promise<ConflictPrediction>;
  train: (conflictData: ConflictTrainingData[]) => Promise<void>;
  getModelStatus: () => Promise<ConflictPredictionModel>;
}

export interface ConflictPredictionModel {
  trained: boolean;
  lastTrained: number;
  accuracy: number;
  featureCount: number;
  trainingDataSize: number;
}

export interface BottleneckMiningEngine {
  analyze: (performanceData: PerformanceData) => Promise<BottleneckAnalysis>;
  identify: (metrics: PerformanceMetric[]) => Promise<PerformanceBottleneck[]>;
}

export interface MemoryAnalysisEngine {
  analyze: (memoryData: MemoryData) => Promise<MemoryAnalysis>;
  track: (sessionData: SessionData) => Promise<MemoryTrend[]>;
}

export interface CompatibilityMiningEngine {
  build: (compatibilityData: CompatibilityData[]) => Promise<CompatibilityMatrix>;
  query: (modA: string, modB: string) => Promise<CompatibilityScore>;
  update: (newData: CompatibilityData) => Promise<void>;
}

// Data structures for analysis
export interface AnalysisData {
  mods: string[];
  performanceMetrics: PerformanceMetric[];
  conflicts: ModConflict[];
  loadOrder: string[];
  systemInfo: HardwareProfile;
}

export interface HistoricalData {
  timestamp: number;
  mods: string[];
  outcome: 'success' | 'failure' | 'warning';
  fps?: number;
  memoryUsage?: number;
  loadTime?: number;
  metrics?: PerformanceMetric;
  conflicts?: ModConflict[];
}

export interface PerformanceData {
  metrics: PerformanceMetric[];
  systemInfo: HardwareProfile;
  loadOrder: string[];
  sessionDuration: number;
}

export interface MemoryData {
  vramSnapshots: MemorySnapshot[];
  ramSnapshots: MemorySnapshot[];
  modLoadOrder: string[];
  sessionInfo: SessionData;
}

export interface MemorySnapshot {
  timestamp: number;
  usage: number;
  byComponent: Map<string, number>;
}

export interface SessionData {
  startTime: number;
  endTime: number;
  mods: string[];
  peakVRAM: number;
  peakRAM: number;
  averageFPS: number;
}

export interface CompatibilityData {
  modA: string;
  modB: string;
  compatible: boolean;
  issues?: string[];
  testedBy: string;
  timestamp: number;
  versions: { modA: string; modB: string };
}

// Data Pipeline Types
export interface DataSource {
  type: 'esp' | 'nif' | 'dds' | 'hkx' | 'log' | 'config' | 'benchmark' | 'bsa';
  path: string;
  priority: number;
  lastProcessed?: number;
  checksum?: string;
}

export interface MiningPipeline {
  sources: DataSource[];
  processors: DataProcessor[];
  correlators: AssetCorrelator[];
  analyzers: PerformanceAnalyzer[];
  output: MiningResult;
}

export interface DataProcessor {
  name: string;
  process: (data: any) => Promise<any>;
  supportedTypes: string[];
}

export interface AssetCorrelator {
  correlate: (assets: AssetReference[]) => Promise<AssetCorrelation[]>;
  supportedTypes: string[];
}

export interface PerformanceAnalyzer {
  analyze: (metrics: PerformanceMetric[]) => Promise<PerformanceReport>;
  supportedMetrics: string[];
}

export interface MiningResult {
  espData: Map<string, ESPFile>;
  correlations: AssetCorrelation[];
  dependencyGraph: ModDependencyGraph;
  performanceReport: PerformanceReport;
  processedAt: number;
  errors: string[];
  engine?: string; // Engine that produced this result
  timestamp?: Date; // When the result was generated
}

export interface MiningEngine {
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<MiningResult>;
}

export interface Phase1MiningEngine {
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<Phase1MiningResult>;
}

export interface Phase1MiningResult {
  engine: string;
  timestamp: Date;
  data: any;
  metadata: any;
}

export interface Phase1AssetCorrelation {
  assetId: string;
  correlatedAssets: string[];
  correlationStrength: number;
  correlationType: string;
  metadata?: any;
}

// Phase 2: Advanced ML-based Mining Engines

export interface Phase2MiningEngine {
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<Phase2MiningResult>;
}

export interface Phase2MiningResult {
  engine: string;
  timestampNum: number;
  predictions: any[];
  insights: any[];
  recommendations: any[];
  resultMetadata: Record<string, any>;
}

// ML-based Conflict Prediction Engine
export interface MLConflictPredictionEngine extends Phase2MiningEngine {
  predictConflicts(modCombination: string[]): Promise<ConflictPrediction[]>;
  trainModel(trainingData: ConflictTrainingData[]): Promise<void>;
  getModelAccuracy(): Promise<ModelMetrics>;
  updateWithFeedback(feedback: ConflictFeedback[]): Promise<void>;
}

export interface ConflictPrediction {
  modA: string;
  modB: string;
  probability: number; // 0-1
  conflictTypes: string[];
  severity: 'low' | 'medium' | 'high' | 'critical';
  evidence: ConflictEvidence[];
  mitigationStrategies: string[];
  confidence: number;
}

export interface ConflictEvidence {
  type: 'historical' | 'pattern' | 'similarity' | 'rule_based' | 'ml_prediction';
  description: string;
  weight: number;
  source?: string;
}

export interface ConflictTrainingData {
  modA: string;
  modB: string;
  actualConflict: boolean;
  conflictType?: string;
  severity?: number;
  context: {
    gameVersion: string;
    modVersions: { [modName: string]: string };
    hardwareProfile: HardwareProfile;
    loadOrder: string[];
  };
}

export interface ConflictFeedback {
  predictionId: string;
  actualOutcome: boolean;
  userRating: number; // 1-5, how accurate was the prediction
  comments?: string;
}

export interface ModelMetrics {
  accuracy: number;
  precision: number;
  recall: number;
  f1Score: number;
  trainingDataSize: number;
  lastTrained: number;
  featureImportance: { [feature: string]: number };
}

// Performance Bottleneck Detection Engine
export interface PerformanceBottleneckEngine extends Phase2MiningEngine {
  analyzeBottlenecks(performanceData: PerformanceData): Promise<BottleneckAnalysis>;
  predictPerformanceImpact(modChanges: ModChange[]): Promise<PerformancePrediction[]>;
  identifyOptimizationOpportunities(systemProfile: HardwareProfile): Promise<OptimizationRecommendation[]>;
  monitorRealTimePerformance(): Promise<RealtimeMetrics>;
}

export interface BottleneckAnalysis {
  primaryBottlenecks: Phase2PerformanceBottleneck[];
  secondaryBottlenecks: Phase2PerformanceBottleneck[];
  criticalPath: string[]; // Mods causing the most performance impact
  systemLimitations: Phase2SystemLimitation[];
  optimizationOpportunities: OptimizationRecommendation[];
  confidence: number;
}

export interface Phase2PerformanceBottleneck {
  type: 'cpu' | 'gpu' | 'memory' | 'io' | 'script' | 'asset_loading';
  severity: 'low' | 'medium' | 'high' | 'critical';
  impact: {
    fps: number;
    memory: number;
    loadTime: number;
  };
  affectedMods: string[];
  rootCause: string;
  mitigationStrategies: MitigationStrategy[];
  evidence: Phase2BottleneckEvidence[];
}

export interface Phase2BottleneckEvidence {
  metric: string;
  observedValue: number;
  expectedValue: number;
  deviation: number;
  confidence: number;
}

export interface MitigationStrategy {
  type: 'disable' | 'reorder' | 'patch' | 'optimize' | 'alternative';
  description: string;
  difficulty: 'easy' | 'medium' | 'hard';
  expectedImprovement: {
    fps: number;
    memory: number;
    loadTime: number;
  };
  affectedMods: string[];
}

export interface PerformancePrediction {
  modChange: ModChange;
  predictedImpact: {
    fps: number;
    memory: number;
    loadTime: number;
  };
  confidence: number;
  riskLevel: 'low' | 'medium' | 'high';
  recommendations: string[];
}

export interface ModChange {
  type: 'add' | 'remove' | 'update' | 'reorder';
  modName: string;
  fromVersion?: string;
  toVersion?: string;
  newPosition?: number;
}

export interface OptimizationRecommendation {
  type: 'texture' | 'mesh' | 'script' | 'config' | 'load_order' | 'hardware';
  description: string;
  potentialGain: {
    fps: number;
    memory: number;
    loadTime: number;
  };
  difficulty: 'easy' | 'medium' | 'hard';
  prerequisites: string[];
  affectedMods: string[];
}

export interface RealtimeMetrics {
  currentFPS: number;
  memoryUsage: number;
  cpuUsage: number;
  gpuUsage: number;
  activeMods: string[];
  bottleneckIndicators: BottleneckIndicator[];
  timestamp: number;
}

export interface BottleneckIndicator {
  component: 'cpu' | 'gpu' | 'memory' | 'disk';
  utilization: number;
  threshold: number;
  isBottleneck: boolean;
}

export interface Phase2SystemLimitation {
  component: any;
  currentCapacity: number;
  recommendedMinimum: number;
  isLimiting: boolean;
  upgradeSuggestions: string[];
}

// Hardware-Aware Mining Engine
export interface HardwareAwareMiningEngine extends Phase2MiningEngine {
  analyzeHardwareCompatibility(mods: string[]): Promise<HardwareCompatibility[]>;
  generateHardwareSpecificRecommendations(profile: HardwareProfile): Promise<HardwareRecommendation[]>;
  predictPerformanceForHardware(mods: string[], targetHardware: HardwareProfile): Promise<HardwarePerformancePrediction>;
  optimizeForHardware(mods: string[], hardwareProfile: HardwareProfile): Promise<HardwareOptimization[]>;
}

export interface HardwareCompatibility {
  modName: string;
  compatibility: {
    cpu: number; // 0-1 compatibility score
    gpu: number;
    ram: number;
    storage: number;
  };
  requirements: HardwareRequirements;
  recommendations: string[];
  warnings: string[];
}

export interface HardwareRequirements {
  minimum: HardwareProfile;
  recommended: HardwareProfile;
  estimatedPerformance: {
    minSpecFPS: number;
    recSpecFPS: number;
  };
}

export interface HardwareRecommendation {
  type: 'upgrade' | 'downgrade' | 'alternative' | 'optimization';
  component: 'cpu' | 'gpu' | 'ram' | 'storage';
  description: string;
  priority: 'low' | 'medium' | 'high';
  costEstimate?: number;
  performanceGain: number;
  affectedMods: string[];
}

export interface HardwarePerformancePrediction {
  baselinePerformance: PerformanceMetric;
  predictedPerformance: PerformanceMetric;
  confidence: number;
  limitingFactors: string[];
  optimizationSuggestions: HardwareOptimization[];
}

export interface HardwareOptimization {
  type: 'texture_resolution' | 'mesh_lod' | 'shadow_quality' | 'draw_distance' | 'anti_aliasing';
  description: string;
  currentSetting: any;
  recommendedSetting: any;
  performanceImpact: {
    fps: number;
    quality: number;
  };
  compatibility: string[]; // Affected mods
}

// Longitudinal Mining Engine
export interface LongitudinalMiningEngine extends Phase2MiningEngine {
  trackPerformanceOverTime(sessionData: SessionData[]): Promise<PerformanceTrend[]>;
  detectPerformanceDegradation(trends: PerformanceTrend[]): Promise<DegradationAlert[]>;
  predictFuturePerformance(currentMods: string[], futureChanges: ModChange[]): Promise<FuturePerformancePrediction>;
  analyzeModUpdateImpact(updates: ModUpdate[]): Promise<UpdateImpactAnalysis[]>;
}

export interface PerformanceTrend {
  modCombination: string[];
  timeRange: {
    start: number;
    end: number;
  };
  metrics: {
    fps: TrendData;
    memory: TrendData;
    loadTime: TrendData;
    stability: TrendData;
  };
  significantChanges: PerformanceChange[];
  overallTrend: 'improving' | 'stable' | 'degrading';
}

export interface TrendData {
  values: number[];
  timestamps: number[];
  average: number;
  min: number;
  max: number;
  standardDeviation: number;
  trend: 'increasing' | 'decreasing' | 'stable';
  slope: number; // Rate of change
}

export interface PerformanceChange {
  timestamp: number;
  changeType: 'improvement' | 'degradation' | 'fluctuation';
  magnitude: number;
  cause: string;
  confidence: number;
}

export interface DegradationAlert {
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  affectedMods: string[];
  rootCause: string;
  mitigationSteps: string[];
  predictedImpact: {
    fps: number;
    memory: number;
    stability: number;
  };
  timeframe: string; // When the degradation was detected
}

export interface FuturePerformancePrediction {
  timeHorizon: number; // Days into the future
  predictedMetrics: PerformanceMetric;
  confidence: number;
  riskFactors: string[];
  recommendedActions: string[];
}

export interface ModUpdate {
  modName: string;
  fromVersion: string;
  toVersion: string;
  updateType: 'patch' | 'major' | 'minor';
  changelog?: string;
  timestamp: number;
}

export interface UpdateImpactAnalysis {
  modName: string;
  update: ModUpdate;
  performanceImpact: {
    fps: number;
    memory: number;
    loadTime: number;
  };
  compatibilityChanges: string[];
  riskLevel: 'low' | 'medium' | 'high';
  recommendations: string[];
  rollbackAdvice?: string;
}

export interface SessionData {
  sessionId: string;
  startTime: number;
  endTime: number;
  mods: string[];
  initialLoadOrder: string[];
  finalLoadOrder: string[];
  performanceSnapshots: PerformanceSnapshot[];
  events: SessionEvent[];
  userActions: UserAction[];
}

export interface PerformanceSnapshot {
  timestamp: number;
  fps: number;
  memoryUsage: number;
  cpuUsage: number;
  gpuUsage: number;
  activeMods: number;
}

export interface SessionEvent {
  timestamp: number;
  type: 'mod_loaded' | 'mod_unloaded' | 'crash' | 'save' | 'load' | 'setting_changed';
  details: any;
}

export interface UserAction {
  timestamp: number;
  action: 'enable_mod' | 'disable_mod' | 'reorder_mods' | 'change_setting' | 'install_mod' | 'uninstall_mod';
  details: any;
}

// Contextual Mining Engine
export interface ContextualMiningEngine extends Phase2MiningEngine {
  analyzeUserPreferences(userProfile?: UserProfile): Promise<any>;
  understandModdingGoals(mods?: string[], userHistory?: UserHistory): Promise<ModdingGoal[]>;
  generatePersonalizedRecommendations(userContext?: any): Promise<any[]>;
  adaptToUserBehavior(behaviorPatterns?: BehaviorPattern[]): Promise<AdaptationStrategy[]>;
}

export interface UserProfile {
  userId: string;
  preferences: {
    performancePriority: any; // 0-10, how much they care about FPS
    visualQualityPriority: any; // 0-10, how much they care about graphics
    stabilityPriority: any; // 0-10, how much they care about crashes
    moddingExperience?: any;
    playstyle?: any;
    hardwareBudget?: any;
    visualQuality?: any;
    modCategories?: any;
    complexityTolerance?: any;
    automationPreference?: any;
    learningStyle?: any;
    moddingStyle?: any;
    contentPreferences?: any;
    technicalProficiency?: any;
  };
  behaviorPatterns?: BehaviorPattern[];
  modPreferences?: any;
  settingPreferences?: any;
  contextualPatterns?: any;
  performanceTolerance?: {
    minFPS: number;
    maxMemoryUsage: number;
    acceptableLoadTime: number;
  };
  lastUpdated: number;
  learningProgress: {
    interactionsProcessed: number;
    feedbackIncorporated: number;
    patternsLearned: number;
    adaptationCycles: number;
  };
  hardwareProfile?: HardwareProfile;
  modLibrary?: string[];
  favoriteMods?: string[];
  avoidedMods?: string[];
  commonIssues?: string[];
  created?: number;
  userGoals?: any[];
}

export interface UserInsights {
  performanceTolerance: {
    minAcceptableFPS: number;
    maxAcceptableLoadTime: number;
    memoryLimit: number;
  };
  qualityPreferences: {
    textureResolution: 'low' | 'medium' | 'high' | 'ultra';
    meshQuality: 'low' | 'medium' | 'high' | 'ultra';
    shadowQuality: 'off' | 'low' | 'medium' | 'high' | 'ultra';
    effectQuality: 'low' | 'medium' | 'high';
  };
  riskTolerance: 'conservative' | 'moderate' | 'aggressive';
  learningStyle: 'cautious' | 'experimental' | 'methodical';
}

export interface ModdingGoal {
  goalType: 'performance' | 'visual' | 'content' | 'compatibility' | 'stability';
  priority: number; // 0-10
  description: string;
  targetMods: string[];
  constraints: string[];
  successCriteria: string[];
  estimatedDifficulty: 'easy' | 'medium' | 'hard';
}

export interface UserContext {
  currentMods: string[];
  recentChanges: ModChange[];
  performanceHistory: PerformanceTrend[];
  reportedIssues: string[];
  userGoals: ModdingGoal[];
  timeConstraints: {
    availableTime: number; // Hours per week for modding
    patienceLevel: 'low' | 'medium' | 'high';
  };
  technicalComfort: 'beginner' | 'intermediate' | 'advanced';
  action?: any;
  details?: any;
}

export interface PersonalizedRecommendation {
  type: any;
  priority?: any;
  description?: string;
  rationale?: any;
  relevance: number;
  confidence: number;
  action?: string;
  id?: string;
  expectedBenefit?: any;
  implementationDifficulty?: any;
  prerequisites?: string[];
  item?: string;
  reasoning?: string[];
  contextRelevance?: number;
  expectedImpact?: any;
}

export interface UserInteraction {
  type: any;
  modName?: string;
  context: any;
  outcome: {
    success?: boolean;
    error?: string;
    performance?: number;
    satisfaction?: number;
    issues?: string[];
  };
  timestamp: number;
  settingName?: string;
  value?: any;
  rating?: number;
}

export interface UserFeedback {
  id?: string;
  rating: number;
  comments?: string;
  recommendationId?: string;
  timestamp: number;
  accepted?: boolean;
  context?: any;
  outcome?: {
    performance?: number;
    satisfaction?: number;
    issues?: string[];
  };
}

export interface SessionContext {
  gameMode?: string;
  systemResourceState?: string;
  activeMods?: string[];
  difficulty?: string;
  hardwareProfile?: any;
  performanceMetrics?: any;
  userPreferences?: any;
}

export interface ContextTransition {
  from: any;
  to: any;
  timestamp: number;
  reason?: string;
  impact?: any;
}

export interface TransitionAnalysis {
  frequency?: number;
  commonPaths?: string[][];
  averageDuration?: number;
  commonTransitions?: ContextTransition[];
  transitionPatterns?: Record<string, number>;
  adaptationStrategies?: any[];
  effectiveness?: number;
}

export interface UserHistory {
  sessions: SessionData[];
  interactions?: UserInteraction[];
  lastActive: number;
}

export interface ModdingGoal {
  title: string;
  target: string;
  requirements: string[];
  currentProgress: number;
}

export interface AdaptationStrategy {
  id: string;
  name?: string;
  strategyType?: any;
  type?: any;
  description: string;
  action?: string;
  trigger?: string;
  isApplied?: boolean;
  appliedAt?: number;
  isActive?: boolean;
  adjustmentFactor: number;
  effectiveness: number;
  conditions?: any;
  actions?: string[];
  implementation?: string[];
  lastUsed?: number;
  successRate?: number;
  expectedImprovement?: number;
  userAcceptance?: number;
  triggerCondition?: any;
  lastAdapted?: number;
}

export type AdaptiveStrategy = AdaptationStrategy;

export interface UserInsights {
  primaryGoal: string;
  preferences: Record<string, any>;
  commonProblems: string[];
  suggestedPath: string;
}

export interface BehaviorPattern {
  id?: string;
  type?: string;
  patternType?: any;
  pattern: string;
  frequency: number;
  successRate: number;
  preferredApproaches?: string[];
  avoidedApproaches?: string[];
  learningProgression?: string[];
  lastObserved: number;
  contexts: any[];
  confidence: number;
  insights?: any[];
}

export interface UserHistory {
  sessions: SessionData[];
  interactions?: UserInteraction[];
  modInstallations?: ModInstallation[];
  issueReports?: IssueReport[];
  settingChanges?: SettingChange[];
  performanceMeasurements?: PerformanceMeasurement[];
  lastActive: number;
}

export interface ModInstallation {
  modName: string;
  version: string;
  timestamp: number;
  source: string;
  reason: string;
  outcome: 'success' | 'failure' | 'partial';
}

export interface IssueReport {
  timestamp: number;
  issueType: 'crash' | 'performance' | 'compatibility' | 'visual' | 'other';
  description: string;
  affectedMods: string[];
  resolution?: string;
  userRating?: number;
}

export interface SettingChange {
  timestamp: number;
  setting: string;
  oldValue: any;
  newValue: any;
  reason: string;
  outcome: 'positive' | 'negative' | 'neutral';
}

export interface PerformanceMeasurement {
  timestamp: number;
  mods: string[];
  metrics: PerformanceMetric;
  context: string;
  userSatisfaction: number; // 1-10
}

export interface MiningStatus {
  active: boolean;
  progress: number;
  currentTask?: string;
  engineType: string;
  engine?: string; // Engine identifier
  startTime?: number;
  lastUpdate?: number;
}

// Intelligent Asset Discovery Types

// BSA Archive Structures
export interface BSAFileEntry {
  filename: string;
  size: number;
  offset: number;
  compressed: boolean;
}

export interface BSADirectory {
  name: string;
  files: BSAFileEntry[];
}

export interface BSAArchive {
  path: string;
  version: number;
  directories: BSADirectory[];
  totalFiles: number;
  totalSizeCompressed: number;
  totalSizeUncompressed: number;
}

// Unused Asset Detection
export interface UnusedAsset {
  path: string;
  type: 'texture' | 'model' | 'animation' | 'sound' | 'other';
  size: number;
  archive?: string; // BSA archive containing this asset
  reason: 'orphaned' | 'duplicate' | 'low_usage';
  potentialSavings: number; // Bytes that could be saved by removal
}

export interface UnusedAssetReport {
  totalAssets: number;
  unusedAssets: UnusedAsset[];
  potentialSpaceSavings: number;
  recommendations: string[];
}

// LOD Optimization Mining
export interface LODMeshInfo {
  path: string;
  lodLevel: number; // 0 = highest detail, higher numbers = lower detail
  triangleCount: number;
  vertexCount: number;
  texturePath?: string;
  distanceThreshold: number;
}

export interface LODOptimization {
  meshPath: string;
  currentLODs: LODMeshInfo[];
  recommendedLODs: LODMeshInfo[];
  issues: string[];
  suggestions: string[];
  potentialSavings: {
    triangles: number;
    vertices: number;
    textureMemory: number;
  };
}

export interface LODReport {
  totalMeshes: number;
  optimizedMeshes: LODOptimization[];
  recommendations: string[];
}

// Texture Resolution Mining
export interface TextureInfo {
  path: string;
  width: number;
  height: number;
  format: string;
  mipmaps: number;
  size: number;
  usage: 'diffuse' | 'normal' | 'specular' | 'other';
  distanceUsage: 'close' | 'medium' | 'far' | 'background';
}

export interface TextureUpscaleOpportunity {
  texture: TextureInfo;
  recommendedResolution: { width: number; height: number };
  qualityImprovement: number; // 0-100
  performanceImpact: number; // Additional VRAM usage in MB
  priority: 'high' | 'medium' | 'low';
  reason: string;
}

export interface TextureResolutionReport {
  totalTextures: number;
  lowResTextures: TextureUpscaleOpportunity[];
  recommendations: string[];
  potentialQualityImprovement: number;
}

// Animation Frame Mining
export interface AnimationKeyframe {
  time: number;
  position?: { x: number; y: number; z: number };
  rotation?: { x: number; y: number; z: number; w: number };
  scale?: { x: number; y: number; z: number };
}

export interface AnimationInfo {
  path: string;
  duration: number;
  frameRate: number;
  keyframeCount: number;
  boneCount: number;
  keyframes: AnimationKeyframe[];
  compressionRatio: number; // Current compression level
}

export interface AnimationOptimization {
  animation: AnimationInfo;
  recommendedFrameRate: number;
  recommendedKeyframeReduction: number;
  potentialSavings: {
    fileSize: number;
    memory: number;
    cpu: number; // Estimated CPU cycles saved
  };
  qualityImpact: number; // 0-100, higher = better quality preserved
  suggestions: string[];
}

export interface AnimationReport {
  totalAnimations: number;
  optimizableAnimations: AnimationOptimization[];
  recommendations: string[];
  potentialSavings: {
    totalFileSize: number;
    totalMemory: number;
    totalCPU: number;
  };
}

// Asset Discovery Analyzers
export interface UnusedAssetDetector {
  scan: (bsaArchives: BSAArchive[], espFiles: ESPFile[]) => Promise<UnusedAssetReport>;
  supportedTypes: string[];
}

export interface LODOptimizer {
  analyze: (lodMeshes: LODMeshInfo[]) => Promise<LODOptimization[]>;
  supportedTypes: string[];
}

export interface TextureResolutionAnalyzer {
  analyze: (textures: TextureInfo[]) => Promise<TextureResolutionReport>;
  supportedTypes: string[];
}

export interface AnimationFrameAnalyzer {
  analyze: (animations: AnimationInfo[]) => Promise<AnimationReport>;
  supportedTypes: string[];
}

// Extended Mining Result
export interface ExtendedMiningResult extends MiningResult {
  assetDiscovery: {
    unusedAssets: UnusedAssetReport;
    lodOptimizations: LODReport;
    textureResolutions: TextureResolutionReport;
    animationOptimizations: AnimationReport;
  };
}

// -----------------------------
// AI Assistant - shared types
// -----------------------------

export interface ScriptGenerationRequest {
  description: string;
  language?: string;
  context?: any;
  style?: string;
  options?: any;
}
export interface ScriptGenerationResult { success: boolean; scripts?: any[]; timestamp?: number; confidence?: number; error?: string }

export interface AssetNamingRequest { type: string; description?: string; count?: number; enforceLdFormat?: boolean; context?: any; currentName?: string; }
export interface AssetNamingResult { success?: boolean; suggestions?: any[]; recommended?: { name: string; explanation?: string; score?: number }; confidence?: number; timestamp?: number; error?: string }
export interface BatchAssetNaming { files: Array<{ path: string; type?: string; currentName?: string }>; pattern?: string; options?: any; enforceStandards?: boolean; strategy?: string }
export interface BatchNamingResult { success?: boolean; renamedAssets?: Array<{ oldName: string; newName: string; reason?: string }>; skippedAssets?: any[]; appliedStandards?: string[]; timestamp?: number; error?: string }

export interface WorkflowRequest { goal: string; description?: string; skillLevel?: 'beginner'|'intermediate'|'advanced'; constraints?: string[]; tools?: string[]; timeEstimate?: string | number }
export interface WorkflowResult { success: boolean; plan?: any; confidence?: number; timestamp?: number; error?: string }

export interface DocumentationRequest {
  type: 'readme' | 'guide' | 'api' | 'tutorial';
  // documentation payload may be a structured object (project metadata, sections)
  content?: any;
  style?: string;
  targetAudience?: string;
  metadata?: any;
}
export interface DocumentationResult { success: boolean; documentation?: any; confidence?: number; timestamp?: number; error?: string }

// --- Documentation generation domain models ---
export interface ProjectData {
  id?: string;
  name: string;
  version?: string;
  description?: string;
  authors?: string[];
  license?: string;
  repository?: string;
  files?: string[];
  metadata?: Record<string, any>;
}

export interface ProjectDocumentation {
  readme: string;
  changelog: string;
  installation: InstallGuide;
  apiReference?: APIDocumentation;
  assetCatalog: AssetDocumentation;
  troubleshooting: TroubleshootingGuide;
  credits: Credits;
}

export interface GitCommit { sha: string; author: string; date: number; message: string; filesChanged?: string[] }

// --- API documentation model ---
export interface ParameterDoc { name: string; type?: string; description?: string }
export interface CodeExample { title?: string; code: string; language: string; description?: string }
export interface FunctionDoc {
  name: string;
  signature: string;
  description?: string;
  parameters?: ParameterDoc[];
  returnType?: string;
  returnDescription?: string;
  examples?: CodeExample[];
  seeAlso?: string[];
}
export interface ClassDoc { name: string; description?: string; methods?: FunctionDoc[]; properties?: PropertyDoc[] }
export interface PropertyDoc { name: string; type?: string; description?: string }
export interface EventDoc { name: string; description?: string; payload?: string }

export interface APIDocumentation {
  functions: FunctionDoc[];
  classes: ClassDoc[];
  properties: PropertyDoc[];
  events: EventDoc[];
}

export interface DocComment { filePath: string; line: number; content: string; tags?: Record<string, string | string[]> }
export interface FunctionReference { functions: FunctionDoc[]; index?: Record<string, number> }

// --- Asset documentation model ---
export interface AssetEntry {
  path: string;
  type: string;
  size: number;
  usedBy: string[]; // References
  description?: string;
  tags: string[];
}
export interface AssetStatistics {
  totalAssets: number;
  byType: Record<string, number>;
  totalSize: number;
  largestAssets: AssetEntry[];
}
export interface AssetDocumentation {
  meshes: AssetEntry[];
  textures: AssetEntry[];
  sounds: AssetEntry[];
  misc: AssetEntry[];
  statistics: AssetStatistics;
}

// Troubleshooting and credits
export interface TroubleshootingEntry { problem: string; cause: string; solution: string; seeAlso?: string[] }
export interface TroubleshootingGuide { entries: TroubleshootingEntry[]; lastUpdated?: number }

export interface Contributor { name: string; role?: string; contributions?: string[] }
export interface AssetCredit { asset: string; creator: string; license: string; url?: string }
export interface Credits { author: string; contributors: Contributor[]; specialThanks: string[]; toolsUsed: string[]; assets: AssetCredit[] }


export interface ItemEntry { editorId: string; name: string; formId: string; type: string; value: number; weight: number; description?: string; location?: string }
export interface ItemCatalog { weapons: ItemEntry[]; armor: ItemEntry[]; consumables: ItemEntry[]; misc: ItemEntry[] }

export interface StageEntry { index: number; description: string; objectives: string[] }
export interface QuestEntry { name: string; type: string; stages: StageEntry[]; rewards: string[]; location: string; requirements: string[] }
export interface QuestGuide { quests: QuestEntry[] }

export interface TutorialStep {
  id: string;
  title: string;
  content: string; // Markdown
  type: 'reading' | 'video' | 'exercise' | 'quiz';
  code?: string;
  exercise?: Exercise;
  estimatedTime: number; // minutes
}

export interface Tutorial {
  id: string;
  title: string;
  description: string;
  category: 'beginner' | 'intermediate' | 'advanced';
  difficulty: number; // 1-10
  duration: number; // minutes
  steps: TutorialStep[];
  prerequisites: string[];
  tags: string[];
  videoUrl?: string;
}

// Convenience DTO for creating/updating tutorials (partial fields allowed)
export interface TutorialData extends Partial<Tutorial> {
  id?: string;
  title: string;
  steps: TutorialStep[];
}

export interface Exercise {
  id: string;
  prompt: string;
  type: 'code' | 'multiple-choice' | 'fill-blank' | 'practical';
  expectedOutput?: any;
  hints: string[];
  solution?: string;
}

export interface StepProgressEntry { tutorialId: string; stepId: string; completedAt: number }

// New canonical user progress model (LearningProgress kept as alias for compatibility)
export interface UserProgress {
  userId: string;
  completedTutorials: string[];
  currentTutorials: CurrentTutorial[];
  achievements: string[];
  totalPoints: number;
  level: number;
}

export type LearningProgress = UserProgress;

export interface CurrentTutorial {
  tutorialId: string;
  currentStep: number;
  startedAt: number;
  lastAccessed: number;
}

export interface StepCompletion { userId: string; stepId: string; completedAt: number; success: boolean; xpEarned?: number }
export interface ValidationResult { success: boolean; score?: number; feedback?: string }
export interface Hint { text: string; hintLevel?: number }

export interface Achievement {
  id: string;
  name: string;
  description: string;
  icon: string;
  points: number;
  unlockedAt?: number;
}

export interface LearningPath {
  id: string;
  name: string;
  description: string;
  tutorials: string[];
  estimatedDuration: number; // minutes
}

export interface Requirement { name: string; version?: string; required: boolean; url?: string }
export interface InstallStep { number: number; title: string; description: string; images?: string[]; substeps?: string[] }
export interface InstallGuide { requirements: Requirement[]; steps: InstallStep[]; troubleshooting: TroubleshootingEntry[]; uninstall: string[] }

export interface WikiPage {
  id: string;
  title: string;
  slug: string;
  content: string; // Markdown
  category: string;
  tags: string[];
  author: string;
  created: number;
  updated: number;
  views: number;
  relatedPages: string[];
}

export interface WikiCategory {
  name: string;
  description: string;
  pages: string[];
  subcategories: WikiCategory[];
}

export interface NavigationNode {
  label: string;
  page?: string;
  children: NavigationNode[];
  icon?: string;
}
export interface NavigationTree { nodes: NavigationNode[] }

export interface SearchIndexEntry { pageId: string; title: string; excerpt?: string; tags?: string[] }
export interface SearchIndex { entries: SearchIndexEntry[]; version?: number }

export interface WikiMetadata {
  title: string;
  description: string;
  logo?: string;
  primaryColor: string;
  version: string;
}

export interface Wiki {
  pages: WikiPage[];
  categories: WikiCategory[];
  searchIndex: SearchIndex;
  navigation: NavigationTree;
  metadata: WikiMetadata;
}

export interface Documentation {
  type: DocumentationType;
  title: string;
  content: string;
  metadata: DocumentMetadata;
  sections: DocumentSection[];
}

export type DocumentationType = 
  | 'readme' 
  | 'changelog' 
  | 'api' 
  | 'wiki' 
  | 'guide' 
  | 'reference';

export interface DocumentMetadata {
  author: string;
  version: string;
  date: number;
  license?: string;
  tags: string[];
}

export interface DocumentSection {
  id: string;
  title: string;
  level: number; // Heading level (1-6)
  content: string;
  subsections: DocumentSection[];
}

// backward-compatible union for existing generator shapes
export type DocumentationUnion = ProjectDocumentation | APIDocumentation | AssetDocumentation | Tutorial | Wiki | any

// Template system types
export interface TemplateVariable {
  name: string;
  type: 'string' | 'number' | 'boolean' | 'array';
  default?: any;
  description?: string;
}

export interface Template {
  id: string;
  name: string;
  type: 'readme' | 'changelog' | 'wiki' | 'api-doc';
  content: string; // Template with variables (use {{VARNAME}})
  variables: TemplateVariable[];
}

export interface RenderedTemplate {
  templateId?: string;
  output: string;
  renderedAt: number;
}

export interface SearchRequest { query: string; filters?: any; topK?: number }
export interface SearchResults { query?: string; results: any[]; totalCount: number; searchTime?: number; suggestions?: any[] }

export interface ErrorContext {
  errorMessage?: string;
  stackTrace?: string;
  logContent?: string;
  relatedMods?: string[];
  contextData?: any;
  severity?: 'error' | 'warning' | 'info';
}
export interface ErrorDiagnosisResult { success: boolean; diagnosis?: any; confidence?: number; timestamp?: number }

export interface ExplanationRequest {
  concept?: string;
  subject?: string;
  skillLevel?: 'beginner' | 'intermediate' | 'advanced';
  includeExamples?: boolean;
  format?: 'text' | 'markdown' | 'code';
  context?: any;
}
export interface ExplanationResult { success: boolean; explanation?: any; confidence?: number; timestamp?: number }

export interface TutorialRequest {
  goal?: string;
  topic?: string;
  skillLevel?: 'beginner' | 'intermediate' | 'advanced';
  toolsInvolved?: string[];
  timeEstimate?: string | number;
  format?: string;
}
export interface TutorialResult { success: boolean; tutorial?: any; confidence?: number; timestamp?: number }

export interface AIFeedback { userId?: string; comment: string; rating?: number; context?: any }
export interface AIAssistantConfig {
  enabled?: boolean;
  provider?: string;
  apiKey?: string;
  apiEndpoint?: string;
  model?: string;
  temperature?: number;
  maxTokens?: number;
  timeout?: number;
  retryAttempts?: number;
  cachingEnabled?: boolean;
  offlineMode?: boolean;
  providerOptions?: any;
  scriptGeneration?: any;
  [key: string]: any;
}

export interface CapabilityDetail { enabled: boolean; supported: boolean; }
export interface AICapabilityStatus {
  scriptGeneration?: CapabilityDetail;
  assetNaming?: CapabilityDetail;
  workflowAutomation?: CapabilityDetail;
  documentationGeneration?: CapabilityDetail;
  semanticSearch?: CapabilityDetail;
  errorDiagnosis?: CapabilityDetail;
  learning?: CapabilityDetail;
  [key: string]: CapabilityDetail | any;
}

export interface AIEngineStatus {
  initialized?: boolean;
  ready?: boolean;
  lastHealthCheck?: number;
  capabilities?: AICapabilityStatus;
  performanceMetrics?: { requestsProcessed?: number; averageResponseTime?: number; errorRate?: number };
  connectionStatus?: 'connected' | 'disconnected' | 'degraded' | string;
  details?: any;
}

export interface AIUsageStatistics {
  totalRequests?: number;
  requestsByCapability?: Record<string, number>;
  successRate?: number;
  averageResponseTime?: number;
  totalTokensUsed?: number;
  estimatedCost?: number;
  lastReset?: number;
  period?: string;
  [key: string]: any;
}

export interface AIAssistantEngine {
  generateScript(request: ScriptGenerationRequest): Promise<ScriptGenerationResult>;
  suggestNames(request: AssetNamingRequest): Promise<AssetNamingResult>;
  batchRenameAssets(request: BatchAssetNaming): Promise<BatchNamingResult>;
  planWorkflow(request: WorkflowRequest): Promise<WorkflowResult>;
  executeWorkflow(plan: any): Promise<any>;
  generateDocumentation(request: DocumentationRequest): Promise<DocumentationResult>;
  search(request: SearchRequest): Promise<SearchResults>;
  buildSearchIndex(sourceFolder: string): Promise<void>;
  diagnoseError(context: ErrorContext): Promise<ErrorDiagnosisResult>;
  analyzeLogs(logContent: string, context?: any): Promise<any>;
  explain(request: ExplanationRequest): Promise<ExplanationResult>;
  suggestTutorial(request: TutorialRequest): Promise<TutorialResult>;
  getRelatedConcepts(concept: string): Promise<string[]>;
  getStatus(): Promise<AIEngineStatus>;
  getConfig(): AIAssistantConfig | Promise<AIAssistantConfig>;
  updateConfig(config: Partial<AIAssistantConfig>): Promise<void>;
  submitFeedback(feedback: AIFeedback): Promise<void>;
  getUsageStatistics(): Promise<AIUsageStatistics>;
}

// --- AIModAssistant types ---
export interface ChatContext {
  conversationId?: string;
  userId: string;
  currentFile?: string;
  projectContext?: ProjectData;
  recentActions: Action[];
}

export interface ChatResponse {
  conversationId: string;
  message: string;
  suggestions: Suggestion[];
  actions: AIAction[];
  confidence: number;
}

export interface Suggestion {
  text: string;
  type: 'question' | 'command' | 'information';
  confidence: number;
}

export interface AIAction {
  type: 'create-file' | 'edit-code' | 'run-tool' | 'open-panel';
  description: string;
  parameters: Record<string, any>;
  autoExecute: boolean;
}

export interface GeneratedCode {
  code: string;
  language: string;
  explanation: string;
  warnings: string[];
  alternatives: CodeAlternative[];
}

export interface CodeAlternative {
  code: string;
  description: string;
  pros: string[];
  cons: string[];
}

export interface Explanation {
  summary: string;
  breakdown: CodeBreakdown[];
  concepts: Concept[];
  relatedDocs: string[];
}

export interface CodeBreakdown {
  lineRange: [number, number];
  explanation: string;
  purpose: string;
}

export interface Concept {
  name: string;
  description: string;
  learnMoreUrl?: string;
}

export interface RefactoredCode {
  original: string;
  refactored: string;
  changes: Change[];
  improvements: string[];
  testSuggestions: string[];
}

export interface Change {
  type: 'rename' | 'extract' | 'inline' | 'restructure';
  description: string;
  before: string;
  after: string;
}

export interface Fix {
  title: string;
  description: string;
  code?: string;
  steps: string[];
  confidence: number;
  estimatedTime: number;
}

export interface FeatureSuggestion {
  name: string;
  description: string;
  difficulty: 'easy' | 'medium' | 'hard';
  estimatedTime: number;
  dependencies: string[];
  pseudocode?: string;
}

export interface Intent {
  type: 'question' | 'command' | 'request' | 'feedback';
  action: string;
  confidence: number;
}

export interface Parameters {
  [key: string]: any;
}

export interface PersonalizationSettings {
  userId: string;
  preferredLanguage: string;
  skillLevel: 'beginner' | 'intermediate' | 'advanced';
  interests: string[];
  frequentActions: string[];
}

export interface ImageAnalysis {
  description: string;
  objects: DetectedObject[];
  answer: string;
  confidence: number;
}

export interface DetectedObject {
  label: string;
  confidence: number;
  boundingBox: BoundingBox;
}

export interface BoundingBox {
  x: number;
  y: number;
  width: number;
  height: number;
}

export interface Action {
  type: string;
  timestamp: number;
  details: any;
}
export interface AIModAssistantEngine {
  // Conversational AI
  chat(message: string, context: ChatContext): Promise<ChatResponse>;
  continueConversation(conversationId: string, message: string): Promise<ChatResponse>;

  // Code generation
  generateScript(prompt: string, language: 'papyrus' | 'typescript'): Promise<GeneratedCode>;
  explainCode(code: string): Promise<Explanation>;
  refactorCode(code: string, improvements: string[]): Promise<RefactoredCode>;

  // Smart suggestions
  suggestFixes(error: string, context: any): Promise<Fix[]>;
  suggestOptimizations(mod: string): Promise<Optimization[]>;
  suggestFeatures(modDescription: string): Promise<FeatureSuggestion[]>;

  // Natural language processing
  parseIntent(userInput: string): Promise<Intent>;
  extractParameters(intent: Intent, userInput: string): Promise<Parameters>;

  // Learning & adaptation
  learnFromFeedback(interactionId: string, helpful: boolean): Promise<void>;
  personalizeResponses(userId: string): Promise<PersonalizationSettings>;

  // Multi-modal
  analyzeImage(imagePath: string, question: string): Promise<ImageAnalysis>;
  generateImageDescription(imagePath: string): Promise<string>;
}

// -----------------------------
// Cloud Sync / Collaboration types
// -----------------------------
export interface CloudSyncConfig {
  enabled: boolean;
  backend: 'self-hosted' | 'firebase' | 'aws' | 'supabase' | 'p2p' | string;
  autoSync?: boolean;
  syncInterval?: number;
  conflictResolutionMode?: string;
  compressionEnabled?: boolean;
  encryptionEnabled?: boolean;
  includeAssets?: boolean;
  maxUploadSize?: number;
  [key: string]: any;
}

export interface SyncStatus {
  projectId: string;
  isSyncing: boolean;
  lastSyncTime?: number;
  nextSyncTime?: number;
  syncProgress?: number;
  currentOperation?: string;
  error?: string;
}

export interface ProjectSnapshot { id: string; projectId: string; createdAt?: number; version?: string; files?: string[] | Map<string, any> | any; metadata?: any; timestamp?: number; author?: string; message?: string; fileCount?: number; totalSize?: number; checksum?: string }
export interface ShareResult { success: boolean; projectId?: string; inviteCode?: string; sharedWith?: string[]; expiresAt?: number; permissions?: string[]; error?: string }
export interface ProjectJoinResult { success: boolean; projectId?: string; projectName?: string; role?: string; permissions?: string[]; joinedAt?: number; error?: string }
export interface CDNUrl { url: string; region?: string; provider?: string; expiresAt?: number; metadata?: any }
export interface ChangeSubscription { id?: string; projectId: string; callbackUrl?: string; lastSeen?: number; filters?: any; callback?: (change: ProjectChange) => void; subscriptionId?: string }
export interface ProjectChange { projectId?: string; filePath?: string; path?: string; changeType?: 'modified'|'added'|'deleted'|'renamed'; diff?: any; author?: string; timestamp?: number; metadata?: any }
export interface SyncResult { success: boolean; direction?: string; filesSync?: number; bytesSync?: number; conflictsDetected?: number; conflictsResolved?: number; duration?: number; timestamp?: number; error?: string }
export interface ProjectState { projectId: string; version?: string; files?: Map<string, { checksum?: string; timestamp: number; author?: string }>; metadata?: any; settings?: any; lastSyncTime?: number }

/**
 * Shared audio / AudioEditor engine types
 * These are top-level shared types used by the in-memory AudioEditorEngine
 */
export type AudioFormat = 'xwm' | 'fuz' | 'wav' | 'mp3';
export type LayeringType = 'simultaneous' | 'sequential' | 'random';

export interface AudioFile {
  path: string;
  format: AudioFormat;
  duration: number; // seconds
  sampleRate: number;
  bitrate: number;
  channels: 1 | 2; // mono or stereo
  fileSize: number;
}

export interface ConversionResult {
  success: boolean;
  outputPath: string;
  originalSize: number;      // bytes
  compressedSize: number;    // bytes (after conversion/compression)
  compressionRatio: number;  // originalSize / compressedSize
}

export interface FUZResult extends ConversionResult {
  lipSyncIncluded: boolean;
}

export interface BatchResult {
  totalFiles: number;
  successful: number;
  failed: number;
  results: ConversionResult[];
} 

export interface Phoneme {
  type: PhonemeType;
  timestamp: number;
  intensity: number;
}

export type PhonemeType =
  | 'Aah' | 'BigAah' | 'BMP' | 'ChJSh' | 'DST'
  | 'Eee' | 'Eh' | 'FV' | 'I' | 'K' | 'N' | 'Oh'
  | 'OohQ' | 'R' | 'Th' | 'W';

export interface Emotion {
  type: EmotionType;
  intensity: number;
  startTime: number;
  endTime: number;
}

export interface PhonemeData {
  phonemes: Phoneme[];
  transcript: string;
  confidence: number;
}

export interface LipFile {
  phonemes: Phoneme[];
  emotions: Emotion[];
  duration: number;
}

export interface AudioLayer { audioPath: string; volume: number; startTime: number; loop: boolean; fadeIn: number; fadeOut: number }

export type MusicType =
  | 'explore'     // Exploration music
  | 'combat'      // Combat music
  | 'dungeon'     // Dungeon ambience
  | 'town'        // Settlement music
  | 'special';    // Special event

export interface MusicCondition { key: string; operator?: '==' | '!=' | '>' | '<' | '>=' | '<=' | 'in'; value: any }

export interface MusicTrack {
  id: string;
  name: string;
  type: MusicType;
  layers: AudioLayer[];
  conditions: MusicCondition[];
  priority: number;
  fadeIn: number;
  fadeOut: number;
}

export interface Playlist { name: string; tracks: string[]; transitionType: 'crossfade' | 'immediate' | 'pause'; transitionDuration: number; shuffle: boolean }

export interface AttenuationPoint { distance: number; volume: number }
export interface AttenuationCurve { points: AttenuationPoint[] }

export type SoundCategory =
  | 'FX'          // Sound effects
  | 'Voice'       // Dialogue/voice
  | 'Music'       // Background music
  | 'Ambient'     // Ambient loops
  | 'UI'          // Interface sounds
  | 'Footstep';   // Footstep sounds

export interface SoundDescriptor {
  id?: string; // optional id for persisted descriptors
  name: string;
  category: SoundCategory;
  audioFiles: string[];          // file paths or references
  looping: boolean;
  volume: number;                // 0.0 - 1.0
  pitch?: number;                // semitone multiplier or default 1.0
  staticAttenuation?: number;    // simple fixed attenuation factor
  distanceAttenuation?: AttenuationCurve; // distance-based curve
  attenuation?: AttenuationCurve; // legacy alias (kept for compatibility)
  randomFrequency?: { min: number; max: number };
}

export interface SoundLayer {
  soundDescriptor: string;
  volume: number;
  probability: number;
  minDelay: number;
  maxDelay: number;
}

export interface AmbientSound {
  layers: SoundLayer[];
  volume: number;
  fadeIn: number;
  fadeOut: number;
}

export interface AudioEffect {
  type: 'reverb' | 'delay' | 'chorus' | 'eq' | 'compressor';
  parameters: Record<string, number>;
} 

/**
 * API for the preload script (exposed to renderer via contextBridge)
 */
export interface ElectronAPI {
    // Generic IPC
    invoke: (channel: string, ...args: any[]) => Promise<any>;
    send: (channel: string, ...args: any[]) => void;
    on: (channel: string, callback: (...args: any[]) => void) => (() => void);
    
    // Directory Picker
    pickDirectory: (options?: any) => Promise<string | null>;

    // Real-time STT partial transcript
    onSttPartial?: (callback: (partial: string) => void) => void;

    // Real-time mic level
    onMicLevel?: (callback: (level: number) => void) => void;
  // Messaging
  sendMessage: (message: string | VoiceChatPayload) => Promise<void>;
  onMessage: (callback: (message: Message) => void) => (() => void);
  
  // Settings
  getSettings: () => Promise<Settings>;
  setSettings: (settings: Partial<Settings>) => Promise<void>;
  onSettingsUpdated: (callback: (settings: Settings) => void) => void;

  // Desktop Bridge
  checkBlenderAddon?: () => Promise<{ connected: boolean; error?: string }>;
  sendBlenderCommand?: (command: string, args?: any) => Promise<any>;
  
  // Audio
  ttsSpeak: (text: string) => Promise<void>;
  sttStart: () => Promise<void>;
  sttStop: () => Promise<void>;
  startListening: () => Promise<void>;
  stopListening: () => Promise<void>;
  onSttResult: (callback: (text: string) => void) => (() => void);
  onTtsSpeak: (callback: (text: string | null) => void) => (() => void);
  transcribeAudio: (arrayBuffer: ArrayBuffer, mimeType?: string) => Promise<{ success: boolean; text?: string; error?: string }>;


  // PDF parsing
  parsePDF: (arrayBuffer: ArrayBuffer) => Promise<{ success: boolean; text?: string; error?: string }>;
  // PSD parsing
  parsePSD: (arrayBuffer: ArrayBuffer) => Promise<{ success: boolean; text?: string; metadata?: any; error?: string }>;
  // ABR parsing (Adobe Brush)
  parseABR: (arrayBuffer: ArrayBuffer) => Promise<{ success: boolean; text?: string; metadata?: any; error?: string }>;
  // Video transcription
  transcribeVideo: (arrayBuffer: ArrayBuffer, filename: string, projectId?: string, organizationId?: string) => Promise<{ success: boolean; text?: string; error?: string }>;
  getSystemInfo: () => Promise<SystemInfo>;
  getPerformance: () => Promise<{
    cpuUsage: number;
    memoryUsage: number;
    gpuUsage?: number;
    gpuMemory?: number;
  }>;
  // Process metrics helper (exposed by preload)
  getProcessMetrics?: (pid: number) => Promise<{ cpu: number; memory: number; handles?: number }>;

  // Quest Editor (renderer -> main) helper IPC wrappers
  createQuest?: (name: string, type?: QuestType, description?: string) => Promise<{ success: boolean; data?: Quest; error?: string }>;
  loadQuest?: (espPath: string | undefined, questId: string) => Promise<{ success: boolean; data?: Quest; error?: string }>;
  saveQuest?: (quest: Quest, espPath?: string) => Promise<{ success: boolean; errors?: string[]; error?: string }>;
  addQuestStage?: (quest: Quest, stage: QuestStage) => Promise<{ success: boolean; data?: QuestStage; error?: string }>;
  generateQuestScript?: (quest: Quest) => Promise<{ success: boolean; data?: PapyrusCode; error?: string }>;
  createDialogueBranch?: (npc: string, topic: string, questId?: string) => Promise<{ success: boolean; data?: DialogueBranch; error?: string }>;
  validateQuest?: (quest: Quest) => Promise<{ success: boolean; data?: ValidationResult; error?: string }>;
  simulateQuest?: (quest: Quest, choices?: any[]) => Promise<{ success: boolean; data?: QuestSimulationResult; error?: string }>;

  // Cell Editor helper IPC wrappers (renderer -> main)
  loadCell?: (espPath: string | undefined, cellId: string) => Promise<{ success: boolean; data?: Cell; error?: string }>;
  saveCell?: (cell: Cell, espPath?: string) => Promise<{ success: boolean; data?: SaveResult; error?: string }>;
  createCell?: (name: string, type?: CellType) => Promise<{ success: boolean; data?: Cell; error?: string }>;
  placeObject?: (cell: Cell, baseObject: string, position: Vector3, rotation: Vector3) => Promise<{ success: boolean; data?: Reference; error?: string }>;
  moveObject?: (refId: string, position: Vector3) => Promise<{ success: boolean; error?: string }>;
  deleteObject?: (refId: string) => Promise<{ success: boolean; error?: string }>;
  duplicateObject?: (refId: string, offset: Vector3) => Promise<{ success: boolean; data?: Reference; error?: string }>;
  generateNavmesh?: (cell: Cell, settings?: NavmeshSettings) => Promise<{ success: boolean; data?: Navmesh; error?: string }>;
  editNavmesh?: (navmesh: Navmesh, triangles: Triangle[]) => Promise<{ success: boolean; error?: string }>;
  finalizeNavmesh?: (navmesh: Navmesh) => Promise<{ success: boolean; error?: string }>;
  placeLight?: (cell: Cell, light: LightSource) => Promise<{ success: boolean; data?: Reference; error?: string }>;
  bakeAO?: (cell: Cell) => Promise<{ success: boolean; data?: AOData; error?: string }>;
  generateCollision?: (staticCollection: Reference[]) => Promise<{ success: boolean; data?: CollisionData; error?: string }>;
  generateOcclusionPlanes?: (cell: Cell) => Promise<{ success: boolean; data?: OcclusionData; error?: string }>;
  createCombinedMesh?: (references: Reference[]) => Promise<{ success: boolean; data?: CombinedMesh; error?: string }>;

  // Audio Editor API exposed on the preload electronAPI.audioEditor
  audioEditor?: {
    convertToXWM: (wavPath: string, quality?: number) => Promise<ConversionResult>;
    convertToFUZ: (wavPath: string, lipPath?: string) => Promise<FUZResult>;
    batchConvertAudio: (files: string[], format: AudioFormat) => Promise<BatchResult>;
    generateLipSync: (wavPath: string, text: string) => Promise<LipFile>;
    phonemeAnalysis: (wavPath: string) => Promise<PhonemeData>;
    createMusicTrack: (name: string, layers: AudioLayer[], type?: MusicType) => Promise<MusicTrack>;
    setMusicConditions: (track: MusicTrack, conditions: MusicCondition[]) => Promise<void>;
    createMusicPlaylist: (tracks: string[], transitionType?: 'crossfade' | 'immediate' | 'pause', transitionDuration?: number, shuffle?: boolean) => Promise<Playlist>;
    createSoundDescriptor: (sound: SoundDescriptor) => Promise<string>;
    set3DAttenuation: (descriptorId: string, curve: AttenuationCurve) => Promise<void>;
    playAudio: (audioPath: string) => Promise<void>;
    stopAudio: () => Promise<void>;
    createAmbientSound: (sounds: string[], layering: LayeringType) => Promise<AmbientSound>;
    normalizeVolume: (audioFiles: string[]) => Promise<void>;
    removeNoise: (audioPath: string, strength?: number) => Promise<string>;
    applyEffect: (audioPath: string, effect: AudioEffect) => Promise<string>;
  };

  // Testing suite exposed on preload (typed)
  testingSuite?: {
    createTestSuite: (name: string, type: TestType) => Promise<TestSuite>;
    runTests: (suiteId: string) => Promise<TestResults>;
    runSingleTest: (testId: string) => Promise<TestResult>;
    testLoadOrder: (plugins: string[]) => Promise<LoadOrderTestResult>;
    testSaveGameCompatibility: (savePath: string, modList: string[]) => Promise<CompatibilityTestResult>;
    testScriptCompilation: (scripts: string[]) => Promise<CompilationTestResult>;
    testAssetIntegrity: (assets: string[]) => Promise<IntegrityTestResult>;
    benchmarkModPerformance: (mod: string) => Promise<BenchmarkResult>;
    createBaseline: (modVersion: string) => Promise<Baseline>;
    compareToBaseline: (current: TestResults, baseline: Baseline) => Promise<RegressionReport>;
    generateTestReport: (results: TestResults) => Promise<TestReport>;
    exportTestResults: (results: TestResults, format: ExportFormat) => Promise<string>;
    executeTestScript?: (script: TestScript) => Promise<ScriptResult>;
    validateQuestFlow?: (quest: any, choices: any[]) => Promise<QuestFlowResult>;
  };

  // Learning Hub (renderer  main)  typed wrappers
  learningHub?: {
    getTutorial: (tutorialId: string) => Promise<Tutorial | null>;
    listTutorials: (category?: string) => Promise<Tutorial[]>;
    trackProgress: (userId: string, tutorialId: string, step: number | string) => Promise<void | { success: boolean }>; // accepts index or stepId
    validateExercise: (exerciseId: string, submission: any) => Promise<ValidationResult>;
    submitExercise: (exerciseId: string, answer: any) => Promise<ValidationResult>;
    completeStep: (userId: string, stepId: string) => Promise<StepCompletion>;
    getUserProgress: (userId: string) => Promise<UserProgress>;
    provideHint: (exerciseId: string, currentAttempt?: any) => Promise<Hint>;
    unlockAchievement: (userId: string, achievementId: string) => Promise<Achievement>;
    listAchievements: (userId?: string) => Promise<{ unlocked: Achievement[]; all: Achievement[] }>;
  };

  // Mod Browser (preload  main) convenience wrappers
  modBrowser?: {
    searchMods: (query: string, filters?: SearchFilters) => Promise<ModListing[]>;
    getModDetails: (modId: string) => Promise<ModDetails>;
    downloadMod: (modId: string, destination: string) => Promise<DownloadResult>;
    rateMod: (modId: string, rating: number, review: string) => Promise<void>;
    authenticateNexus: (apiKey: string) => Promise<AuthResult>;
    getModReviews: (modId: string) => Promise<Review[]>;
    createCollection: (name: string, mods: string[], description?: string) => Promise<Collection>;
    shareCollection: (collectionId: string) => Promise<{ success: boolean; shareUrl?: string }>;
    endorseMod: (modId: string) => Promise<void>;
    getTrendingMods: (timeframe?: string) => Promise<ModListing[]>;
  };

  // Security / scanning API (preload  main)
  security?: {
    scanFile(path: string): Promise<ScanResult>;
    scanArchive(path: string): Promise<ArchiveScanResult>;
    scanScript(path: string): Promise<ScriptScanResult>;
    analyzePapyrusScript(code: string): Promise<CodeAnalysis>;
    generateChecksum(path: string, algorithm?: 'md5' | 'sha256'): Promise<string>;
    verifyChecksum(path: string, expectedHash: string): Promise<boolean>;
    verifySignature(path: string, signature: string, publicKey: string): Promise<boolean>;
    runInSandbox(executable: string, args: string[], config?: any): Promise<SandboxResult>;
    updateThreatDatabase(): Promise<UpdateResult>;
    updateThreats(): Promise<UpdateResult>;
    checkAgainstDatabase(hash: string): Promise<ThreatInfo | null>;
  };

  detectPrograms: () => Promise<InstalledProgram[]>;
  externalToolDetectTools?: () => Promise<InstalledProgram[]>;
  externalToolVerifyTool?: (toolName: string) => Promise<{ success: boolean; error?: string }>;
  externalToolRunXEditScript?: (scriptPath: string, pluginList: string[]) => Promise<any>;
  externalToolCleanPlugin?: (pluginPath: string, mode?: 'quick' | 'manual') => Promise<any>;
  externalToolFindConflicts?: (plugins: string[]) => Promise<any>;
  externalToolOptimizeNIF?: (nifPath: string, settings?: any) => Promise<any>;
  externalToolBatchFixNIFs?: (folder: string, issues: string[]) => Promise<any>;
  externalToolExtractNIFInfo?: (nifPath: string) => Promise<any>;
  externalToolImportFBX?: (fbxPath: string, settings?: any) => Promise<any>;
  externalToolExportNIF?: (blendPath: string, settings?: any) => Promise<any>;
  externalToolBatchConvertMeshes?: (files: string[], workflow: string) => Promise<any>;
  externalToolRunCKCommand?: (command: string, args: string[]) => Promise<any>;
  externalToolGeneratePrecombines?: (espPath: string, cells?: string[]) => Promise<any>;
  externalToolPackArchive?: (folder: string, archiveName: string, format: 'General' | 'DDS' | 'BA2') => Promise<any>;
  externalToolUnpackArchive?: (ba2Path: string, outputFolder: string) => Promise<any>;

  // xEdit / external tool wrappers (exposed on preload and available to renderer)
  xeditClean?: (pluginPath: string, mode?: 'quick' | 'manual') => Promise<any>;
  xeditExecuteScript?: (scriptPath: string, plugins: string[], parameters?: any) => Promise<any>;
  xeditExportCSV?: (plugin: string, recordTypes: string[], outputPath?: string) => Promise<any>;
  xeditFindConflicts?: (plugins: string[]) => Promise<any>;

  // NIF helpers
  nifOptimize?: (nifPath: string, options?: any) => Promise<any>;
  nifBatchOptimize?: (nifFiles: string[], options?: any) => Promise<any>;
  nifChangeTexture?: (nifPath: string, oldPath: string, newPath: string) => Promise<any>;
  nifFixCollision?: (nifPath: string, options?: any) => Promise<any>;
  nifExtractMetadata?: (nifPath: string) => Promise<any>;
  nifValidate?: (nifPath: string) => Promise<any>;

  // Blender integrations
  blenderConvertFBXToNIF?: (fbxPath: string, nifPath: string, options?: any) => Promise<any>;
  blenderConvertNIFToFBX?: (nifPath: string, fbxPath: string, options?: any) => Promise<any>;
  blenderExecuteScript?: (scriptContent: string, args?: any, options?: any) => Promise<any>;
  blenderBatchProcess?: (files: string[], operation: string, options?: any) => Promise<any>;
  blenderCheckNIFPlugin?: () => Promise<any>;

  // Creation Kit (CK) helpers
  ckLaunch?: (espPath?: string, options?: any) => Promise<any>;
  ckGetLog?: () => Promise<string>;
  ckGetLogErrors?: () => Promise<any[]>;
  ckValidateESP?: (espPath: string) => Promise<any>;
  ckGetMasters?: (espPath: string) => Promise<string[]>;
  ckBackupESP?: (espPath: string) => Promise<any>;
  ckIsRunning?: () => Promise<boolean>;
  ckKill?: () => Promise<any>;

  getRunningProcesses: () => Promise<any[]>;
  openExternal: (url: string) => Promise<void>;
  openProgram: (path: string) => Promise<{ success: boolean; error?: string; method?: string }>;
  readFile: (filePath: string) => Promise<string>;
  readCrashLog?: (logPath: string) => Promise<{ success: boolean; content?: string; error?: string }>;
  saveFile: (content: string, filename: string) => Promise<string>;
  // Plugin / integration helpers
  getPluginMetadata?: (pluginPath: string) => Promise<any>;
  // CK Crash Prevention helpers
  ckValidate?: (modDataOrEspPath: any) => Promise<any>;
  ckGeneratePreventionPlan?: (validationResult: any) => Promise<any>;
  ckAnalyzeCrash?: (logPath: string) => Promise<any>;
  ckPickLogFile?: () => Promise<string | null>;

  // Developer tools
  openDevTools: () => Promise<void>;

  // Advanced analysis (optional)
  getAdvancedAnalysisEngine?: () => Promise<AdvancedAnalysisEngine>;
  
  // Image Suite
  generateNormalMap: (imageBase64: string) => Promise<string>;
  generateRoughnessMap: (imageBase64: string) => Promise<string>;
  generateHeightMap: (imageBase64: string) => Promise<string>;
  generateMetallicMap: (imageBase64: string) => Promise<string>;
  generateAOMap: (imageBase64: string) => Promise<string>;
  convertImageFormat: (sourceBase64: string, targetFormat: string, options: any) => Promise<string>;
  getImageInfo: (filePath: string) => Promise<{ width: number; height: number; format: string; colorSpace: string } | null>;

  // Asset Validation helpers
  assetValidateMod?: (modPath: string, depth?: 'quick' | 'standard' | 'deep', progressCallback?: (progress: number) => void) => Promise<{ success: boolean; issues?: any[]; error?: string }>;
  assetValidateNIF?: (nifPath: string) => Promise<{ success: boolean; metadata?: any; issues?: any[]; error?: string }>;
  assetValidateDDS?: (ddsPath: string) => Promise<{ success: boolean; format?: string; error?: string }>;
  assetValidateESP?: (espPath: string) => Promise<{ success: boolean; warnings?: any[]; error?: string }>;
  assetValidateScript?: (pscPath: string) => Promise<{ success: boolean; errors?: string[]; error?: string }>;
  assetValidateSound?: (wavPath: string) => Promise<{ success: boolean; duration?: number; error?: string }>;
  assetValidateBatch?: (files: string[], progressCallback?: (progress: number) => void) => Promise<{ success: boolean; results?: any[]; error?: string }>;
  assetValidationAutoFix?: (issues: any[]) => Promise<{ success: boolean; fixed?: any[]; error?: string }>;

  // Asset Validator (alternative namespace)
  assetValidatorValidateFile?: (filePath: string, type: string) => Promise<any>;
  assetValidatorValidateMod?: (modPath: string, depth?: 'quick' | 'standard' | 'deep') => Promise<any>;
  assetValidatorAutoFix?: (issues: any[]) => Promise<any>;
  assetValidatorExportReport?: (report: any, format: 'json' | 'html') => Promise<any>;

  // DDS Converter helpers
  ddsConvert?: (input: any) => Promise<any>;
  ddsConvertBatch?: (files: any[], options?: any) => Promise<any>;
  ddsDetectFormat?: (filePath: string) => Promise<any>;
  ddsGenerateMipmaps?: (imagePath: string, levels?: number) => Promise<any>;
  ddsGetPreset?: (type: string) => Promise<any>;
  ddsGetAllPresets?: () => Promise<any>;
  ddsGetDefaultFormatRules?: () => Promise<any>;
  ddsPickFiles?: () => Promise<string[]>;

  // Texture Generator helpers
  textureGenerateMaterialSet?: (input: any) => Promise<any>;
  textureGenerateMap?: (type: string, source: string, settings: any) => Promise<any>;
  textureMakeSeamless?: (imagePath: string, blendRadius?: number) => Promise<any>;
  textureUpscale?: (imagePath: string, factor: 2 | 4) => Promise<any>;
  textureGenerateProcedural?: (type: string, settings: any) => Promise<any>;
  
  // Voice setup wizard handlers
  checkOllamaStatus: () => Promise<{ installed: boolean; version?: string; error?: string }>;
  listOllamaModels: () => Promise<string[]>;
  pullOllamaModel: (modelName: string) => Promise<{ success: boolean; message?: string; error?: string }>;
  
  // Scribe Advanced
  installScript: (type: 'papyrus' | 'xedit', name: string, code: string, targetPath?: string) => Promise<{ success: boolean; path?: string; error?: string }>;

  // Window
  minimizeWindow: () => void;
  closeWindow: () => void;

  // Project Management
  listProjects: () => Promise<ModProject[]>;
  createProject: (project: Omit<ModProject, 'id' | 'createdAt' | 'updatedAt'>) => Promise<ModProject>;
  updateProject: (id: string, updates: Partial<ModProject>) => Promise<ModProject>;
  deleteProject: (id: string) => Promise<boolean>;
  switchProject: (id: string) => Promise<void>;
  getCurrentProject: () => Promise<ModProject | null>;

  // Mod Packaging helpers
  modPackagingStart?: (modPath: string) => Promise<any>;
  modPackagingValidateStructure?: (modPath: string) => Promise<any>;
  modPackagingCreateArchive?: (settings: any) => Promise<any>;
  modPackagingGenerateReadme?: (modInfo: any, template: string) => Promise<string>;

  // Documentation generator (preload wrappers + main IPC)
  generateProjectDocs?: (projectPath: string) => Promise<ProjectDocumentation>;
  generateReadme?: (projectData: any, template?: string) => Promise<string>;
  generateAPIDoc?: (code: string, language: string) => Promise<APIDocumentation>;
  documentAssets?: (assetFolder: string) => Promise<AssetDocumentation>;
  generateWiki?: (project: any) => Promise<Wiki>;
  exportDocumentation?: (doc: DocumentationUnion | Documentation, format: 'markdown' | 'html' | 'pdf' | 'nexus') => Promise<any>;

  modPackagingAppendChangelog?: (changelogPath: string, version: string, changes: string[]) => Promise<any>;
  modPackagingPrepareNexus?: (modPackage: any) => Promise<any>;
  modPackagingIncrementVersion?: (currentVersion: string, type: 'major' | 'minor' | 'patch') => Promise<string>;
  modPackagingGetSession?: (sessionId: string) => Promise<any>;
  modPackagingUpdateSession?: (sessionId: string, updates: any) => Promise<any>;

  // FOMOD Builder helpers
  fomodCreate?: (modPath: string, modInfo?: any) => Promise<any>;
  fomodGenerateModuleConfig?: (fomod: any) => Promise<any>;
  fomodGenerateInfoXML?: (modInfo: any) => Promise<any>;
  fomodValidate?: (fomodPath: string) => Promise<any>;
  fomodPreview?: (fomod: any, selections?: Map<string, string[]>) => Promise<any>;
  fomodExport?: (fomod: any, outputPath: string, sourceModPath: string) => Promise<any>;
  fomodLoad?: (fomodPath: string) => Promise<any>;
  fomodSaveProject?: (fomod: any, projectPath: string) => Promise<any>;

  // Load Order / Conflict Resolution helpers
  loadOrderAnalyze?: (plugins: any[]) => Promise<any>;
  loadOrderOptimize?: (plugins: any[], rules: any) => Promise<any>;
  loadOrderDetectConflicts?: (plugins: any[]) => Promise<any>;
  loadOrderResolveDependencies?: (plugins: any[]) => Promise<any>;
  loadOrderPredictPerformance?: (plugins: any[]) => Promise<any>;
  loadOrderApplyRules?: (plugins: any[], rules: any[]) => Promise<any>;
  loadOrderImport?: (source: 'mo2' | 'vortex', sourcePath?: string) => Promise<any>;
  loadOrderExport?: (plugins: any[], destination: 'mo2' | 'vortex', destPath?: string) => Promise<any>;
  loadOrderParsePlugin?: (pluginPath: string) => Promise<any>;
  loadOrderSaveOptimization?: (optimization: any, filePath: string) => Promise<any>;
  pickMo2ProfileDir?: () => Promise<string | null>;
  pickVortexProfileDir?: () => Promise<string | null>;
  conflictAnalyze?: (plugins: string[]) => Promise<any>;
  conflictCompareRecords?: (pluginA: string, pluginB: string, recordIdentifier: string) => Promise<any>;
  conflictGeneratePatch?: (conflicts: any[], strategy: any) => Promise<any>;
  conflictCheckCompatibility?: (modA: string, modB: string) => Promise<any>;
  conflictRecommendMerge?: (plugins: string[]) => Promise<any>;
  conflictApplyRules?: (conflicts: any[], rules: any[]) => Promise<any>;
  conflictSavePatch?: (patch: any, outputPath: string) => Promise<any>;

  // Game integration helpers
  gameDetectGame?: () => Promise<{ id: string; path?: string; version?: string } | null>;
  gameExecuteConsoleCommand?: (command: string, game: string) => Promise<{ success: boolean; output?: string; error?: string }>;
  gameAnalyzeSave?: (savePath: string) => Promise<any>;
  gameGetActiveMods?: (game: any) => Promise<string[]>;
  gameStartMonitoring?: (pid: number) => Promise<{ success: boolean; error?: string }>;
  gameCaptureScreenshot?: () => Promise<Buffer | null>;
  gameInjectPlugin?: (dllPath: string, game: any) => Promise<{ success: boolean; error?: string }>;

  // Wizard Support
  wizardGetState: (wizardId: string) => Promise<any>;
  wizardUpdateStep: (wizardId: string, stepId: string, status: any, data?: any) => Promise<any>;
  wizardSubmitAction: (wizardId: string, actionType: string, payload: any) => Promise<any>;

  // Roadmap System
  roadmapGetAll: () => Promise<Roadmap[]>;
  roadmapGetActive: () => Promise<Roadmap | null>;
  roadmapCreate: (roadmap: Omit<Roadmap, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Roadmap>;
  roadmapUpdateStep: (roadmapId: string, stepId: string, status: string) => Promise<{ ok: boolean }>;
  roadmapDelete: (id: string) => Promise<void>;
  roadmapGenerateAI: (prompt: string, projectId: string) => Promise<{ ok: boolean; roadmap: Roadmap }>;

  // Mining Infrastructure
  startMiningPipeline?: (sources: DataSource[]) => Promise<MiningResult>;
  parseESPFile?: (filePath: string) => Promise<ESPFile>;
  correlateAssets?: (assets: AssetReference[]) => Promise<AssetCorrelation[]>;
  buildDependencyGraph?: (modFiles: string[]) => Promise<ModDependencyGraph>;
  analyzePerformance?: (metrics: PerformanceMetric[]) => Promise<PerformanceReport>;
  getMiningStatus?: () => Promise<{ active: boolean; progress: number; currentTask?: string }>;
  miningStart?: () => Promise<void>;
  miningStop?: () => Promise<void>;
  miningGetStatus?: () => Promise<any>;
  miningGetResults?: () => Promise<any>;
  miningDeepAnalysis?: (options: any) => Promise<any>;
  miningBatchJob?: (job: any) => Promise<any>;
  miningResolveConflicts: (modDirectory: string) => Promise<any>;
  miningWorkflowRecommendations: (options: any) => Promise<any>;
  miningUpdateConfig: (config: any) => Promise<any>;

  // Phase 1: Asset Correlation Engine
  miningAssetCorrelationStart: (config?: any) => Promise<any>;
  miningAssetCorrelationStop: () => Promise<any>;
  miningAssetCorrelationStatus: () => Promise<any>;
  miningAssetCorrelationResults: () => Promise<any>;

  // Phase 1: Pattern Recognition Engine
  miningPatternRecognitionStart: (config?: any) => Promise<any>;
  miningPatternRecognitionStop: () => Promise<any>;
  miningPatternRecognitionStatus: () => Promise<any>;
  miningPatternRecognitionResults: () => Promise<any>;

  // BA2 Archive Management
  mergeBA2: (inputArchives: string[], outputArchive: string, archiveType: 'general' | 'texture') => Promise<any>;

  // Collaboration Features
  initGitRepository: (projectId: string, config: any) => Promise<any>;
  gitCommit: (projectId: string, message: string, files?: string[]) => Promise<any>;
  gitPush: (projectId: string) => Promise<any>;
  gitPull: (projectId: string) => Promise<any>;

  // Version Control helpers
  versionControlInit?: (projectPath: string) => Promise<any>;
  versionControlCommit?: (message: string, files?: string[]) => Promise<any>;
  versionControlHistory?: (limit?: number) => Promise<any>;
  versionControlCreateBranch?: (branchName: string) => Promise<any>;
  versionControlMergeBranch?: (source: string, target: string) => Promise<any>;
  versionControlDiff?: (fileA: string, fileB: string) => Promise<any>;
  versionControlShowChanges?: (commitHash: string) => Promise<any>;
  versionControlPush?: (remote: string, branch: string) => Promise<any>;
  versionControlPull?: (remote: string, branch: string) => Promise<any>;
  versionControlClone?: (repoUrl: string, localPath: string) => Promise<any>;
  versionControlBackup?: (projectPath: string) => Promise<any>;
  versionControlRestore?: (backupId: string, targetPath: string) => Promise<any>;
  versionControlListBackups?: () => Promise<any[]>;
  versionControlResolveConflict?: (file: string, resolution: 'ours' | 'theirs' | 'manual') => Promise<any>;
  joinCollaborationSession?: (sessionId: string) => Promise<CollaborationSession>;
  leaveCollaborationSession?: (sessionId: string) => Promise<void>;

  // Advanced Analytics
  trackAnalyticsEvent: (event: any) => Promise<any>;
  getAnalyticsMetrics: () => Promise<any>;
  exportAnalyticsData: () => Promise<any>;
  exportAnalyticsReport?: (format: string) => Promise<any>;

  // AI Assistant helpers
  aiGenerateScript?: (request: any) => Promise<any>;
  aiSuggestNames?: (request: any) => Promise<any>;
  aiBatchRenameAssets?: (request: any) => Promise<any>;
  aiPlanWorkflow?: (request: any) => Promise<any>;
  aiExecuteWorkflow?: (workflowSession: any) => Promise<any>;
  aiGenerateDocumentation?: (request: any) => Promise<any>;
  aiSearch?: (request: any) => Promise<any>;
  aiBuildSearchIndex?: (sourceFolder: string) => Promise<any>;
  aiAnalyzeLogs?: (logContent: string, context?: any) => Promise<any>;
  aiSuggestTutorial?: (request: any) => Promise<any>;
  aiGetRelatedConcepts?: (concept: string) => Promise<any>;
  aiGetStatus?: () => Promise<any>;
  aiGetConfig?: () => Promise<any>;
  aiUpdateConfig?: (config: any) => Promise<any>;
  aiSubmitFeedback?: (feedback: any) => Promise<any>;
  aiGetUsageStatistics?: () => Promise<any>;
  aiDiagnoseError?: (request: any) => Promise<any>;
  aiExplain?: (request: any) => Promise<any>;

  // AI Assistant Alternative API (simplified interface)
  aiAssistantGenerateScript?: (description: string) => Promise<any>;
  aiAssistantChat?: (message: string, context?: ChatContext) => Promise<ChatResponse>;
  aiAssistantExplainCode?: (code: string) => Promise<Explanation>;
  aiAssistantSuggestFixes?: (error: string, context?: any) => Promise<Fix[]>;
  aiAssistantRefactorCode?: (code: string, improvements?: string[]) => Promise<RefactoredCode>;
  aiAssistantParseIntent?: (userInput: string) => Promise<Intent>;
  aiAssistantAnalyzeImage?: (imagePath: string, question?: string) => Promise<ImageAnalysis>;
  aiAssistantSuggestNames?: (assetType: string, context: string) => Promise<any>;
  aiAssistantParseWorkflow?: (naturalLanguage: string) => Promise<any>;
  aiAssistantExecuteWorkflow?: (plan: any) => Promise<any>;
  aiAssistantGenerateReadme?: (projectData: any) => Promise<any>;
  aiAssistantDiagnoseError?: (errorLog: string, context: any) => Promise<any>;

  updateAnalyticsConfig: (config: any) => Promise<any>;

  // Advanced Analysis Capabilities
  analyzePatterns: (data: any) => Promise<any>;
  predictConflicts: (modA: string, modB: string) => Promise<any>;
  analyzeBottlenecks: (performanceData: any) => Promise<any>;
  analyzeMemory: (memoryData: any) => Promise<any>;
  buildCompatibilityMatrix: (compatibilityData: any[]) => Promise<any>;
  queryCompatibility: (modA: string, modB: string) => Promise<any>;
  trainConflictModel: (trainingData: any[]) => Promise<any>;
  getAnalysisStatus: () => Promise<any>;

  // Enhanced LLM Service
  llmGenerateWithExplainability: (messages: any[], config: any, includeExplainability: boolean) => Promise<any>;
  llmSaveModelVersion: (version: any) => Promise<any>;
  llmGetModelVersions: () => Promise<any>;
  llmCreateABTest: (test: any) => Promise<any>;
  llmGetPerformanceMetrics: (timeRange?: number) => Promise<any>;

  // Monitoring Service
  monitoringStart: () => Promise<any>;
  monitoringStop: () => Promise<any>;
  monitoringCreateAlertRule: (rule: any) => Promise<any>;
  monitoringGetAlertRules: () => Promise<any>;
  monitoringGetHealth: () => Promise<any>;
  monitoringGetMetrics: (name?: string, timeRange?: number) => Promise<any>;
  monitoringGetNotifications: (limit?: number) => Promise<any>;

  // Data Management Service
  dataCreateUserProfile: (userData: any) => Promise<any>;
  dataGetUserProfile: (userId: string) => Promise<any>;
  dataUpdateUserProfile: (userId: string, updates: any) => Promise<any>;
  dataSubmitGDPRRequest: (request: any) => Promise<any>;
  dataGetGDPRRequest: (requestId: string) => Promise<any>;
  dataRequestExport: (userId: string, options?: any) => Promise<any>;
  dataGetExport: (exportId: string) => Promise<any>;
  dataGetPrivacySettings: () => Promise<any>;
  dataUpdatePrivacySettings: (settings: any) => Promise<any>;

  // Scalability Service
  scalabilityGetCache: (key: string) => Promise<any>;
  scalabilitySetCache: (key: string, value: any, ttl?: number) => Promise<any>;
  scalabilitySubmitTask: (task: any) => Promise<any>;
  scalabilityGetTaskStatus: (taskId: string) => Promise<any>;
  scalabilityRegisterWorker: (workerId: string, capabilities: string[], type?: string) => Promise<any>;
  scalabilityGetAvailableWorkers: () => Promise<any>;

  // Notification listener for monitoring service
  onNotification: (callback: (notification: any) => void) => (() => void);
}

export interface VoiceChatPayload {
  text: string;
  history?: Array<{ role: 'user' | 'assistant'; content: string }>;
  workingMemory?: string;
  projectData?: Record<string, any> | null;
}

/**
 * Predictive Optimization Mining Engines
 */

// Load Order Optimization
export interface LoadOrderOptimizationMiningEngine {
  analyze: (performanceData: PerformanceData[]) => Promise<LoadOrderOptimization[]>;
  optimize: (currentOrder: string[], performanceData: PerformanceData[]) => Promise<OptimizedLoadOrder>;
  predictImpact: (proposedOrder: string[], performanceData: PerformanceData[]) => Promise<LoadOrderImpact>;
}

export interface LoadOrderOptimization {
  currentOrder: string[];
  suggestedOrder: string[];
  performanceImprovement: number;
  stabilityScore: number;
  conflictReduction: number;
  reasoning: string[];
}

export interface OptimizedLoadOrder {
  order: string[];
  expectedPerformanceGain: number;
  stabilityRating: number;
  conflictScore: number;
  implementationSteps: string[];
}

export interface LoadOrderConstraints {
  mustLoadBefore: Array<[string, string]>; // [modA, modB] - modA must load before modB
  mustLoadAfter: Array<[string, string]>;  // [modA, modB] - modA must load after modB
  incompatiblePairs: Array<[string, string]>; // mods that cannot be loaded together
  performancePriority: 'stability' | 'performance' | 'compatibility';
}

export interface SimpleHardwarePerformancePrediction {
  fpsImprovement: number;
  memoryUsageChange: number;
  loadTimeChange: number;
  stabilityScore: number;
  confidence: number;
}

// Texture Optimization
export interface TextureOptimizationMiningEngine {
  analyze: (ddsFiles: DDSFile[], hardwareProfile: HardwareProfile) => Promise<TextureOptimization[]>;
  recommendCompression: (texture: DDSFile) => Promise<CompressionRecommendation>;
  batchOptimize: (textures: DDSFile[]) => Promise<BatchOptimizationResult>;
}

export interface TextureOptimization {
  texturePath: string;
  currentFormat: string;
  recommendedFormat: string;
  compressionRatio: number;
  qualityImpact: number;
  performanceGain: number;
  memorySavings: number;
}

export interface CompressionRecommendation {
  originalFormat: string;
  recommendedFormat: 'DXT1' | 'DXT3' | 'DXT5' | 'BC7' | 'BC6H' | 'RGBA8';
  compressionSettings: {
    quality: number;
    mips: boolean;
    alpha: boolean;
  };
  expectedSavings: number;
  qualityLoss: number;
}

export interface BatchOptimizationResult {
  totalTextures: number;
  optimizedTextures: number;
  totalMemorySavings: number;
  averageQualityLoss: number;
  processingTime: number;
  recommendations: TextureOptimization[];
}

// Mesh Optimization
export interface MeshOptimizationMiningEngine {
  analyze: (nifFiles: NIFFile[], lodSettings: LODSettings) => Promise<MeshOptimization[]>;
  suggestLOD: (mesh: NIFFile, lodSettings: LODSettings) => Promise<LODSuggestion>;
  optimizeBatch: (meshes: NIFFile[], lodSettings: LODSettings) => Promise<BatchMeshOptimization>;
}

export interface MeshOptimization {
  meshPath: string;
  currentTriangles: number;
  recommendedTriangles: number;
  lodSuggestions: LODSuggestion[];
  performanceImpact: number;
  visualQualityLoss: number;
}

export interface LODSuggestion {
  distance: number;
  triangleReduction: number;
  quality: 'high' | 'medium' | 'low';
  performanceGain: number;
}

export interface LODSettings {
  maxDistance: number;
  qualityLevels: number;
  triangleBudget: number;
  performanceTarget: 'high' | 'medium' | 'low';
}

export interface BatchMeshOptimization {
  totalMeshes: number;
  optimizedMeshes: number;
  totalTriangleReduction: number;
  averagePerformanceGain: number;
  lodConfigurations: LODSuggestion[];
}

// INI Parameter Mining
export interface IniParameterMiningEngine {
  analyze: (iniFiles: INIFile[], hardwareProfile: HardwareProfile) => Promise<IniOptimization[]>;
  recommendSettings: (iniFile: INIFile, hardwareProfile: HardwareProfile) => Promise<INISettingsRecommendation>;
  validateConfiguration: (iniSettings: Record<string, any>, hardwareProfile: HardwareProfile) => Promise<ConfigurationValidation>;
}

export interface IniOptimization {
  iniPath: string;
  section: string;
  key: string;
  currentValue: string;
  recommendedValue: string;
  performanceImpact: number;
  stabilityImpact: number;
  reasoning: string;
}

export interface INISettingsRecommendation {
  settings: IniOptimization[];
  profile: string;
  expectedPerformanceGain: number;
  stabilityRating: number;
  compatibilityScore: number;
  warnings: string[];
}

export interface ConfigurationValidation {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  performanceScore: number;
  stabilityScore: number;
}

/**
 * Knowledge Graph Construction Mining Engines
 */

// Modding Knowledge Mining
export interface ModdingKnowledgeMiningEngine {
  mineFromSources: (sources: KnowledgeSource[]) => Promise<KnowledgeGraph>;
  extractInsights: (rawData: RawKnowledgeData[]) => Promise<ModdingInsight[]>;
  buildKnowledgeGraph: (insights: ModdingInsight[]) => Promise<KnowledgeGraph>;
}

export interface KnowledgeSource {
  id: string;
  type: 'forum' | 'wiki' | 'discord' | 'tutorial' | 'documentation';
  url: string;
  title: string;
  lastUpdated: number;
  credibility: number;
  content?: string;
  timestamp?: number;
}

export interface RawKnowledgeData {
  source: KnowledgeSource;
  topic: string;
  content: string;
  sentiment: number;
  relevance: number;
}

export interface ModdingInsight {
  id: string;
  type: 'solution' | 'warning' | 'optimization' | 'compatibility' | 'tutorial';
  title: string;
  description: string;
  confidence: number;
  sources: KnowledgeSource[];
  relatedMods?: string[];
  tags?: string[];
  timestamp?: number;
}

export interface KnowledgeGraph {
  nodes: KnowledgeNode[];
  edges: KnowledgeEdge[];
  insights: ModdingInsight[];
  lastUpdated: number;
}

export interface KnowledgeNode {
  id: string;
  type: 'concept' | 'problem' | 'solution' | 'tutorial' | 'tool' | 'technique';
  label: string;
  content: string;
  source: string;
  confidence: number;
  tags: string[];
  metadata: Record<string, any>;
}

export interface KnowledgeEdge {
  id: string;
  source: string;
  target: string;
  type: 'requires' | 'solves' | 'related' | 'prerequisite' | 'improves' | 'conflicts';
  weight: number;
  evidence: string[];
  metadata?: Record<string, any>;
}

// Patch Compatibility Mining
export interface PatchCompatibilityMiningEngine {
  analyzePatchCombinations: (patches: PatchData[]) => Promise<PatchCompatibilityGraph>;
  findCompatibleSets: (targetMods: string[]) => Promise<CompatiblePatchSet[]>;
  validatePatchSet: (patchSet: PatchData[]) => Promise<PatchValidation>;
}

export interface PatchData {
  id: string;
  name: string;
  targetMods: string[];
  changes: PatchChange[];
  compatibility: PatchCompatibility[];
  version: string;
  author: string;
}

export interface PatchChange {
  type: 'esp' | 'ini' | 'texture' | 'mesh' | 'script';
  target: string;
  modification: string;
  impact: number;
}

export interface PatchCompatibility {
  withPatch: string;
  compatibility: 'compatible' | 'incompatible' | 'requires_patch' | 'conflicts';
  reason: string;
  severity: 'low' | 'medium' | 'high';
  score?: number;
}

export interface PatchCompatibilityGraph {
  patches: PatchData[];
  compatibilityMatrix: Record<string, Record<string, PatchCompatibility>>;
  recommendedSets: CompatiblePatchSet[];
}

export interface CompatiblePatchSet {
  patches: string[];
  targetMods: string[];
  compatibilityScore: number;
  performanceImpact: number;
  stabilityRating: number;
  description: string;
}

export interface PatchValidation {
  isValid: boolean;
  conflicts: PatchConflict[];
  warnings: string[];
  performanceScore: number;
  compatibilityRating: number;
}

export interface PatchConflict {
  patchA: string;
  patchB: string;
  conflictType: string;
  severity: 'low' | 'medium' | 'high';
  resolution: string;
}

// Version Compatibility Mining
export interface VersionCompatibilityMiningEngine {
  trackCompatibility: (modVersions: ModVersionData[]) => Promise<VersionCompatibilityGraph>;
  predictCompatibility: (modA: string, versionA: string, modB: string, versionB: string) => Promise<CompatibilityPrediction>;
  findCompatibleVersions: (modList: string[]) => Promise<CompatibleVersionSet[]>;
}

export interface ModVersionData {
  modName: string;
  version: string;
  gameVersion: string;
  dependencies: VersionDependency[];
  incompatibilities: VersionIncompatibility[];
  reportedIssues: VersionIssue[];
  testResults: VersionTestResult[];
}

export interface VersionDependency {
  modName: string;
  versionRange: string;
  type: 'required' | 'optional' | 'recommended';
}

export interface VersionIncompatibility {
  modName: string;
  versionRange: string;
  reason: string;
  severity: 'low' | 'medium' | 'high';
}

export interface VersionIssue {
  issueType: 'crash' | 'bug' | 'performance' | 'compatibility';
  description: string;
  frequency: number;
  severity: 'low' | 'medium' | 'high';
  reportedBy: string[];
}

export interface VersionTestResult {
  tester: string;
  gameVersion: string;
  result: 'success' | 'partial' | 'failure';
  notes: string;
  timestamp: number;
}

export interface VersionCompatibilityGraph {
  mods: Record<string, ModVersionData[]>;
  compatibilityMatrix: Record<string, Record<string, CompatibilityPrediction>>;
  recommendedVersions: CompatibleVersionSet[];
}

export interface CompatibilityPrediction {
  compatibility: 'compatible' | 'incompatible' | 'unknown' | 'risky';
  confidence: number;
}

// --- Testing suite types ---
export type TestType = 
  | 'unit'           // Unit tests for scripts
  | 'integration'    // Integration tests
  | 'load-order'     // Load order validation
  | 'compatibility'  // Mod compatibility
  | 'performance'    // Performance benchmarks
  | 'regression'     // Regression detection
  | 'save-game'      // Save game compatibility
  | 'asset';         // Asset integrity

export interface TestParameters {
  [key: string]: any;
}

export interface ExpectedResult {
  type: 'pass' | 'fail' | 'value' | 'custom';
  value?: any;
  validator?: string; // Custom validation function
}

export interface Test {
  id: string;
  name: string;
  description: string;
  type: TestType;
  parameters: TestParameters;
  expected: ExpectedResult;
  timeout: number; // ms
}

export interface TestSuite {
  id: string;
  name: string;
  type: TestType;
  tests: Test[];
  created: number;
  lastRun?: number;
}

export interface TestResult {
  testId: string;
  testName?: string;
  status: 'pass' | 'fail' | 'skip' | 'error';
  duration: number; // milliseconds
  message?: string;
  error?: Error;
  actual?: any;
  expected?: any;
  stackTrace?: string;
}

export interface TestResults {
  suiteId: string;
  timestamp: number;
  duration: number; // total duration (ms)
  totalTests: number;
  passed: number;
  failed: number;
  skipped: number;
  results: TestResult[];
  summary: string; // human-readable summary
}

export interface Conflict {
  id?: string;
  type?: string;
  description?: string;
  severity?: 'low' | 'medium' | 'high' | 'critical';
  details?: any;
}

export interface LoadOrderTestResult extends TestResult {
  conflicts: Conflict[];
  missingMasters: string[];
  circularDependencies: string[][];
  recommendations: string[];
}

export interface IncompatibleMod {
  modName: string;
  reason: string;
  severity: 'minor' | 'major' | 'critical';
}

export interface CompatibilityTestResult extends TestResult {
  compatibleMods: string[];
  incompatibleMods: IncompatibleMod[];
  warnings: string[];
  saveable: boolean;
}

export interface CompilationError {
  script: string;
  line: number;
  column?: number;
  message: string;
}

export interface CompilationWarning {
  script: string;
  line: number;
  message: string;
  severity: 'low' | 'medium' | 'high';
}

export interface CompilationTestResult extends TestResult {
  compiledScripts: string[];
  errors: CompilationError[];
  warnings: CompilationWarning[];
}

export interface CorruptedAsset {
  path: string;
  type: string;
  error: string;
  recoverable: boolean;
}

export interface IntegrityTestResult extends TestResult {
  validAssets: string[];
  corruptedAssets: CorruptedAsset[];
  missingAssets: string[];
}

export interface Baseline {
  version: string;
  timestamp: number;
  results: TestResults;
  benchmarks: BenchmarkMetrics;
}

export interface MetricRegression {
  metric: string;
  baselineValue: number;
  currentValue: number;
  percentChange: number;
  acceptable: boolean;
}

export interface RegressionReport {
  regressionDetected: boolean;
  degradedTests: TestResult[];
  performanceRegressions: MetricRegression[];
  newFailures: TestResult[];
  summary: string;
}

export interface BenchmarkMetrics {
  fpsAverage: number;
  fpsMin: number;
  fpsMax: number;
  loadTime: number; // ms
  memoryUsage: number; // MB
  scriptLoad: number; // ms
  assetLoad: number; // ms
}

export interface ComparisonData {
  baseline: BenchmarkMetrics;
  current: BenchmarkMetrics;
  percentChange: Record<string, number>;
  regression: boolean;
}

export interface BenchmarkResult {
  modName: string;
  timestamp: number;
  metrics: BenchmarkMetrics;
  comparison?: ComparisonData;
}

export interface PluginLoadTime { plugin: string; loadTime: number; percentage: number }
export interface AssetLoadTime { assetType: string; loadTime: number; count: number; averagePerAsset: number }

export interface LoadTimeResult {
  totalTime: number; // ms
  pluginLoadTimes: PluginLoadTime[];
  assetLoadTimes: AssetLoadTime[];
  slowestPlugins: PluginLoadTime[];
}

export interface MemoryLeakResult {
  leakDetected: boolean;
  initialMemory: number; // MB
  finalMemory: number; // MB
  peakMemory: number; // MB
  leakRate: number; // MB per minute
  suspectedSources: string[];
}

export interface TestStep {
  action: 'spawn' | 'teleport' | 'execute-console' | 'wait' | 'interact' | 'screenshot';
  parameters: Record<string, any>;
  description: string;
}

export interface Assertion {
  type: 'equals' | 'not-equals' | 'greater-than' | 'less-than' | 'contains' | 'exists';
  actual: string; // Expression to evaluate (e.g. 'lastOutput', 'step[0]')
  expected: any;
  message: string;
}

export interface TestScript {
  name: string;
  steps: TestStep[];
  assertions: Assertion[];
  timeout: number; // ms
}

export interface ScriptResult { success: boolean; output?: string; runtimeMs?: number; error?: string }

export interface QuestFlowResult {
  questName: string;
  pathTaken: QuestStage[];
  completed: boolean;
  brokenStages: number[];
  warnings: string[];
  success: boolean;
}

export interface TestSummary {
  totalTests: number;
  passed: number;
  failed: number;
  skipped: number;
  duration: number;
  passRate: number; // 0..1
}

export interface TestReport {
  title: string;
  timestamp: number;
  summary: TestSummary;
  results: TestResults;
  regressions?: RegressionReport;
  recommendations: string[];
}

export type ExportFormat = 'json' | 'html' | 'pdf' | 'junit' | 'markdown';

export interface Error {
  name: string;
  message: string;
  stack?: string;
}

export interface CompatibleVersionSet {
  mods: Record<string, string>; // modName -> version
  compatibilityScore: number;
  stabilityRating: number;
  performanceScore: number;
  knownIssues: VersionIssue[];
}

// Hardware-Specific Mining
export interface HardwareSpecificMiningEngine {
  analyzeHardwareProfile: (hardware: HardwareProfile) => Promise<HardwareOptimization[]>;
  recommendSettings: (hardware: HardwareProfile, modList: string[]) => Promise<HardwareRecommendation>;
  predictPerformance: (hardware: HardwareProfile, loadOrder: string[]) => Promise<HardwarePerformancePrediction>;
}

export interface HardwareProfile {
  cpu: CPUInfo;
  gpu: GPUInfo;
  ram: RAMInfo;
  storage: StorageInfo;
  os: OSInfo;
}

export interface CPUInfo {
  model: string;
  cores: number;
  threads: number;
  baseClock: number;
  boostClock: number;
  cache: number;
}

export interface GPUInfo {
  model: string;
  vram: number;
  driverVersion: string;
  dxVersion: string;
  rayTracing: boolean;
}

export interface RAMInfo {
  total: number;
  speed: number;
  type: string;
  channels: number;
}

export interface StorageInfo {
  type: 'HDD' | 'SSD' | 'NVMe';
  readSpeed: number;
  writeSpeed: number;
  totalSpace: number;
  availableSpace: number;
}

export interface OSInfo {
  name: string;
  version: string;
  architecture: 'x64' | 'x86' | 'arm64';
}



export interface HardwareRecommendation {
  iniSettings: Record<string, any>;
  loadOrderAdjustments: string[];
  textureSettings: TextureOptimization[];
  meshSettings: MeshOptimization[];
  expectedPerformance: HardwarePerformancePrediction;
}

export interface DetailedHardwarePerformancePrediction {
  averageFps: number;
  minimumFps: number;
  memoryUsage: number;
  loadTime: number;
  stabilityScore: number;
  bottlenecks: string[];
}

// Predictive Optimization Mining Engines
export interface LoadOrderOptimizationMiningEngine {
  analyze: (performanceData: PerformanceData[]) => Promise<LoadOrderOptimization[]>;
  optimize: (currentOrder: string[], performanceData: PerformanceData[]) => Promise<OptimizedLoadOrder>;
  predictImpact: (proposedOrder: string[], performanceData: PerformanceData[]) => Promise<LoadOrderImpact>;
}

export interface TextureOptimizationMiningEngine {
  analyze: (ddsFiles: DDSFile[], hardwareProfile: HardwareProfile) => Promise<TextureOptimization[]>;
  recommendCompression: (texture: DDSFile) => Promise<CompressionRecommendation>;
  batchOptimize: (textures: DDSFile[]) => Promise<BatchOptimizationResult>;
}

export interface MeshOptimizationMiningEngine {
  analyze: (nifFiles: NIFFile[], lodSettings: LODSettings) => Promise<MeshOptimization[]>;
  suggestLOD: (mesh: NIFFile, lodSettings: LODSettings) => Promise<LODSuggestion>;
  optimizeBatch: (meshes: NIFFile[], lodSettings: LODSettings) => Promise<BatchMeshOptimization>;
}

export interface IniParameterMiningEngine {
  analyze: (iniFiles: INIFile[], hardwareProfile: HardwareProfile) => Promise<IniOptimization[]>;
  recommendSettings: (iniFile: INIFile, hardwareProfile: HardwareProfile) => Promise<INISettingsRecommendation>;
  validateConfiguration: (iniSettings: Record<string, any>, hardwareProfile: HardwareProfile) => Promise<ConfigurationValidation>;
}

// Knowledge Graph Construction Mining Engines
export interface ModdingKnowledgeMiningEngine {
  mineFromSources: (sources: KnowledgeSource[]) => Promise<KnowledgeGraph>;
  extractInsights: (rawData: RawKnowledgeData[]) => Promise<ModdingInsight[]>;
  buildKnowledgeGraph: (insights: ModdingInsight[]) => Promise<KnowledgeGraph>;
}

// Additional supporting types for Predictive Optimization
export interface LoadOrderOptimization {
  currentOrder: string[];
  optimizedOrder: string[];
  performanceGain: number;
  stabilityImprovement: number;
  conflictReduction: number;
  reasoning: string[];
}

export interface OptimizedLoadOrder {
  order: string[];
  expectedPerformance: HardwarePerformancePrediction;
  conflictScore: number;
  stabilityRating: number;
}

export interface LoadOrderImpact {
  fpsImpact: number;
  memoryImpact: number;
  loadTimeImpact: number;
  stabilityImpact: number;
}

export interface TextureOptimization {
  texturePath: string;
  currentFormat: string;
  recommendedFormat: string;
  expectedSavings: number;
  performanceGain: number;
  compatibilityNotes: string[];
}

export interface CompressionRecommendation {
  texturePath: string;
  suggestedFormat: string;
  suggestedResolution: { width: number; height: number };
  performanceGain: number;
  fileSizeReduction: number;
  qualityImpact: number;
  compatibility: string[];
}

export interface BatchOptimizationResult {
  optimizations: TextureOptimization[];
  totalSavings: number;
  averagePerformanceGain: number;
  incompatibleTextures: string[];
}

export interface LODSettings {
  baseDistance: number;
  lod1Distance: number;
  lod2Distance: number;
  quality: 'low' | 'medium' | 'high';
  generateFromHighPoly: boolean;
}

export interface MeshOptimization {
  meshPath: string;
  currentVertexCount: number;
  optimizedVertexCount: number;
  lodLevels: number;
  expectedPerformanceGain: number;
  qualityLoss: number;
  recommendations: string[];
}

export interface LODSuggestion {
  meshPath: string;
  lodLevels: LODLevel[];
  totalReduction: number;
  performanceImpact: number;
  generationMethod: string;
}

export interface LODLevel {
  level: number;
  distance: number;
  vertexCount: number;
  triangleCount: number;
  quality: number;
}

export interface BatchMeshOptimization {
  optimizations: MeshOptimization[];
  totalVertexReduction: number;
  averagePerformanceGain: number;
  lodGenerationStats: LODGenerationStats;
}

export interface LODGenerationStats {
  totalMeshes: number;
  successfulGenerations: number;
  failedGenerations: number;
  averageLODsPerMesh: number;
}

export interface IniOptimization {
  iniPath: string;
  section: string;
  key: string;
  currentValue: string;
  recommendedValue: string;
  performanceImpact: number;
  stabilityImpact: number;
  reasoning: string;
}

export interface INISettingsRecommendation {
  settings: IniOptimization[];
  profile: string;
  expectedPerformanceGain: number;
  compatibilityWarnings: string[];
}

export interface ConfigurationValidation {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  performanceScore: number;
  recommendations: string[];
}

// Additional supporting types for Knowledge Graph Construction
export interface KnowledgeSource {
  id: string;
  type: 'forum' | 'wiki' | 'discord' | 'tutorial' | 'documentation';
  url: string;
  title: string;
  lastUpdated: number;
  credibility: number;
  tags: string[];
}

export interface KnowledgeGraph {
  nodes: KnowledgeNode[];
  edges: KnowledgeEdge[];
  metadata: {
    totalNodes: number;
    totalEdges: number;
    sourcesProcessed: number;
    lastUpdated: string;
    confidence: number;
  };
}

export interface KnowledgeNode {
  id: string;
  type: 'concept' | 'problem' | 'solution' | 'tutorial' | 'tool' | 'technique';
  label: string;
  content: string;
  source: string;
  confidence: number;
  tags: string[];
  metadata: Record<string, any>;
}

export interface KnowledgeEdge {
  id: string;
  source: string;
  target: string;
  type: 'requires' | 'solves' | 'related' | 'prerequisite' | 'improves' | 'conflicts';
  weight: number;
  evidence: string[];
  metadata?: Record<string, any>;
}

export interface RawKnowledgeData {
  source: KnowledgeSource;
  content: string;
  extractedAt: number;
  processingMetadata: Record<string, any>;
}

export interface ModdingInsight {
  id: string;
  type: 'solution' | 'warning' | 'optimization' | 'compatibility' | 'tutorial';
  title: string;
  description: string;
  confidence: number;
  sources: KnowledgeSource[];
  relatedNodes: string[];
  actionableSteps: string[];
  metadata: Record<string, any>;
}

// Update AdvancedAnalysisEngine interface
export interface AdvancedAnalysisEngine {
  patternRecognition: PatternRecognitionEngine;
  conflictPrediction: ConflictPredictionEngine;
  bottleneckMining: BottleneckMiningEngine;
  memoryAnalysis: MemoryAnalysisEngine;
  compatibilityMining: CompatibilityMiningEngine;
  formIdRelationshipMining: FormIDRelationshipMiningEngine;
  cellWorldspaceMining: CellWorldspaceMiningEngine;
  questObjectiveMining: QuestObjectiveMiningEngine;
  perkPowerMining: PerkPowerMiningEngine;
  loadOrderOptimization: LoadOrderOptimizationMiningEngine;
  textureOptimization: TextureOptimizationMiningEngine;
  meshOptimization: MeshOptimizationMiningEngine;
  iniParameterMining: IniParameterMiningEngine;
  moddingKnowledgeMining: ModdingKnowledgeMiningEngine;
  patchCompatibilityMining: PatchCompatibilityMiningEngine;
  versionCompatibilityMining: VersionCompatibilityMiningEngine;
  hardwareSpecificMining: HardwareSpecificMiningEngine;
  runComprehensiveAnalysis(data: AnalysisData): Promise<{
    patterns: PatternRecognitionResult;
    bottlenecks: BottleneckAnalysis;
    memory: MemoryAnalysis;
    compatibilityMatrix: CompatibilityMatrix;
  }>;
}

/**
 * Phase 2 Mining Engines - Advanced AI-driven analysis
 */

// Contextual Mining Engine Types
// (UserInteraction was moved above and merged)

export interface MiningUserProfile {
  preferences: {
    visualQuality: number;
    performancePriority: number;
    modCategories: Record<string, number>;
    complexityTolerance: number;
    automationPreference: number;
    learningStyle: 'visual' | 'textual' | 'interactive';
  };
  behaviorPatterns: MiningBehaviorPattern[];
  performanceTolerance: {
    minFPS: number;
    maxMemoryUsage: number;
    acceptableLoadTime: number;
  };
  modPreferences: Record<string, number>;
  settingPreferences: Record<string, any>;
  contextualPatterns: ContextualPattern[];
  learningProgress: {
    interactionsProcessed: number;
    feedbackIncorporated: number;
    patternsLearned: number;
    adaptationCycles: number;
  };
  lastUpdated: number;
}

export interface MiningBehaviorPattern {
  pattern: string;
  frequency: number;
  contexts: string[];
  successRate: number;
  lastObserved: number;
  confidence: number;
}

export interface ContextualPattern {
  context: string;
  preferences: Record<string, any>;
  frequency: number;
  effectiveness: number;
}

export interface PreferenceAnalysis {
  visualQuality?: number;
  performancePriority?: number;
  modCategories?: Record<string, number>;
  complexityTolerance?: number;
  automationPreference?: number;
  learningStyle?: string;
  confidence: number;
  preferences?: any;
  trends?: any;
  lastAnalyzed?: number;
  dataPoints?: number;
}

export interface ContextualRecommendation {
  type: any;
  item?: string;
  confidence: number;
  relevance: number; // Added
  reasoning?: string[];
  contextRelevance?: number;
  expectedImpact?: {
    performance: number;
    stability: number;
    compatibility: number;
  };
  id?: string;
  title?: string;
  description?: string;
  expectedOutcome?: string;
  actionRequired?: string;
  personalizationScore?: number;
  category?: string;
  userPreferenceAlignment?: number;
  prerequisites?: string[];
  alternatives?: string[];
}

// (UserFeedback was moved above and merged)

// (SessionContext was moved above and merged)

// (ContextTransition was moved above and merged)

export interface ContextHistory {
  sessionId: string;
  context: SessionContext;
  timestamp: number;
  duration?: number;
  transitions: ContextTransition[];
}

// (TransitionAnalysis was moved above and merged)

// (AdaptiveStrategy was moved above and merged)

export interface ContextualInsight {
  id: string;
  type: string;
  title: string;
  description: string;
  confidence: number;
  impact?: string;
  actionable?: boolean;
  category?: string;
  context?: Record<string, any>;
  recommendations?: any[];
  timestamp?: number;
}

// Contextual Mining Engine Interface
export interface AdvancedContextualMiningEngine {
  // Core lifecycle methods
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<any>;

  // User profiling methods
  recordUserInteraction(interaction: UserInteraction): Promise<void>;
  buildUserProfile(): Promise<UserProfile>;
  analyzeUserPreferences(): Promise<PreferenceAnalysis>;

  // Contextual analysis methods
  updateUserContext(context: UserContext): Promise<void>;
  generateContextualRecommendations(context: Record<string, any>): Promise<ContextualRecommendation[]>;

  // Adaptive learning methods
  incorporateUserFeedback(feedback: UserFeedback): Promise<void>;
  analyzeBehaviorPatterns(): Promise<{
    modCategoryPreferences: Record<string, number>;
    contextualBehaviors: Record<string, any>;
    successPatterns: Record<string, number>;
    riskTolerance: number;
  }>;

  // Personalization methods
  generatePersonalizedRecommendations(): Promise<ContextualRecommendation[]>;

  // Context awareness methods
  updateSessionContext(context: SessionContext): Promise<void>;
  getContextHistory(): Promise<ContextHistory[]>;
  recordContextTransition(transition: ContextTransition): Promise<void>;
  analyzeContextTransitions(): Promise<TransitionAnalysis>;
}

// Longitudinal Mining Engine Types
export interface LongitudinalHistoricalData {
  sessionId: string;
  timestamp: number;
  mods: string[];
  fps: number;
  memoryUsage: number;
  loadTime: number;
  performanceMetrics: PerformanceMetric;
  context: Record<string, any>;
}

export interface AdvancedPerformanceTrend {
  period: string;
  direction: 'improving' | 'degrading' | 'stable';
  magnitude: number;
  confidence: number;
  factors: string[];
  recommendations: string[];
}

export interface AdvancedTrendData {
  timestamp: number;
  value: number;
  context: Record<string, any>;
}

export interface AdvancedPerformanceChange {
  timestamp: number;
  type: 'improvement' | 'degradation';
  magnitude: number;
  causes: string[];
  confidence: number;
}

export interface AdvancedDegradationAlert {
  id: string;
  timestamp: number;
  severity: 'low' | 'medium' | 'high' | 'critical';
  type: 'performance' | 'stability' | 'compatibility';
  description: string;
  affectedMods: string[];
  recommendedActions: string[];
  confidence: number;
  context: Record<string, any>;
}

export interface AdvancedFuturePerformancePrediction {
  timestamp: number;
  predictionHorizon: number; // days
  predictedFPS: number;
  predictedMemoryUsage: number;
  confidence: number;
  riskFactors: string[];
  recommendations: string[];
  context: Record<string, any>;
}

export interface AdvancedSessionData {
  sessionId: string;
  startTime: number;
  endTime: number;
  mods: string[];
  peakVRAM: number;
  peakRAM: number;
  averageFPS: number;
  performanceMetrics?: PerformanceMetric;
  context?: Record<string, any>;
}

export interface AdvancedLongitudinalModChange {
  modName: string;
  type: 'added' | 'removed' | 'updated';
  version?: string;
  timestamp: number;
  impact: Record<string, any>;
}

export interface AdvancedUpdateImpactAnalysis {
  modName: string;
  currentVersion: string;
  newVersion: string;
  impact: {
    performance: number;
    compatibility: number;
    stability: number;
  };
  riskLevel: 'low' | 'medium' | 'high';
  recommendations: string[];
  confidence: number;
  context: Record<string, any>;
}

// Longitudinal Mining Engine Interface
export interface AdvancedLongitudinalMiningEngine {
  // Core lifecycle methods
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<any>;

  // Performance tracking methods
  trackPerformanceOverTime(): Promise<AdvancedPerformanceTrend[]>;
  detectPerformanceDegradation(): Promise<AdvancedDegradationAlert[]>;
  predictFuturePerformance(): Promise<AdvancedFuturePerformancePrediction>;
  analyzeModUpdateImpact(updates: AdvancedLongitudinalModChange[]): Promise<AdvancedUpdateImpactAnalysis[]>;
}

// Hardware-Aware Mining Engine Types
export interface AdvancedHardwareProfile {
  cpu: AdvancedCPUInfo;
  gpu: AdvancedGPUInfo;
  ram: AdvancedRAMInfo;
  storage: AdvancedStorageInfo;
  os: AdvancedOSInfo;
  bottlenecks: string[];
  optimizationScore: number;
}

export interface AdvancedHardwareCompatibility {
  modName: string;
  compatibility: 'excellent' | 'good' | 'fair' | 'poor' | 'incompatible';
  requirements: AdvancedHardwareRequirements;
  recommendations: AdvancedHardwareRecommendation[];
  performanceImpact: Record<string, any>;
}

export interface AdvancedHardwareRecommendation {
  type: 'setting' | 'mod' | 'configuration';
  item: string;
  action: 'enable' | 'disable' | 'adjust' | 'replace';
  value?: any;
  reasoning: string;
  expectedImpact: Record<string, any>;
  priority: 'low' | 'medium' | 'high';
}

export interface AdvancedHardwarePerformancePrediction {
  scenario: string;
  predictedFPS: number;
  predictedMemoryUsage: number;
  bottleneck: string;
  recommendations: AdvancedHardwareRecommendation[];
  confidence: number;
}

export interface AdvancedHardwareOptimization {
  category: 'cpu' | 'gpu' | 'memory' | 'storage' | 'settings';
  optimizations: AdvancedHardwareRecommendation[];
  expectedGain: number;
  riskLevel: 'low' | 'medium' | 'high';
  implementationDifficulty: 'easy' | 'medium' | 'hard';
}

export interface AdvancedHardwareRequirements {
  minCPU?: string;
  minGPU?: string;
  minRAM?: number;
  minStorage?: number;
  recommendedCPU?: string;
  recommendedGPU?: string;
  recommendedRAM?: number;
  recommendedStorage?: number;
}

export interface AdvancedCPUInfo {
  model: string;
  cores: number;
  threads: number;
  frequency: number;
  cache: number;
  architecture: string;
}

export interface AdvancedGPUInfo {
  model: string;
  vram: number;
  driverVersion: string;
  api: 'directx' | 'vulkan' | 'opengl';
  performanceScore: number;
}

export interface AdvancedRAMInfo {
  total: number;
  available: number;
  speed: number;
  type: string;
}

export interface AdvancedStorageInfo {
  type: 'hdd' | 'ssd' | 'nvme';
  total: number;
  available: number;
  readSpeed: number;
  writeSpeed: number;
}

export interface AdvancedOSInfo {
  name: string;
  version: string;
  architecture: string;
  pageFileSize?: number;
}

// Hardware-Aware Mining Engine Interface
export interface AdvancedHardwareAwareMiningEngine {
  // Core lifecycle methods
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<AdvancedPhase2MiningResult>;

  // Hardware analysis methods
  analyzeHardwareProfile(): Promise<AdvancedHardwareProfile>;
  checkModCompatibility(modName: string, requirements: AdvancedHardwareRequirements): Promise<AdvancedHardwareCompatibility>;
  generateHardwareRecommendations(profile: AdvancedHardwareProfile): Promise<AdvancedHardwareRecommendation[]>;
  predictPerformanceImpact(changes: AdvancedHardwareRecommendation[]): Promise<AdvancedHardwarePerformancePrediction>;
  optimizeForHardware(profile: AdvancedHardwareProfile): Promise<AdvancedHardwareOptimization[]>;
}

// ML Conflict Prediction Engine Types
export interface ConflictPattern {
  id: string;
  type: 'load_order' | 'compatibility' | 'resource' | 'script';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  affectedMods: string[];
  confidence: number;
  evidence: string[];
  solutions: ConflictSolution[];
}

export interface ConflictSolution {
  type: 'reorder' | 'disable' | 'replace' | 'patch';
  description: string;
  affectedMods: string[];
  expectedOutcome: Record<string, any>;
  riskLevel: 'low' | 'medium' | 'high';
  implementationSteps: string[];
}

export interface AdvancedConflictPrediction {
  modCombination: string[];
  predictedConflicts: ConflictPattern[];
  overallRisk: 'low' | 'medium' | 'high' | 'critical';
  confidence: number;
  conflictSolutions: ConflictSolution[];
  context: Record<string, any>;
}

export interface MLModelMetrics {
  accuracy: number;
  precision: number;
  recall: number;
  f1Score: number;
  trainingDataSize: number;
  lastTrained: number;
  modelVersion: string;
}

export interface TrainingData {
  modCombination: string[];
  conflicts: ConflictPattern[];
  resolution: ConflictSolution;
  outcome: 'success' | 'partial' | 'failure';
  feedback?: string;
}

// ML Conflict Prediction Engine Interface
export interface AdvancedMLConflictPredictionEngine {
  // Core lifecycle methods
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<AdvancedPhase2MiningResult>;

  // ML analysis methods
  predictConflicts(modCombination: string[]): Promise<AdvancedConflictPrediction>;
  analyzeConflictPatterns(): Promise<ConflictPattern[]>;
  generateConflictSolutions(conflicts: ConflictPattern[]): Promise<ConflictSolution[]>;
  trainModel(trainingData: TrainingData[]): Promise<MLModelMetrics>;
  incorporateFeedback(predictionId: string, outcome: 'accepted' | 'rejected', feedback?: string): Promise<void>;
}

// Performance Bottleneck Detection Engine Types
export interface AdvancedBottleneckAnalysis {
  primaryBottleneck: string;
  secondaryBottlenecksList: string[];
  severity: 'low' | 'medium' | 'high' | 'critical';
  impact: {
    fps: number;
    memory: number;
    loadTime: number;
  };
  recommendations: BottleneckSolution[];
  confidence: number;
  context: Record<string, any>;
}

export interface BottleneckSolution {
  type: 'hardware' | 'software' | 'configuration' | 'mod';
  description: string;
  expectedImprovement: Record<string, number>;
  implementationDifficulty: 'easy' | 'medium' | 'hard';
  riskLevel: 'low' | 'medium' | 'high';
  prerequisites: string[];
}

export interface SystemBottleneck {
  component: 'cpu' | 'gpu' | 'memory' | 'storage' | 'network';
  utilization: number;
  threshold: number;
  isBottleneck: boolean;
  recommendations: BottleneckSolution[];
}

export interface PerformanceOptimization {
  category: string;
  optimizations: BottleneckSolution[];
  expectedGain: number;
  implementationOrder: string[];
  dependencies: string[];
}

// Performance Bottleneck Detection Engine Interface
export interface AdvancedPerformanceBottleneckDetectionEngine {
  // Core lifecycle methods
  start(): Promise<void>;
  stop(): Promise<void>;
  getStatus(): Promise<MiningStatus>;
  getResults(): Promise<AdvancedPhase2MiningResult>;

  // Bottleneck analysis methods
  analyzeBottlenecks(performanceData: PerformanceMetric): Promise<AdvancedBottleneckAnalysis>;
  identifyBottlenecks(systemInfo: any): Promise<SystemBottleneck[]>;
  generateOptimizationStrategies(bottlenecks: SystemBottleneck[]): Promise<PerformanceOptimization[]>;
  predictOptimizationImpact(optimizations: PerformanceOptimization[]): Promise<Record<string, any>>;
}

// Phase 2 Mining Result
export interface AdvancedPhase2MiningResult {
  engine: string;
  timestamp: number;
  insights: any[];
  recommendations: any[];
  predictions: any[];
  metrics: Record<string, any>;
  metadata: Record<string, any>;
}

/**
 * Extend Window interface to include our Electron API
 */
declare global {
  interface Window {
    electronAPI: ElectronAPI;
  }
}

// ===== ADVANCED FEATURES: Enhanced ML, Monitoring, Data Management, Scalability =====

/**
 * Enhanced LLM Service Types
 */
export interface LLMMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

export interface LLMConfig {
  provider: 'groq' | 'openai' | 'ollama';
  model?: string;
  temperature?: number;
  maxTokens?: number;
  version?: string;
}

export interface ModelVersion {
  id: string;
  provider: string;
  model: string;
  version: string;
  createdAt: number;
  performanceMetrics: {
    accuracy: number;
    latency: number;
    cost: number;
    userSatisfaction: number;
  };
  isActive: boolean;
  metadata: Record<string, any>;
}

export interface ABTestVariant {
  id: string;
  name: string;
  config: LLMConfig;
  weight: number;
  metrics: {
    impressions: number;
    conversions: number;
    satisfaction: number;
  };
}

export interface ABTest {
  id: string;
  name: string;
  variants: ABTestVariant[];
  startDate: number;
  endDate?: number;
  status: 'active' | 'completed' | 'paused';
  targetMetric: 'satisfaction' | 'accuracy' | 'latency';
}

export interface ModelExplainabilityResult {
  response: string;
  confidence: number;
  reasoning: string[];
  alternativeResponses: Array<{
    text: string;
    probability: number;
    reasoning: string;
  }>;
  biasAnalysis: {
    detectedBiases: string[];
    mitigationStrategies: string[];
  };
  sources: Array<{
    type: 'training_data' | 'knowledge_base' | 'context';
    relevance: number;
    content: string;
  }>;
}

/**
 * Monitoring Service Types
 */
export interface AlertRule {
  id: string;
  name: string;
  condition: {
    metric: string;
    operator: '>' | '<' | '>=' | '<=' | '==' | '!=';
    threshold: number;
    duration?: number;
  };
  severity: 'low' | 'medium' | 'high' | 'critical';
  enabled: boolean;
  cooldown: number;
  lastTriggered?: number;
  channels: ('notification' | 'websocket' | 'log')[];
}

export interface HealthMetric {
  name: string;
  value: number;
  unit: string;
  timestamp: number;
  status: 'healthy' | 'warning' | 'critical';
  metadata?: Record<string, any>;
}

export interface SystemHealth {
  cpuUsage: number;
  memoryUsage: number;
  diskUsage: number;
  networkActivity: number;
  miningEngineStatus: 'active' | 'idle' | 'error';
  activeConnections: number;
  uptime: number;
  lastUpdate: number;
}

export interface NotificationMessage {
  id: string;
  type: 'alert' | 'info' | 'warning' | 'success';
  title: string;
  message: string;
  timestamp: number;
  data?: any;
  actions?: Array<{
    label: string;
    action: string;
    data?: any;
  }>;
}

/**
 * Data Management Service Types
 */
export interface AccountUserProfile {
  id: string;
  anonymizedId: string;
  preferences: {
    theme: 'light' | 'dark' | 'auto';
    language: string;
    notifications: boolean;
    analytics: boolean;
  };
  usageStats: {
    sessionsCount: number;
    totalTimeSpent: number;
    lastActivity: number;
    favoriteFeatures: string[];
  };
  moddingHistory: {
    projectsCreated: number;
    modsDownloaded: number;
    toolsUsed: string[];
    skillLevel: 'beginner' | 'intermediate' | 'advanced';
  };
  createdAt: number;
  lastUpdated: number;
  consentGiven: boolean;
  dataRetentionPeriod: number;
}

export interface DataExport {
  id: string;
  userId: string;
  requestedAt: number;
  completedAt?: number;
  format: 'json' | 'csv' | 'xml';
  includesPersonalData: boolean;
  includesAnalytics: boolean;
  includesUsageData: boolean;
  downloadUrl?: string;
  expiresAt: number;
}

export interface GDPRRequest {
  id: string;
  userId: string;
  type: 'access' | 'rectification' | 'erasure' | 'portability' | 'restriction' | 'objection';
  status: 'pending' | 'processing' | 'completed' | 'rejected';
  requestedAt: number;
  completedAt?: number;
  reason?: string;
  data?: any;
}

export interface PrivacySettings {
  dataCollectionEnabled: boolean;
  analyticsEnabled: boolean;
  crashReportingEnabled: boolean;
  personalizationEnabled: boolean;
  dataRetentionDays: number;
  anonymizeByDefault: boolean;
  exportDataOnRequest: boolean;
  autoDeleteOldData: boolean;
}

/**
 * Scalability Service Types
 */
export interface CacheEntry {
  key: string;
  value: any;
  expiresAt?: number;
  lastAccessed: number;
  accessCount: number;
  size: number;
}

export interface DistributedTask {
  id: string;
  type: string;
  payload: any;
  priority: 'low' | 'medium' | 'high' | 'critical';
  createdAt: number;
  assignedTo?: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  result?: any;
  error?: string;
  retries: number;
  maxRetries: number;
  timeout: number;
}

export interface WorkerNode {
  id: string;
  type: 'cpu' | 'gpu' | 'io';
  capabilities: string[];
  status: 'idle' | 'busy' | 'offline';
  lastHeartbeat: number;
  tasksProcessed: number;
  performance: {
    avgResponseTime: number;
    successRate: number;
    currentLoad: number;
  };
}

/**
 * CK Crash Prevention System Types
 */
export interface CKValidationInput {
  espPath: string;
  modName?: string;
  cellCount?: number;
}

export interface CKValidationResult {
  safe: boolean;
  issues: ValidationIssue[];
  warnings: ValidationWarning[];
  recommendations: string[];
  estimatedMemoryUsage: number;
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
}

export interface ValidationIssue {
  type: 'file_size' | 'memory' | 'known_mod' | 'missing_master' | 'corrupted_mesh';
  severity: 'warning' | 'error' | 'critical';
  message: string;
  fix?: string;
  cellId?: string;
}

export interface ValidationWarning {
  message: string;
  recommendation: string;
}

export interface CKMonitoringSession {
  id: string;
  processId: number;
  startTime: number;
  status: 'running' | 'frozen' | 'crashed' | 'completed';
  currentCell?: string;
  cellsProcessed: number;
  totalCells?: number;
}

export interface CKHealthMetrics {
  memoryUsage: number;
  cpuUsage: number;
  responding: boolean;
  uptime: number;
  logErrors: string[];
}

export interface CrashDiagnosis {
  exceptionCode?: string;
  exceptionType: 'access_violation' | 'memory_error' | 'timeout' | 'unknown';
  problematicCell?: string;
  knownIssue?: KnownCKIssue;
  rootCause: string;
  fixSteps: string[];
  relatedKnowledgeArticles: string[];
}

export interface KnownCKIssue {
  id: string;
  name: string;
  description: string;
  affectedMods: string[];
  solution: string;
  workaround?: string;
}

export interface PreventionPlan {
  priority: 'low' | 'medium' | 'high';
  steps: PreventionStep[];
  estimatedTime: number;
}

export interface PreventionStep {
  id: string;
  title: string;
  description: string;
  tool?: string;
  command?: string;
  completed: boolean;
}

// ============================================================================
// QUEST EDITOR TYPES
// ============================================================================

export type QuestType = 
  | 'main'          // Main storyline
  | 'side'          // Side quest
  | 'radiant'       // Procedural/repeatable
  | 'companion'     // Companion quest
  | 'faction'       // Faction questline
  | 'misc';         // Miscellaneous objective

export interface Quest {
  id: string;
  name: string;
  description: string;
  type: QuestType;
  priority: number;
  stages: QuestStage[];
  aliases: QuestAlias[];
  properties: QuestProperty[];
  script?: string;
}

export interface QuestProperty {
  name: string;
  type: 'ObjectReference' | 'Int' | 'Float' | 'Bool' | 'String';
  value: any;
}

export interface QuestStage {
  index: number;
  logEntry?: string;
  objectives: QuestObjective[];
  conditions: Condition[];
  resultScript?: string;
  flags: StageFlags;
}

export interface StageFlags {
  startGameEnabled: boolean;
  completeQuest: boolean;
  failQuest: boolean;
  shutDownStage: boolean;
}

export interface Condition {
  function: string; // GetStage, GetItemCount, etc.
  parameters: any[];
  operator: '==' | '!=' | '>' | '<' | '>=' | '<=';
  value: any;
  runOnTarget?: boolean;
}

export interface QuestObjective {
  id: string;
  displayText: string;
  target?: string; // RefID or Alias
  targetCount?: number;
  completed: boolean;
  conditions: Condition[];
}

export interface QuestAlias {
  name: string;
  type: 'reference' | 'location' | 'item';
  fillType: 'specific' | 'unique' | 'find' | 'create';
  conditions: Condition[];
}

export interface ValidationWarning {
  message: string;
  recommendation: string;
}

export interface CKMonitoringSession {
  id: string;
  processId: number;
  startTime: number;
  status: 'running' | 'frozen' | 'crashed' | 'completed';
  currentCell?: string;
  cellsProcessed: number;
  totalCells?: number;
}

export interface CKHealthMetrics {
  memoryUsage: number;
  cpuUsage: number;
  responding: boolean;
  uptime: number;
  logErrors: string[];
}

export interface CrashDiagnosis {
  exceptionCode?: string;
  exceptionType: 'access_violation' | 'memory_error' | 'timeout' | 'unknown';
  problematicCell?: string;
  knownIssue?: KnownCKIssue;
  rootCause: string;
  fixSteps: string[];
  relatedKnowledgeArticles: string[];
}

export interface KnownCKIssue {
  id: string;
  name: string;
  description: string;
  affectedMods: string[];
  solution: string;
  workaround?: string;
}

export interface PreventionPlan {
  priority: 'low' | 'medium' | 'high';
  steps: PreventionStep[];
  estimatedTime: number;
}

export interface PreventionStep {
  id: string;
  title: string;
  description: string;
  tool?: string;
  command?: string;
  completed: boolean;
}

// ============================================================================
// QUEST EDITOR TYPES
// ============================================================================

         // Miscellaneous objective

export interface Quest {
  id: string;
  name: string;
  description: string;
  type: QuestType;
  priority: number;
  stages: QuestStage[];
  aliases: QuestAlias[];
  properties: QuestProperty[];
  script?: string;
}

export interface QuestProperty {
  name: string;
  type: 'ObjectReference' | 'Int' | 'Float' | 'Bool' | 'String';
  value: any;
}

export interface QuestStage {
  index: number;
  logEntry?: string;
  objectives: QuestObjective[];
  conditions: Condition[];
  resultScript?: string;
  flags: StageFlags;
}

export interface StageFlags {
  startGameEnabled: boolean;
  completeQuest: boolean;
  failQuest: boolean;
  shutDownStage: boolean;
}

export interface Condition {
  function: string; // GetStage, GetItemCount, etc.
  parameters: any[];
  operator: '==' | '!=' | '>' | '<' | '>=' | '<=';
  value: any;
  runOnTarget?: boolean;
}

export interface QuestObjective {
  id: string;
  displayText: string;
  target?: string; // RefID or Alias
  targetCount?: number;
  completed: boolean;
  conditions: Condition[];
}

export interface QuestAlias {
  name: string;
  type: 'reference' | 'location' | 'item';
  fillType: 'specific' | 'unique' | 'find' | 'create';
  conditions: Condition[];
}

export type EmotionType = 
  | 'happy' | 'sad' | 'angry' | 'fear' | 'disgust' 
  | 'surprise' | 'neutral' | 'custom';

export interface DialogueBranch {
  id: string;
  npc: string;
  topic: string;
  priority: number;
  nodes: DialogueNode[];
  quest?: string;
}

export interface DialogueNode {
  id: string;
  speaker: 'player' | 'npc' | 'other';
  text: string;
  prompt?: string; // Player choice text
  responses: DialogueResponse[];
  conditions: Condition[];
  actions: DialogueAction[];
  emotions?: EmotionType;
  animation?: string;
}

export interface DialogueResponse {
  targetNodeId: string;
  conditions: Condition[];
  chance?: number; // Random selection
}

export interface DialogueAction {
  type: 'script' | 'set-stage' | 'give-item' | 'add-perk' | 'start-combat';
  parameters: Record<string, any>;
}

export interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  timestamp?: number;
}

export interface SimulationResult {
  path: QuestStage[];
  choices: UserChoice[];
  finalStage: number;
  success: boolean;
  warnings: string[];
}

// Backwards-compatibility alias
export type QuestSimulationResult = SimulationResult;

export interface UserChoice {
  dialogueNodeId: string;
  responseIndex: number;
} 

export interface PapyrusCode {
  scriptName: string;
  code: string;
  properties: QuestProperty[];
}
